<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="技术日记和杂七杂八的dx">
<meta property="og:type" content="website">
<meta property="og:title" content="地球上的小东西">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="地球上的小东西">
<meta property="og:description" content="技术日记和杂七杂八的dx">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="oldnineping">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>地球上的小东西</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">地球上的小东西</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hiahiahiahia</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/05/HTTPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/05/HTTPS/" class="post-title-link" itemprop="url">HTTPS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 17:36:33" itemprop="dateCreated datePublished" datetime="2021-07-05T17:36:33+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-16 01:51:26" itemprop="dateModified" datetime="2021-07-16T01:51:26+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/https/" itemprop="url" rel="index"><span itemprop="name">https</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>HTTP over SSL 的简称，即工作在 SSL (或 TLS)上的 HTTP。说白了就是加密通信 的 HTTP。</p>
<p>HTTPS本是网景为了安全开发的协议，SSL和HTTP本是共生的，SSL后来独立出来演变成了TLS</p>
<p>TSL定义：Http之下的一个安全层，其实就是http把数据交给TCP之前，先交给TLS加密，再交给IP层传输</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在客户端和服务器之间用非对称加密协商出一套对称密钥，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输</p>
<h3 id="为什么不直接用非对称加密"><a href="#为什么不直接用非对称加密" class="headerlink" title="为什么不直接用非对称加密?"></a>为什么不直接用非对称加密?</h3><p>非对称加密由于使用了复杂了数学原理，因此计算相当复杂，如果完全使用非对称加密来加密通信内容，会严重影响网络通信的性能</p>
<h2 id="HTTPS链接"><a href="#HTTPS链接" class="headerlink" title="HTTPS链接"></a>HTTPS链接</h2><p>HTTP不是稳定链接，稳定的是TCP，HTTPS主要用于加密传输数据。</p>
<h3 id="HTTPS-连接建立的过程"><a href="#HTTPS-连接建立的过程" class="headerlink" title="HTTPS 连接建立的过程"></a>HTTPS 连接建立的过程</h3><p>简单：</p>
<ol>
<li>客户端请求TLS连接 say hello<ol>
<li>ClientHello</li>
<li>ServerHello</li>
</ol>
</li>
<li>服务器发回证书</li>
<li>客户端验证服务器证书</li>
<li>客户端信任服务器后，和服务器协商对称密钥（使用非对称加密）</li>
<li>使用对称加密开始通信</li>
</ol>
<p>详细：</p>
<ol>
<li><p>ClientHello</p>
<p><img src="/2021/07/05/HTTPS/image-20210706183554191.png" alt="image-20210706183554191"></p>
<p>客户端向服务端发送一个字节数据，这个数据被称为ClientHello，是客户端对服务器第一次打招呼的意思</p>
<p>除此之外还包含：</p>
<p><strong>可选的TLS版本的集合</strong>，因为客户端可能包含好几个版本，给服务器一个选择。</p>
<p><strong>可选的加密套件集合</strong>：</p>
<ul>
<li>可选的对称加密算法</li>
<li>可选的非对称加密算法</li>
<li>可选的hash算法</li>
</ul>
<p><strong>客户端的随机数</strong>，同时客户端也会本地保存一份随机数。</p>
<p><img src="/2021/07/05/HTTPS/Xnip2021-07-07_17-38-17.jpg" alt="Xnip2021-07-07_17-38-17"></p>
</li>
<li><p>ServerHello</p>
<p><img src="/2021/07/05/HTTPS/image-20210707174217872.png" alt="image-20210707174217872"></p>
<p>服务端返回一个自己的 Server Hello数据，表示响应客户端请求。1字节数据后面会紧跟着：</p>
<ul>
<li>服务端选好的TLS版本，加密套件</li>
<li>服务端随机数（服务端也会保存一份）</li>
</ul>
<p><img src="/2021/07/05/HTTPS/Xnip2021-07-07_17-47-04.jpg" alt="Xnip2021-07-07_17-47-04"></p>
</li>
<li><p>服务端发送证书到客户端</p>
<p>服务端发送证书给给客户端 ，其中数据包括：</p>
<ol>
<li>服务器证书 （内容包含服务器主机名，证书名等，但最重要的数据是服务端公钥）</li>
<li>服务器证书的签名</li>
<li>证书签发机构的证书（包含签发机构的名字，地区等，最重要的是用于验证这个<code>服务端公钥签名</code>的公钥，也就是服务器服务器公钥的公钥）</li>
<li>证书签发机构的证书的签名</li>
<li>根证书的相关信息（证书签发机构的签发机构的公钥）</li>
</ol>
<p>根证书：系统中默认可以无条件信任的证书，比如Mac中的钥匙串。</p>
<p>服务器证书的最大作用证书中的服务器公钥对数据非对称加密信息，和服务端协商一个对称加密密钥。</p>
<p><img src="/2021/07/05/HTTPS/Xnip2021-07-07_19-35-05.jpg" alt="Xnip2021-07-07_19-35-05"></p>
</li>
<li><p>客户端验证证书是否可信：（大量使用数字签名（非对称加密）技术）</p>
<p>为了保证服务器证书（也就是服务器公钥）的可信，我们需要一个公钥来验证服务器证书的签名是否正确，这个用来验证服务器证书签名的公钥就是 证书签发机构的证书。</p>
<p>但是证书签发机构可能也会被篡改，所以需要一个公钥来验证签发机构的证书的签名，这个用于验证签发机构的签名的公钥就是 根证书。</p>
<p>因为系统里已经内置了根证书，所以我们只需要读取服务端发送的根证书相关的信息即可。</p>
<p>除此之外，我们还需要验证服务器证书中的Host是否是我们想要的。</p>
<p><strong>若黑客只更换Host不修改其他信息，是否能通过验证</strong></p>
<p>不能，因为签名是对整个服务器证书的全部数据做的，只改Host hash值也会改变。</p>
</li>
<li><p>Pre-masterSecret</p>
<p><img src="/2021/07/05/HTTPS/image-20210708145309372.png" alt="image-20210708145309372"></p>
<ol>
<li><p>客户端再次发送一次随机数，不过这次是通过服务端公钥加密过的。</p>
</li>
<li><p>接下来，客户端和服务端会结合之前发送的随机数计算出Master Secret</p>
</li>
<li><p>Master Secret会生成一些密钥（6个），可以实现对称加密通信</p>
<ul>
<li>客户端加密密钥</li>
<li>服务端加密密钥</li>
<li>客户端 MAC secret</li>
<li>服务端 MAC secret</li>
</ul>
</li>
</ol>
<p><strong>Pre-masterSecret一个随机数就可以计算MasterSecret，为什么要结合之前发的两个个随机数？</strong></p>
<p>虽然之前发送的随机数没有被加密，但是可以用它们防止重放攻击（Replay attack）如果你将今天的请求信息都保存下来在第二天发送，服务器会返回不同的随机数让你本地存储的信息失效。</p>
<p><strong>为什么生成两个加密密钥？</strong></p>
<p>因为客户端和服务端通信的时候各自使用不同的密钥。为了防止恶意将客户端发送的信息再发回来，由于密钥不同就根本无法解析，也就不会把这种重复发送的消息当作服务端发回来的。</p>
<p><strong>MAC secret</strong></p>
<p>是HMAC hash-based message authenticate code 带密钥的hash算法。不仅能验证数据的指纹，还能验证身份，且不能被公众验证身份。</p>
<p><img src="/2021/07/05/HTTPS/image-20210708160808284.png" alt="image-20210708160808284"></p>
</li>
<li><p>客户端通知:将使用加密通信 </p>
<p><img src="/2021/07/05/HTTPS/Xnip2021-07-08_16-05-31.jpg" alt="Xnip2021-07-08_16-05-31"></p>
</li>
<li><p>客户端发送:Finished</p>
<p>将前面五步的内容结合，用客户端加密密钥加密，再做一个HMAC ，再由服务器验证</p>
<p><img src="/2021/07/05/HTTPS/image-20210708161110520.png" alt="image-20210708161110520"></p>
</li>
<li><p>服务器通知:将使用加密通信 </p>
<p><img src="/2021/07/05/HTTPS/image-20210708161150472.png" alt="image-20210708161150472"></p>
</li>
<li><p>服务器发送:Finished</p>
<p>将前面五步的内容结合，用服务端密钥加密在做一个HMAC，再由客户端验证，内容会比客户端Finished发送的多一点。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/02/TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/" class="post-title-link" itemprop="url">TCP/IP协议族</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 17:07:33" itemprop="dateCreated datePublished" datetime="2021-07-02T17:07:33+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-28 18:19:39" itemprop="dateModified" datetime="2021-07-28T18:19:39+08:00">2021-07-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/TCP-IP/" itemprop="url" rel="index"><span itemprop="name">TCP/IP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><p>概念：一系列协议组成的网络分层模型。</p>
<h2 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a><strong>为什么要分层？</strong></h2><p>因为网络不稳定。</p>
<p><strong>网络不稳定造成的问题：</strong></p>
<ul>
<li><p>传输较大数据时，在复杂网络环境中容易传输失败。</p>
</li>
<li><p>若传输失败时，需要把整个报文重新传因此</p>
</li>
</ul>
<p>为了解决这些问题：我们需要将报文分块，传输成功后接收方再将报文拼装好。</p>
<p><strong>分块传输的优点：</strong></p>
<ul>
<li><p>数据分块后，体积变小了，提高了传输的成功率</p>
</li>
<li><p>数据分块后，若传输失败，可以只重新传失败的数据块而不是重传全部数据</p>
</li>
</ul>
<p><strong>实际应用中，我们使用的网络协议不止有HTTP，还有FTP，DNS等协议都有分块传输的需求，我们需要划分两个层级：</strong></p>
<ol>
<li>HTTP，FTP，DNS等协议组成的应用层。</li>
<li>用于分块传输/接收组装报文的传输层。</li>
</ol>
<p><strong>两层分层仍然不能满足实际应用，因为不是所有请求都是需要失败重传的</strong>，游戏/直播等追求实时性的应用是不需要失败重传的，使用的是UDP协议，而失败重传的是TCP协议，所以我们需要拆分一个网络层（IP层）来支持传输层，进行网络数据传输。</p>
<p><strong>最后，网络层（IP层）也只是一个协议/标准，我们仍然需要真正的物理层面的支持</strong>，这部分能力被划分为数据链路层。</p>
<img src="/2021/07/02/TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/image-20210705143657813.png" alt="image-20210705143657813" style="zoom:50%;">

<ul>
<li><p>Application Layer 应用层:HTTP、FTP、DNS </p>
</li>
<li><p>Transport Layer 传输层:TCP、UDP</p>
</li>
<li><p>Internet Layer 网络层:IP</p>
</li>
<li><p>Link Layer 数据链路层:以太网、Wi-Fi</p>
</li>
</ul>
<h2 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h2><h3 id="TCP链接"><a href="#TCP链接" class="headerlink" title="TCP链接"></a>TCP链接</h3><p>链接：通信双方互相确认可以通信</p>
<p>建立链接：通信双方建立确认「可以通信」，不会将对方的消息丢弃，即为「建立连接」</p>
<p>TCP链接是有状态的（HTTP是无状态的）</p>
<p>所谓状态是指：我不用每次通信都告知对方自己是谁，要请求什么，对方已经了解你的状态了。</p>
<p>而Http则需要每次请求时都带上header等信息确认状态。</p>
<h3 id="Java中的TCP实现-：Socket-套接字"><a href="#Java中的TCP实现-：Socket-套接字" class="headerlink" title="Java中的TCP实现 ：Socket(套接字)"></a>Java中的TCP实现 ：Socket(套接字)</h3><p>是对TCP端口的具象化，可以收发消息。</p>
<p>端口：  和外界链接，确认对象状态需要一个收发器，这个收发器就是端口。它只和链接对象做交互，这样的话每个对象对应的链接身份一定是确认过的。Java中端口的具像化则是套接字（Socket英文原意则为插座，正如连根线相连需要插座一样）</p>
<img src="/2021/07/02/TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/image-20210705152317860.png" alt="image-20210705152317860" style="zoom:50%;">

<h3 id="TCP连接的建立与关闭"><a href="#TCP连接的建立与关闭" class="headerlink" title="TCP连接的建立与关闭"></a>TCP连接的建立与关闭</h3><p>Tcp报文结构：首部+数据</p>
<p>首部部分字段定义：</p>
<p>序号（seq number）：TCP链接中传送到字节流中的每一个字节都按顺序编号。首部的序号指本报文段发送的数据的第一个字节的序号。</p>
<p>两个ACK：一个是确认值(Acknowledgement)，为1便是确认连接，是首部的一个字段。<br>另一个是确认编号(Acknowledgement Number)，即接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。</p>
<p>同步（syn）：建立连接时用来同步序号。</p>
<p>终止FIN：用来释放一个链接。</p>
<h4 id="建立："><a href="#建立：" class="headerlink" title="建立："></a>建立：</h4><p>三次握手：</p>
<p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信 息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p>
<p>简单模型：</p>
<ol>
<li>A给B发一个消息 </li>
<li>B：知道了，我也要给你发消息</li>
<li>A: 我也知道你要给我发消息了</li>
</ol>
<p>详细：</p>
<p><strong>第一次握手(SYN=1, seq=x):</strong> </p>
<p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头 的序列号(Sequence Number)字段里。发送完毕后，客户端进入 SYN_SEND 状态。</p>
<p><strong>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)：</strong></p>
<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域 里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入</p>
<p>SYN_RCVD 状态。</p>
<p><strong>第三次握手(ACK=1，ACKnum=y+1)：</strong></p>
<p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确 定字段中发送给对方，并且在数据段放写ISN的+1<br> 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手 结束。</p>
<p>完成三次握手，主机A与主机B开始传送数据。</p>
<p><strong>注意</strong> ：因为一个SYN将占用一个序号，所以要加1。</p>
<p>各个状态名称与含义</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- CLOSED: 这个没什么好说的了，表示初始状态。 </span><br><span class="line">- LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。 </span><br><span class="line">- SYN_RECV: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本 上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态 时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。 </span><br><span class="line">- SYN_SENT: 这个状态与SYN_RECV遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状 态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</span><br><span class="line">- ESTABLISHED：这个容易理解了，表示连接已经建立了。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/02/TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/image-20210708150804856.png" alt="image-20210708150804856"></p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>为什么关闭：省资源</p>
<p>怎么关闭：释放链接</p>
<p>四次挥手</p>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<p>简单：</p>
<p>第一条</p>
<p>A：我没有消息给你了</p>
<p>B：我知道了</p>
<p>第二条：</p>
<p>B：我也没有消息给你了</p>
<p>A：我也知道了</p>
<p>为何分两条发：A不发送的时候，B可能还有消息要发送。</p>
<p>详细：</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p>
<ol>
<li>**第一次挥手(FIN=1，seq=x)**假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然 可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。</li>
<li><strong>第二次挥手(ACK=1，ACKnum=x+1</strong>)服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了户端关闭连接的请求，但还没有准备好关闭 连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务 器端关闭连接。</li>
<li><strong>第三次挥手(FIN=1，seq=y)</strong> 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 </li>
<li><strong>第四次挥手(ACK=1，ACKnum=y+1)</strong><br>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间(两个最大段生命周期，2MSL，2 Maximum Segment Lifetime)之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 四次挥手的示意图如下:</li>
</ol>
<p><img src="/2021/07/02/TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/image-20210708144606170.png" alt="image-20210708144606170"></p>
<h2 id="⻓连接"><a href="#⻓连接" class="headerlink" title="⻓连接"></a>⻓连接</h2><h3 id="为什么要⻓连接"><a href="#为什么要⻓连接" class="headerlink" title="为什么要⻓连接?"></a>为什么要⻓连接?</h3><p>因为移动网络并不在 Internet 中，而是在运营商的内网，并不具有真正的公网 IP， 因此当某个 TCP 连接在一段时间不通信之后，网关会出于网络性能考虑而关闭这条 TCP 连接和公网的连接通道，导致这个 TCP 端口不再能收到外部通信消息，即 TCP 连接被动关闭。</p>
<h3 id="⻓连接的实现方式"><a href="#⻓连接的实现方式" class="headerlink" title="⻓连接的实现方式"></a>⻓连接的实现方式</h3><p>心跳。即在一定间隔时间内，使用 TCP 连接发送超短无意义消息来让网关不能将自 己定义为「空闲连接」，从而防止网关将自己的连接关闭。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/" class="post-title-link" itemprop="url">登陆和授权</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-02 12:45:47 / 修改时间：17:09:19" itemprop="dateCreated datePublished" datetime="2021-07-02T12:45:47+08:00">2021-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/http/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/" itemprop="url" rel="index"><span itemprop="name">登陆和授权</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="登陆和授权"><a href="#登陆和授权" class="headerlink" title="登陆和授权"></a>登陆和授权</h1><h2 id="登录和授权的区别："><a href="#登录和授权的区别：" class="headerlink" title="登录和授权的区别："></a>登录和授权的区别：</h2><ul>
<li>登录:身份认证，即确认「你是你」的过程</li>
<li>授权:由身份或持有的令牌确认享有某些权限(例如获取用户信息)。</li>
</ul>
<p>登录过程实质上的目的也是为了确认权限。因此，在实际的应用中，多数场景下的「登录」和「授权」界限是模糊的。</p>
<h2 id="HTTP-中确认授权-或登录-的两种方式"><a href="#HTTP-中确认授权-或登录-的两种方式" class="headerlink" title="HTTP 中确认授权(或登录)的两种方式"></a>HTTP 中确认授权(或登录)的两种方式</h2><ol>
<li>通过Cookie</li>
<li>通过Authorization Header</li>
</ol>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>起源:「购物⻋」功能的需求，由 Netscape 浏览器开发团队打造。 工作机制:</p>
<ol>
<li><p>服务器需要客户端保存的内容，放在 Set-Cookie headers 里返回，客户端会自动保存。</p>
</li>
<li><p>客户端保存的 Cookies，会在之后的所有请求里都携带进 Cookie header 里发回给服务器。</p>
</li>
<li><p>客户端保存Cookie是按照服务器域名来分类的，例如shop.com发回的 Cookie 保存下来以后，在之后向 games.com 的请求中并不会携带。</p>
</li>
<li><p>客户端保存的Cookie在超时后会被删除、没有设置超时时间的Cookie (称作 Session Cookie)在浏览器关闭后就会自动删除;另外，服务器也可以主动删除还未过期的客户端 Cookies。</p>
</li>
</ol>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702125123536.png" alt="image-20210702125123536">                          </p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702125143369.png" alt="image-20210702125143369">                                           <img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702125945817.png" alt="image-20210702125945817">                                                                                                                     </p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702130012721.png" alt="image-20210702130012721"></p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702130035733.png" alt="image-20210702130035733"></p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702130044015.png" alt="image-20210702130044015"></p>
<h4 id="Cookie-的作用"><a href="#Cookie-的作用" class="headerlink" title="Cookie 的作用"></a>Cookie 的作用</h4><blockquote>
<p>会话（Session）也是用户状态机制。Cookie是存本地的，Session是存服务器的。</p>
<p>由于HTTP是无状态的请求无法确定用户状态，服务器通过存储SessionId并配合Cookie验证用户是否登陆。</p>
</blockquote>
<ul>
<li> 会话管理:登录状态、购物⻋</li>
</ul>
<ol>
<li><p>登陆后服务器会记录此次会话（Session）并声称SessionId<br><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702130814894.png" alt="image-20210702130814894"></p>
</li>
<li><p>服务端返回SessionId给客户端<br><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702130838821.png" alt="image-20210702130838821"></p>
</li>
<li><p>客户端本地存储SessionId</p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702130849455.png" alt="image-20210702130849455"></p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702130859160.png" alt="image-20210702130859160"></p>
</li>
</ol>
<ul>
<li><p>个性化:用户偏好、主题 </p>
<p>服务器记录clientId来存储风格，和Session类似</p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702130955005.png" alt="image-20210702130955005"><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702131004645.png" alt="image-20210702131004645"></p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702131028541.png" alt="image-20210702131028541"></p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702131010998.png" alt="image-20210702131010998"></p>
</li>
<li><p>Tracking:分析用户行为</p>
<p><img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702131252119.png" alt="image-20210702131252119"></p>
</li>
</ul>
<h4 id="XSS-Cross-site-scripting-了解即可-跨站脚本攻击。"><a href="#XSS-Cross-site-scripting-了解即可-跨站脚本攻击。" class="headerlink" title="XSS (Cross-site scripting)(了解即可):跨站脚本攻击。"></a>XSS (Cross-site scripting)(了解即可):跨站脚本攻击。</h4><p>即使用 JavaScript 拿 到浏览器的 Cookie 之后，发送到自己的网站，以这种方式来盗取用户 Cookie。应对方式:Server 在发送 Cookie 时，敏感的 Cookie 加上 HttpOnly。</p>
<p>应对方式:HttpOnly——这个 Cookie 只能用于 HTTP 请求，不能被 JavaScript 调用。它可以防止本地代码滥用 Cookie。</p>
<h4 id="XSRF-Cross-site-request-forgery-了解即可-跨站请求伪造。"><a href="#XSRF-Cross-site-request-forgery-了解即可-跨站请求伪造。" class="headerlink" title="XSRF (Cross-site request forgery)(了解即可):跨站请求伪造。"></a>XSRF (Cross-site request forgery)(了解即可):跨站请求伪造。</h4><p>即在用户不知情的情况下访问已经保存了 Cookie 的网站，以此来越权操作用户账户(例如 盗取用户资金)。应对方式主要是从服务器安全⻆度考虑，就不多说了。</p>
<p>应对方式:Referer 校验。是浏览器自动加的header，如果是从其他网站跳转的，referer中会存储跳转来源，我们可以强制网站不接受从其他网站跳转而来的请求，也可以根据referer 判断来源网站是否在白名单中。</p>
<h3 id="Authorization-（现在常用）"><a href="#Authorization-（现在常用）" class="headerlink" title="Authorization （现在常用）"></a>Authorization （现在常用）</h3><p>两种主流方式: Basic 和 Bearer</p>
<h4 id="Basic"><a href="#Basic" class="headerlink" title="Basic:"></a>Basic:</h4><ul>
<li>格式:Authorization: Basic <a href="username:password(Base64ed)">username:password(Base64ed)</a></li>
<li>风险:header可以被解码（base64）,在http请求中会被截获，可以使用https解决。本地存储的token可能被盗，可以通过加密本地存储。</li>
</ul>
<h4 id="Bearer"><a href="#Bearer" class="headerlink" title="Bearer:"></a>Bearer:</h4><ul>
<li><p>格式:Authorization: Bearer <bearer token></bearer></p>
</li>
<li><p>bearer token 的获取方式:通过 OAuth2 的授权流程</p>
<p>OAuth2 的流程:</p>
<ol>
<li><p>第三方网站向授权方网站申请第三方授权合作，拿到clientid和client secret</p>
</li>
<li><p>用户在使用第三方网站时，点击「通过XX(如GitHub)授权」按钮，第三方 网站将⻚面跳转到授权方网站，并传入 client id 作为自己的身份标识</p>
</li>
<li><p>授权方网站根据clientid，将第三方网站的信息和第三方网站需要的用户权 限展示给用户，并询问用户是否同意授权</p>
</li>
<li><p>用户点击「同意授权」按钮后，授权方网站将⻚面跳转回第三方网站，并传 入 Authorization code 作为用户认可的凭证。</p>
</li>
<li><p>第三方网站将Authorization code发送回自己的服务器</p>
</li>
<li><p>服务器将Authorization code和自己的client secret一并发送给授权方的服务器(必须https)，授权方服务器在验证通过后，返回 access token。OAuth 流程结束。</p>
</li>
<li><p>在上面的过程结束之后，第三方网站的服务器(或者有时客户端也会)就可以使用 access token 作为用户授权的令牌，向授权方网站发送请求来获取 用户信息或操作用户账户。但这已经在 OAuth 流程之外。</p>
</li>
</ol>
</li>
<li><p>为什么 OAuth 要引入 Authorization code，并需要申请授权的第三方将 Authorization code 发送回自己的服务器，再从服务器来获取 access token， 而不是直接返回 access token ?这样复杂的流程意义何在?</p>
<p> 为了安全。OAuth 不强制授权流程必须使用 HTTPS，因此需要保证当通信路径中存在窃听者时， 依然具有足够高的安全性。</p>
</li>
<li><p>第三方 App 通过微信登录的流程，也是一个 OAuth2 流程:</p>
<ol>
<li><p>第三方App向腾讯申请第三方授权合作，拿到clientid和clientsecret</p>
</li>
<li><p>用户在使用第三方App时，点击「通过微信登录」，第三方App将使用微信 SDK 跳转到微信，并传入自己的 client id 作为自己的身份标识</p>
</li>
<li><p>微信通过和服务器交互，拿到第三方App的信息，并显示在界面中，然后询问用户是否同意授权该 App 使用微信来登录</p>
</li>
<li><p>用户点击「使用微信登录」后，微信和服务器交互将授权信息提交，然后跳转回第三方 App，并传入 Authorization code 作为用户认可的凭证</p>
</li>
<li><p>第三方App调用自己服务器的「微信登录」Api，并传入Authorization code，然后等待服务器的响应</p>
</li>
<li><p>服务器在收到登录请求后，拿收到的Authorizationcode去向微信的第三方授权接口发送请求，将 Authorization code 和自己的 client secret 一起作为参数发送，微信在验证通过后，返回 access token</p>
</li>
<li><p>服务器在收到accesstoken后，立即拿着access token去向微信的用户信息接口发送请求，微信验证通过后，返回用户信息</p>
</li>
<li><p>服务器在收到用户信息后，在自己的数据库中为用户创建一个账户，并使用从微信服务器拿来的用户信息填入自己的数据库，以及将用户的 ID 和用户的微信 ID 做关联</p>
</li>
<li><p>用户创建完成后，服务器向客户端的请求发送响应，传送回刚创建好的用户信息</p>
</li>
<li><p>客户端收到服务器响应，用户登录成功</p>
</li>
</ol>
</li>
<li><p>在自家 App 中使用 Bearer token</p>
<p>有的 App 会在 Api 的设计中，将登录和授权设计成类似 OAuth2 的过程，但简 化掉 Authorization code 概念。即:登录接口请求成功时，会返回 access token，然后客户端在之后的请求中，就可以使用这个 access token 来当做 bearer token 进行用户操作了。</p>
</li>
<li><p>Refresh token</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;token_type&quot;: &quot;Bearer&quot;,</span><br><span class="line">    &quot;access_token&quot;: &quot;xxxxx&quot;,</span><br><span class="line">    &quot;refresh_token&quot;: &quot;xxxxx&quot;,</span><br><span class="line">    &quot;expires_time&quot;: &quot;xxxxx&quot;</span><br></pre></td></tr></table></figure>
<p>}</p>
<p>用法:access token 有失效时间，在它失效后，调用 refresh token 接口，传入 refresh_token 来获取新的 access token。</p>
<img src="/2021/07/02/%E7%99%BB%E9%99%86%E5%92%8C%E6%8E%88%E6%9D%83/image-20210702162801669.png" alt="image-20210702162801669" style="zoom:50%;">

<p><strong>目的:</strong></p>
<p>安全。当 access token 失窃，由于它有失效时间，因此坏人只有较短的时间来「做坏事」;同时，由于(在标准的 OAuth2 流程中)refresh token 永 远只存在与第三方服务的服务器中，因此 refresh token 几乎没有失窃的⻛险。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/01/Android%E9%9D%A2%E7%BB%8F%EF%BC%9A%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/01/Android%E9%9D%A2%E7%BB%8F%EF%BC%9A%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Android面经：优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 23:54:27" itemprop="dateCreated datePublished" datetime="2021-07-01T23:54:27+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-02 00:04:40" itemprop="dateModified" datetime="2021-07-02T00:04:40+08:00">2021-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android面经：优化"><a href="#Android面经：优化" class="headerlink" title="Android面经：优化"></a>Android面经：优化</h1><h2 id="UI渲染优化"><a href="#UI渲染优化" class="headerlink" title="UI渲染优化"></a>UI渲染优化</h2><h3 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h3><p>内存抖动，所谓内存抖动就是短时间产生大量对象又在短时间内马上释放。<br>短时间产生大量对象超出阈值，内存不够，同样会触发GC操作。</p>
<p>在onDraw()方法中创建的对象要么赋值给局部变量，要么赋值给成员变量，赋值给局部变量时，onDraw()方法退出后就再也没有其他地方引用到这个对象，下次gc时就会被回收，赋值给成员变量时，下次onDraw()方法内会对该成员变量重新赋值，旧的对象变的没有任何引用，下次gc时会被回收。如果在onDraw()方法中创建的对象被加入一个List类型成员变量中，只有在view被回收时才会被回收，因为每个新创建的对象都被list强引用，可能导致内存溢出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/30/%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81Hash%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81Hash%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/" class="post-title-link" itemprop="url">编码、加密、Hash、序列化和字符集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 16:06:55" itemprop="dateCreated datePublished" datetime="2021-06-30T16:06:55+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 19:18:28" itemprop="dateModified" datetime="2021-07-01T19:18:28+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="编码、加密、Hash、序列化和字符集"><a href="#编码、加密、Hash、序列化和字符集" class="headerlink" title="编码、加密、Hash、序列化和字符集"></a>编码、加密、Hash、序列化和字符集</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="古典密码学"><a href="#古典密码学" class="headerlink" title="古典密码学"></a>古典密码学</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">起源于古代战争:在战争中，为了防止书信被截获后重要信息泄露，人们开始对书</span><br><span class="line">信进行加密。</span><br></pre></td></tr></table></figure>
<h4 id="移位式加密"><a href="#移位式加密" class="headerlink" title="移位式加密"></a>移位式加密</h4><p>如密码棒，使用布条缠绕在木棒上的方式来对书信进行加密。<br>加密算法:缠绕后书写<br>密钥: 木棒的尺寸</p>
<h4 id="替换式加密"><a href="#替换式加密" class="headerlink" title="替换式加密"></a>替换式加密</h4><p>按规则使用不同的文字来替换掉原先的文字来进行加密。</p>
<p>码表: </p>
<p>原始字符:ABCDEFGHIJKLMNOPQRSTUVWXYZ </p>
<p>密码字符:BCDEFGHIJKLMNOPQRSTUVWXYZA </p>
<p>原始书信:I love you<br>加密书信:J mpwf zpv<br>解读后:I love you</p>
<p>加密算法:替换文字<br>密钥:替换的码表</p>
<h3 id="现代密码学"><a href="#现代密码学" class="headerlink" title="现代密码学"></a>现代密码学</h3><p>可以加密任何二进制数据<br>非对称加密的出现使得密码学有了更广泛的用途:数字签名</p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>加密：通信双方使用同一个密钥，使用加密算法配合上密钥来加密，得到无意义的数据即为密文。</p>
<p>解密：使用加密过程的完全逆过程配合密钥来进行解密，得到原数据。</p>
<p>简化模型即上面的古典密码学中替换式加密的模型:对文字进行规则化替换来加<br>密，对密文进行逆向的规则化替换来解密。</p>
<p><img src="/2021/06/30/%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81Hash%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/image-20210630182947664.png" alt="image-20210630182947664"></p>
<h5 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h5><p>DES(56 位密钥，密钥太短而逐渐被弃用)、AES(128 位、192 位、256 位密钥， 现在最流行)</p>
<h5 id="对称加密的作用"><a href="#对称加密的作用" class="headerlink" title="对称加密的作用"></a>对称加密的作用</h5><p>加密通信，防止信息在不安全网络上被截获后，信息被人读取或篡改。</p>
<p>对称加密(如 <strong>AES</strong>)的破解 </p>
<h5 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h5><p>拿到一组或多组原文-密文对 设法找到一个密钥，这个密钥可以将这些原文-密文对中的原文加密为密文，以 及将密文解密为原文的组合，即为成功破解</p>
<h5 id="反破解"><a href="#反破解" class="headerlink" title="反破解"></a>反破解</h5><p>一种优秀的对称加密算法的标准是，让破解者找不到比穷举法(暴力破解法)更有效的破解手段，并且穷举法的破解时间足够⻓(例如数千年)。</p>
<h5 id="对称加密的缺点"><a href="#对称加密的缺点" class="headerlink" title="对称加密的缺点"></a>对称加密的缺点</h5><p>密钥泄露:不能在不安全网络上传输密钥，一旦密钥泄露则加密通信失败。</p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>使用公钥对数据进行加密得到密文;使用私钥对数据进行解密得到原数据。</p>
<p>非对称加密使用的是复杂的数学技巧，在古典密码学中没有对应的原型。</p>
<img src="/2021/06/30/%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81Hash%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/image-20210630183135104.png" alt="image-20210630183135104" style="zoom:50%;">

<p>使用非对称加密通信，可以在不可信网络上将双方的公钥传给对方，然后在发消息前分别对消息使用对方的公钥来加密和使用自己的私钥来签名，做到不可信网络上的可靠密钥传播及加密通信。</p>
<img src="/2021/06/30/%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81Hash%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/image-20210630183157872.png" alt="image-20210630183157872" style="zoom:50%;">

<p>由于私钥和公钥互相可解，因此非对称加密还可以应用于数字签名技术。</p>
<p>ps：（公钥一般是私钥算出来的，私钥不适合暴露，因为可以计算出来，比特币的公钥使用的椭圆曲线算法）</p>
<img src="/2021/06/30/%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81Hash%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/image-20210630183246700.png" alt="image-20210630183246700" style="zoom:50%;">

<p>通常会对原数据 hash 以后对 hash 签名，然后附加在原数据的后面作为签名。这是 为了让数据更小。</p>
<p><img src="/2021/06/30/%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81Hash%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/image-20210630183321546.png" alt="image-20210630183321546"></p>
<p>ps一个简单的模型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原数据：110 算法：加法 加密密钥：4 解密密钥 6</span><br><span class="line">加密： 110 按位+4  </span><br><span class="line">加密结果：554</span><br><span class="line">解密： 554 按位+6</span><br><span class="line">解密结果： 11，11，</span><br></pre></td></tr></table></figure>


<h5 id="经典算法-1"><a href="#经典算法-1" class="headerlink" title="经典算法"></a>经典算法</h5><p><strong>RSA</strong>(可用于加密和签名)、<strong>DSA</strong>(仅用于签名，但速度更快)</p>
<h5 id="非对称加密的优缺点"><a href="#非对称加密的优缺点" class="headerlink" title="非对称加密的优缺点"></a>非对称加密的优缺点</h5><p>  优点:可以在不安全网络上传输密钥<br>  缺点:计算复杂，因此性能相比对称加密差很多</p>
<h5 id="非对称加密-如-RSA、ECDSA-的破解-破解思路"><a href="#非对称加密-如-RSA、ECDSA-的破解-破解思路" class="headerlink" title="非对称加密(如 RSA、ECDSA)的破解 破解思路"></a>非对称加密(如 <strong>RSA</strong>、<strong>ECDSA</strong>)的破解 破解思路</h5><p>和对称加密不同之处在于，非对称加密的公钥很容易获得，因此制造原文-密文 对是没有困难的事 所以，非对称加密的关键只在于，如何找到一个正确的私钥，可以解密所有经过 公钥加密过的密文。找到这样的私钥即为成功破解 由于非对称加密的自身特性，怎样通过公钥来推断出私钥通常是一种思路(例如 RSA)，但往往最佳手段依然是穷举法，只是和对称加密破解的区别在于，对称 加密破解是不断尝试自己的新密钥是否可以将自己拿到的原文-密文对进行加密 和解密，而非对称加密时不断尝试自己的新私钥是否和公钥互相可解。</p>
<h5 id="反破解-1"><a href="#反破解-1" class="headerlink" title="反破解"></a>反破解</h5><p>和对称加密一样，非对称加密算法优秀的标准同样在于，让破解者找不到比穷举法<br>更有效的破解手段，并且穷举法的破解时间足够⻓。</p>
<h3 id="密码学密钥和登录密码"><a href="#密码学密钥和登录密码" class="headerlink" title="密码学密钥和登录密码"></a>密码学密钥和登录密码</h3><p>密钥(key)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">场景:用于加密和解密</span><br><span class="line">目的:保证数据被盗时不会被人读懂内容</span><br><span class="line">焦点:数据</span><br></pre></td></tr></table></figure>
<p>登录密码(password)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   场景:用户进入网站或游戏前的身份验证</span><br><span class="line">   目的:数据提供方或应用服务方对账户拥有者数据的保护，保证「你是你」</span><br><span class="line">   的时候才提供权限</span><br><span class="line">   焦点:身份</span><br><span class="line">上面这些区别不必背会，理解就可以了</span><br></pre></td></tr></table></figure>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>将二进制数据转换成由 64 个字符组成的字符串的编码算法 </p>
<h4 id="什么是二进制数据"><a href="#什么是二进制数据" class="headerlink" title="什么是二进制数据?"></a>什么是二进制数据?</h4><p>  广义:所有计算机数据都是二进制数据<br>  狭义:非文本数据即二进制数据</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>将原数据每 6 位对应成 Base 64 索引表中的一个字符编排成一个字符串(每个字符 8 位)。</p>
<h4 id="Base64-索引表"><a href="#Base64-索引表" class="headerlink" title="Base64 索引表"></a>Base64 索引表</h4><img src="/2021/06/30/%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81Hash%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/image-20210630180946380.png" alt="image-20210630180946380" style="zoom:50%;">

<p>编码示例:把「Man」进行 Base64 编码</p>
<p><img src="/2021/06/30/%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%E3%80%81Hash%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/image-20210630181039083.png" alt="image-20210630181039083"></p>
<p>编码示例:Base64 的末尾补足</p>
<h4 id="Base64-的用途"><a href="#Base64-的用途" class="headerlink" title="Base64 的用途"></a>Base64 的用途</h4><ol>
<li>将二进制数据扩充了储存和传输途径(例如可以把数据保存到文本文件、可以通 过聊天对话框或短信形式发送二进制数据、可以在 URL 中加入简单的二进制数据)</li>
<li>普通的字符串在经过Base64编码后的结果会变得肉眼不可读，因此可以适用于 一定条件下的防偷窥(较少用)</li>
</ol>
<h4 id="Base64-的缺点"><a href="#Base64-的缺点" class="headerlink" title="Base64 的缺点"></a>Base64 的缺点</h4><p> 因为自身的原理(6 位变 8 位)，因此每次 Base64 编码之后，数据都会增大约1/3，所以会影响存储和传输性能。</p>
<h4 id="「Base64-加密图片传输更安全和高效」"><a href="#「Base64-加密图片传输更安全和高效」" class="headerlink" title="「Base64 加密图片传输更安全和高效」"></a>「Base64 加密图片传输更安全和高效」</h4><p>???</p>
<p>不。首先，Base64 并不是加密;另外，Base64 会导致数据增大 1/3，降低网络性 能，增大用户流量开销，是画蛇添足的手段。(最好不要拿来 diss 你们公司的后端 哟，友善)</p>
<p>Base64 对图片进行编码的用于在于，有时需要使用文本形式来传输图片。除此之 外，完全没必要使用 Base64 对图片进行额外处理。</p>
<h4 id="变种-Base58"><a href="#变种-Base58" class="headerlink" title="变种:Base58"></a>变种:Base58</h4><p>比特币使用的编码方式，去掉了 Base64 中的数字 “0”，字母大写 “O”，字母大写</p>
<p>“I”，和字母小写 “l”，以及 “+” 和 “/“ 符号，用于比特币地址的表示。</p>
<p>Base58 对于 Base64 的改动，主要目的在于用户的便捷性。由于去掉了难以区分的 字符，使得 Base58 对于「人工抄写」更加方便。另外，去掉了 “+” “/“ 号后也让大 多数的软件可以方便双击选取。</p>
<h3 id="URL-Encoding-使用的百分号编码"><a href="#URL-Encoding-使用的百分号编码" class="headerlink" title="URL Encoding 使用的百分号编码"></a>URL Encoding 使用的百分号编码</h3><p> 在 URL 的字符串中，对一些不用于特殊用途的保留字符，使用百分号 “%” 为前缀进行单编码，以避免出现解析错误。</p>
<p>例如，要在 <a target="_blank" rel="noopener" href="http://hencoder.com/users">http://hencoder.com/users</a> 后面添加查询字符串，查询 name 为「隐秘&amp;伟大」的用户，如果直接写成 <a target="_blank" rel="noopener" href="http://hencoder.com/user/?name=%E9%9A%90%E7%A7%98&amp;%E4%BC%9F%E5%A4%A7">http://hencoder.com/user/?name=隐秘&amp;伟大</a> ，”&amp;” 符号就会被解析为分隔符号，因此需要对它进行转码，转码后的 URL 为 http: //hencoder.com/user/?name=隐秘%26伟大 。</p>
<p>这种编码仅用于 URL，目的是避免解析错误的出现。 </p>
<h3 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>  压缩:将数据使用更具有存储优势的编码算法进行编码（换一种存储方式，减小存储空间）。<br>  解压缩:将压缩数据解码还原成原来的形式，以方便使用。</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>减小数据占用的存储空间。</p>
<h4 id="粗暴算法举例"><a href="#粗暴算法举例" class="headerlink" title="粗暴算法举例"></a>粗暴算法举例</h4><p>将下面文本内容压缩:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb</span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">使用某种算法压缩后的数据为:</span><br><span class="line">   compress:a:1062;b:105</span><br><span class="line"> 注:具体的压缩场景有很多，因此压缩算法也会复杂得多，上面只是一个原型</span><br><span class="line"> 算法。</span><br></pre></td></tr></table></figure>
<h4 id="压缩是编码吗"><a href="#压缩是编码吗" class="headerlink" title="压缩是编码吗?"></a>压缩是编码吗?</h4><p>是。所谓编码，即把数据从一种形式转换为另一种形式。压缩过程属于编码过程，<br>解压缩过程属于解码过程。</p>
<h4 id="常⻅压缩算法"><a href="#常⻅压缩算法" class="headerlink" title="常⻅压缩算法"></a>常⻅压缩算法</h4><p>DEFLATE（zip是归档过程，即把所有文档打包，顺便会做压缩，算法交deflate）、JPEG、MP3 等。</p>
<h3 id="图片与音频、视频（媒体数据）编解码"><a href="#图片与音频、视频（媒体数据）编解码" class="headerlink" title="图片与音频、视频（媒体数据）编解码"></a>图片与音频、视频（媒体数据）编解码</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p>将图像、音频、视频数据通过编码来转换成存档形式(编码)，以及从存档形式转<br>换回来(解码)。</p>
<h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>存储和压缩媒体数据(大多数媒体编码算法会压缩数据，但不是全部)。</p>
<p>有损压缩：不可逆，压缩过程丢弃一些数据，减少体积。</p>
<p>无损压缩：编码后可以解码回原数据，无缝转换，不丢弃收据，可逆。</p>
<h4 id="图片压缩粗暴算法举例"><a href="#图片压缩粗暴算法举例" class="headerlink" title="图片压缩粗暴算法举例"></a>图片压缩粗暴算法举例</h4><p>一张纯白(白色的 16 进制数值为 0xffffff)的 64x64 不透明像素图片，原数据格式 大致为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">width:64;height:64;fffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">ffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">fffffffffffffffffffffffffffffffff.......ffffff</span><br><span class="line">使用某种算法压缩后的数据为:</span><br><span class="line">   width:64;height:64;ffffff:[0,0]-[63,63]</span><br><span class="line"> 注:具体的压缩场景有很多，因此压缩算法也会复杂得多，上面只是一个原型</span><br><span class="line"> 算法。</span><br><span class="line">音频与视频的编码与上面的图片编码同理。</span><br></pre></td></tr></table></figure>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>把数据对象(一般是内存中的，例如 JVM 中的对象)转换成字节序列的过程。对象 在程序内存里的存放形式是散乱的(存放在不同的内存区域、并且由引用进行 接)，通过序列化可以把内存中的对象转换成一个字节序列，从而使用 byte[] 等形 式进行本地存储或网络传输，在需要的时候重新组装(反序列化)来使用。</p>
<h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><p>让内存中的对象可以被储存和传输。</p>
<h4 id="序列化是编码吗"><a href="#序列化是编码吗" class="headerlink" title="序列化是编码吗?"></a>序列化是编码吗?</h4><p>不是</p>
<h4 id="和编码的区别"><a href="#和编码的区别" class="headerlink" title="和编码的区别"></a>和编码的区别</h4><p>编码是把数据由一种数据格式转换成另一种数据格式;而序列化是把数据由内存中<br>的对象(而不是某种具体的格式)转换成字节序列。</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>把任意数据转换成指定大小范围(通常很小，例如 256 字节以内)的数据。 </p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>相当于从数据中提出摘要信息，因此最主要用途是数字指纹。</p>
<h4 id="经典算法-2"><a href="#经典算法-2" class="headerlink" title="经典算法"></a>经典算法</h4><p>MD5，SHA1，SHA256 等 </p>
<h4 id="Hash-的实际用途-数据完整性验证"><a href="#Hash-的实际用途-数据完整性验证" class="headerlink" title="Hash 的实际用途:数据完整性验证"></a>Hash 的实际用途:数据完整性验证</h4><p>从网络上下载文件后，通过比对文件的 Hash 值(例如 MD5、SHA1)，可以确认下载的文件是否有损坏。如果下载的文件 Hash 值和文件提供方给出的 Hash 值一致， 则证明下载的文件是完好无损的。</p>
<h4 id="Hash-的实际用途-快速查找"><a href="#Hash-的实际用途-快速查找" class="headerlink" title="Hash 的实际用途:快速查找"></a>Hash 的实际用途:快速查找</h4><p>HashMap和HashCode(); </p>
<p>一般来说hashcode 不够精细，hashcode不同可以确定两个对象一定不同，但是相等也不代表两个对象一定相等，需要equals 进行更高精度的比较，所以可以实现快速查找。</p>
<h4 id="Hash-的实际用途：唯一性验证"><a href="#Hash-的实际用途：唯一性验证" class="headerlink" title="Hash 的实际用途：唯一性验证"></a>Hash 的实际用途：唯一性验证</h4><p> 例如 Java 中的 hashCode() 方法。</p>
<h5 id="为什么每次重写-equals-方法都需要同事修改HashCode-方法"><a href="#为什么每次重写-equals-方法都需要同事修改HashCode-方法" class="headerlink" title="为什么每次重写 equals() 方法都需要同事修改HashCode()方法?"></a>为什么每次重写 equals() 方法都需要同事修改HashCode()方法?</h5><p>因为Hash 相关类（HashMap）初步判断是否相等会先用HashCode()比较而不是直接用equals。</p>
<h5 id="怎么重写-hashCode-方法"><a href="#怎么重写-hashCode-方法" class="headerlink" title="怎么重写 hashCode 方法?"></a>怎么重写 hashCode 方法?</h5><p>把 equals() 方法中的每个用于判断相等的变量都放进 hashCode() 中，一起生成一 个尽量不会碰撞的整数即可</p>
<h4 id="Hash-的实际用途-隐私保护"><a href="#Hash-的实际用途-隐私保护" class="headerlink" title="Hash 的实际用途:隐私保护"></a>Hash 的实际用途:隐私保护</h4><p>当重要数据必须暴露的时候，有事可以选择暴露它的 Hash 值(例如 MD5)，以保障原数据的安全。例如网站登录时，可以只保存用户密码的 Hash 值，在每次登录验 证时只需要将输入的密码的 Hash 值和数据库中保存的 Hash 值作比对就好，网站无 需知道用户的密码。这样，当网站数据失窃时，用户不会因为自己的密码被盗导致 其他网站的安全也受到威胁。</p>
<p>注意:这不属于加密。</p>
<p>彩虹表：</p>
<p>常用密码的hash映射值数据库表表，如果你注册的网站脱库（数据库被盗），而你设置的密码很常见，那么即使网站存储的是hash值，你的密码也会很快在彩虹表中找到从而暴露。</p>
<p>加盐：密码 经历hash之前先加入其他数据，提高破解难度。</p>
<h4 id="Hash-是编码吗"><a href="#Hash-是编码吗" class="headerlink" title="Hash 是编码吗?"></a>Hash 是编码吗?</h4><p> 不是。 Hash 是单向过程，往往是不可逆的，无法进行逆向恢复操作，因此 Hash 不属于编码。</p>
<h4 id="Hash是加密吗"><a href="#Hash是加密吗" class="headerlink" title="Hash是加密吗?"></a>Hash是加密吗?</h4><p> 不是。Hash 是单向过程，无法进行逆向回复操作，因此 Hash 不属于加密。(记住，MD5 不是加密!)</p>
<h4 id="但百度百科说它是加密"><a href="#但百度百科说它是加密" class="headerlink" title="但百度百科说它是加密?"></a>但百度百科说它是加密?</h4><p>它说错啦!</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义:"></a>含义:</h3><p>一个由整数向现实世界中的文字符号的 Map</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支:"></a>分支:</h3><ul>
<li>ASCII:128 个字符，1 字节 </li>
<li>ISO-8859-1:对 ASCII 进行扩充，1 字节 </li>
<li>Unicode:13 万个字符，多字节<ul>
<li>UTF-8:Unicode 的编码分支</li>
<li>UTF-16 :Unicode 的编码分支</li>
</ul>
</li>
<li>GBK / GB2312 / GB18030:中国自研标准，多字节，字符集 + 编码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/29/Http%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/29/Http%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Http的原理和工作机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-29 14:03:13" itemprop="dateCreated datePublished" datetime="2021-06-29T14:03:13+08:00">2021-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-12 05:37:48" itemprop="dateModified" datetime="2021-08-12T05:37:48+08:00">2021-08-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C/http/" itemprop="url" rel="index"><span itemprop="name">http</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Http-基础"><a href="#Http-基础" class="headerlink" title="Http 基础"></a>Http 基础</h1><h2 id="Http的原理和工作机制"><a href="#Http的原理和工作机制" class="headerlink" title="Http的原理和工作机制"></a>Http的原理和工作机制</h2><h3 id="Http-定义-Http到底是什么"><a href="#Http-定义-Http到底是什么" class="headerlink" title="Http 定义 Http到底是什么"></a>Http 定义 Http到底是什么</h3><p>直观印象：</p>
<ol>
<li>浏览器输入地址，打开网页</li>
<li>Android发送请求，返回对应的内容</li>
</ol>
<p>HyperText Transfer Protocol 超文本传输协议</p>
<ul>
<li><p>超文本：在电脑显示的，含有可以指向其他文本的文本</p>
<p>其实就是Html，http最初就是为了传输Html文档而诞生的。</p>
<p>HyperText ，所谓的超其实是可扩展的意思。</p>
</li>
</ul>
<h4 id="HTTP-的工作方式"><a href="#HTTP-的工作方式" class="headerlink" title="HTTP 的工作方式"></a><strong>HTTP</strong> 的工作方式</h4><h5 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器 :"></a>浏览器 :</h5><p>用户输入地址后回⻋或点击链接 -&gt; 浏览器拼装 HTTP 报文并发送请求给服务器 -&gt; 服 务器处理请求后发送响应报文给浏览器 -&gt; 浏览器解析响应报文并使用渲染引擎显示 到界面</p>
<h5 id="手机-App"><a href="#手机-App" class="headerlink" title="手机 App :"></a>手机 <strong>App</strong> :</h5><p>用户点击或界面自动触发联网需求 -&gt; Android 代码调用拼装 HTTP 报文并发送请求 到服务器 -&gt; 服务器处理请求后发送响应报文给手机 -&gt; Android 代码处理响应报文并 作出相应处理(如储存数据、加工数据、显示数据到界面)</p>
<h3 id="URL-gt-HTTP报文"><a href="#URL-gt-HTTP报文" class="headerlink" title="URL -&gt; HTTP报文"></a>URL -&gt; HTTP报文</h3><h4 id="URL-格式"><a href="#URL-格式" class="headerlink" title="URL 格式"></a><strong>URL</strong> 格式</h4><p>三部分:协议类型、服务器地址(和端口号)、路径(Path) 协议类型://服务器地址[:端口号]/路径</p>
<p> <a target="_blank" rel="noopener" href="http://hencoder.com/users?gender=male">http://hencoder.com/users?gender=male</a></p>
<p>在浏览器输入Url会被转化成请求报文。</p>
<h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><p>请求/响应报文都是由三大部分组成的</p>
<p>第一行（请求/状态行）+Headers+Body</p>
<p>Header和Body两者基本相同</p>
<p>请求报文的第一行（请求行）：method + path + HTTP version组成（Host不是给服务器看的，是给主机的，所以不属于请求行，属于Header）</p>
<p>响应报文的第一行（请求行）：HTTP version +status code+status message组成</p>
<h4 id="请求报文-Request"><a href="#请求报文-Request" class="headerlink" title="请求报文 Request"></a>请求报文 Request</h4><p><img src="/2021/06/29/Http%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/image-20210625164634531.png" alt="image-20210625164634531">         </p>
<p>Host不是给服务器看的，是给主机的，所以不属于请求行。</p>
<p>​      Http 有，0.9 1.1 2.0版本，0.9已经废弃，1.1正被大量使用，正在向2.0迁移</p>
<p>Body，提供给服务器看的具体内容（一般般业务相关），不是必须的。</p>
<p>Body是提供给服务器，让服务器去处理的内容，而用来定位请求的都在Head中。</p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="/2021/06/29/Http%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/image-20210625164714772.png" alt="image-20210625164714772"></p>
<p>和请求报文（Request）基本一样，</p>
<p>除了第一行，叫状态行。返回了一个状态码和状态信息，是这次请求的简单描述。</p>
<h2 id="Http的请求方法和状态码"><a href="#Http的请求方法和状态码" class="headerlink" title="Http的请求方法和状态码"></a>Http的请求方法和状态码</h2><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><blockquote>
<p>重复执行多次结果还是一样，就是有幂等性</p>
</blockquote>
<h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><ul>
<li>获取资源，没有Body,具有幂等性</li>
<li>是第一个版本（0.9）就存在的方法，在浏览器输入地址调用的就是Get方法，它不对服务器的数据进行操作。</li>
</ul>
<blockquote>
<p>Body是操作服务器数据用的，里面的的内容是给服务器读的，作为只获取数据不操作数据的Get请求<strong>自然不需要Body</strong>，</p>
<p>如果想传递参数，就要拼在Requst 请求行等path上 比如 /user/1 传递参数1</p>
</blockquote>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string"></span> /users/1 <span class="string"></span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.github.com</span><br></pre></td></tr></table></figure>
<p>对应 Retrofit 的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> String id,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Query(&quot;gender&quot;)</span> String gender)</span></span>;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>在Get 增加Body标签，Retrofit甚至会报错。</p>
</blockquote>
<h4 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h4><ul>
<li>增加和修改资源，有且一定有Body，不具有幂等性</li>
</ul>
<blockquote>
<p>既然要新增/修改资源，不增加参数（Body）服务器自然无法修改</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string"></span> /users <span class="string"></span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.github.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>13</span><br><span class="line">name=rengwuxian&amp;gender=male</span><br></pre></td></tr></table></figure>
<p>对应 Retrofit 的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line"><span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">addUser</span><span class="params">(<span class="meta">@Field(&quot;name&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Field(&quot;gender&quot;)</span> String gender)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h4><ul>
<li>修改（只修改），有Body，具有幂等性</li>
</ul>
<p>Post的和Put的区别</p>
<table>
<thead>
<tr>
<th align="center">相似</th>
<th align="center">区别</th>
</tr>
</thead>
<tbody><tr>
<td align="center">都可以修改数据都符合标准</td>
<td align="center">Post不具有幂等性，执行多次返回不同的结果，因为它可以增加资源。Put具有幂等性，执行多次返回相同的结果，例如多次修改性别为女，结果用户的性别还是女。</td>
</tr>
</tbody></table>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string"></span> /users/1 <span class="string"></span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.github.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>13</span><br><span class="line">gender=female</span><br></pre></td></tr></table></figure>
<p>对应 Retrofit 的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line"><span class="meta">@PUT(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">updateGender</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> String id,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Field(&quot;gender&quot;)</span> String gender)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><ul>
<li>删除资源，没有Body，有幂等性（删除用户1，重复执行无反应，因为已经删除了，从结果来看是一样的）</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Delete /users/1 Http/1.1</span><br><span class="line">Host api.github.com  </span><br></pre></td></tr></table></figure>
<p>从path就足以定位用户删除了，无需Body</p>
<p>对应 Retrofit 的代码:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@DELETE(&quot;/users/&#123;id&#125;&quot;)</span><br><span class="line">Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id,</span><br><span class="line">@Query(&quot;gender&quot;) String gender);</span><br></pre></td></tr></table></figure>
<h4 id="Head"><a href="#Head" class="headerlink" title="Head"></a>Head</h4><p>和Get请求完全相同，返回响应没有Body，其他请求方法的响应都是有Body的。可以快速得到资源信息。</p>
<h3 id="状态码-（日常中最重要的2打头-成功，4打头客户端错误。）"><a href="#状态码-（日常中最重要的2打头-成功，4打头客户端错误。）" class="headerlink" title="状态码 （日常中最重要的2打头 成功，4打头客户端错误。）"></a>状态码 （日常中最重要的2打头 成功，4打头客户端错误。）</h3><ul>
<li><p>作用： 对结果作出类型化的描述（如获得成功，内容未找到）</p>
<ul>
<li><p>1xx:临时性消息。如:</p>
<ul>
<li><p>100 (继续发送)，如果你发送的文件太大，想分段发送。</p>
<p>Header传<code>Excpet： 100-continue</code>，</p>
<p>服务器响应<code>HTTP/1.1 100</code>代表允许你继续发送。 </p>
<p>发送成功后返回<code>HTTP/1.1 200</code>或者201</p>
</li>
<li><p>101(正在切换协议 比如http1.1和http2.0的请求不兼容，</p>
<p> 一般会加一个<code>Upgrade： h2c</code>的header试着请求，询问服务器是否支持<code>Http2.0</code>，</p>
<p> 服务器响应<code>HTTP/1.1 101</code>，则代表服务器支持http2.0</p>
<p> 服务器响应<code>HTTP/1.1 200</code>，代表不识别Http2.0的请求) </p>
</li>
</ul>
</li>
<li><p>2xx:成功。最典型的是 200(OK)、201(创建成功)。</p>
</li>
<li><p>3xx:重定向。如 301(永久移动)、302(暂时移动)、304(内容未改变)。 对于浏览器来说表现一样，</p>
<p>但是301可以通知搜索引擎，你的网站已迁移，搜索引擎会将权重转移到新域名。</p>
</li>
<li><p>4xx:客户端错误。如 400(客户端请求错误)、401(认证失败)、403(被禁 止)、404(找不到内容)。</p>
</li>
<li><p>5xx:服务器错误。如 500(服务器内部错误)</p>
</li>
</ul>
</li>
</ul>
<p>日常中最重要的2打头 成功，4打头客户端错误。</p>
<h2 id="HTTP的Header和Body"><a href="#HTTP的Header和Body" class="headerlink" title="HTTP的Header和Body"></a>HTTP的Header和Body</h2><p>Body是报文的核心，但是所有的Body都是配合Header使用的，提交用户信息有多个方法，都是由Header定义的。</p>
<p>Header是Http消息的元数据（metadata） 即<strong>数据的数据</strong> 关于数据的数据，数据的属性。</p>
<h3 id="Host-目标主机名-，作用是给DNS查询IP地址，交给主机查找子主机。"><a href="#Host-目标主机名-，作用是给DNS查询IP地址，交给主机查找子主机。" class="headerlink" title="Host 目标主机名 ，作用是给DNS查询IP地址，交给主机查找子主机。"></a>Host 目标主机名 ，作用是给DNS查询IP地址，交给主机查找子主机。</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Get /user/1 HTTP/1.1</span><br><span class="line">Host api.github.com</span><br><span class="line"></span><br><span class="line">host不是查询主机地址的，查询主机地址的工作DNS已经做了。 Domain Name System 域名系统，</span><br><span class="line">所以这个Host 是给对方主机看的，英文一个主机可能有多个虚拟主机（子主机），比如阿里云服务器部署了多个主机</span><br><span class="line">hencoder.com</span><br><span class="line">haocoder.com</span><br></pre></td></tr></table></figure>
<h3 id="ContentType-ContentLength-Body的类型和长度"><a href="#ContentType-ContentLength-Body的类型和长度" class="headerlink" title="ContentType/ContentLength:Body的类型和长度"></a>ContentType/ContentLength:Body的类型和长度</h3><h4 id="ContentLength"><a href="#ContentLength" class="headerlink" title="ContentLength"></a>ContentLength</h4><p>Body的字节长度，因为我门传输的是二进制字符我们不知道主机的解析方式，所以不能🈯️定某个字符作为终止符号（例如用\n做终止符号，可能这次请求的Body数据只是用\n换行），所以我们用二进制字节长度来告诉主机在哪里结束读取/解析Body中的数据。</p>
<h4 id="ContentType内容的类型-，也即是Body的格式"><a href="#ContentType内容的类型-，也即是Body的格式" class="headerlink" title="ContentType内容的类型 ，也即是Body的格式"></a>ContentType内容的类型 ，也即是Body的格式</h4><h5 id="text-html-html文本"><a href="#text-html-html文本" class="headerlink" title="text/html : html文本"></a>text/html : html文本</h5><p>用于浏览器页面的响应。浏览器是不知道用户访问的url的资源类型的，可以是html也可以是Json</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>853</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>




<h5 id="application-x-www-form-urlencoded-普通表单-纯文字表单，也是最早的表单。-image-20200726224015531-Users-zhangzhuang-Library-Application-Support-typora-user-images-image-20200726224015531-png"><a href="#application-x-www-form-urlencoded-普通表单-纯文字表单，也是最早的表单。-image-20200726224015531-Users-zhangzhuang-Library-Application-Support-typora-user-images-image-20200726224015531-png" class="headerlink" title="application/x-www-form-urlencoded: 普通表单/纯文字表单，也是最早的表单。![image-20200726224015531](/Users/zhangzhuang/Library/Application Support/typora-user-images/image-20200726224015531.png)"></a>application/x-www-form-urlencoded: 普通表单/纯文字表单，也是最早的表单。![image-20200726224015531](/Users/zhangzhuang/Library/Application Support/typora-user-images/image-20200726224015531.png)</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string"></span> /users <span class="string"></span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.github.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>27</span><br><span class="line">name=rengwuxian&amp;gender=male</span><br></pre></td></tr></table></figure>
<p>对应 Retrofit 的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line"><span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">addUser</span><span class="params">(<span class="meta">@Field(&quot;name&quot;)</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Field(&quot;gender&quot;)</span> String gender)</span></span></span><br></pre></td></tr></table></figure>


<h5 id="multipart-form-data-Web-⻚面（表单）含有二进制文件时的提交方式。-常见的传图片方式。"><a href="#multipart-form-data-Web-⻚面（表单）含有二进制文件时的提交方式。-常见的传图片方式。" class="headerlink" title="multipart/form-data Web ⻚面（表单）含有二进制文件时的提交方式。 常见的传图片方式。"></a>multipart/form-data Web ⻚面（表单）含有二进制文件时的提交方式。 常见的传图片方式。<img src="/2021/06/29/Http%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/image-20200726225142875.png" alt="image-20200726225142875"></h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string"></span> /users <span class="string"></span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>hencoder.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----</span><br><span class="line">WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Length: 2382</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;name&quot;</span><br><span class="line">rengwuxian</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;avatar&quot;;</span><br><span class="line">filename=&quot;avatar.jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">JFIFHHvOwX9jximQrWa......</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Boundary 后面的一长串文字是为了分割普通表单文字和二进制数据的，如果和二进制数据恰好重复请求就会失败，概率很小。普通表单不会用boundary来分割内容，因为分割用的字符串长度太长，浪费资源。</span><br></pre></td></tr></table></figure>
<p>对应 Retrofit 的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Multipart</span></span><br><span class="line"><span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">addUser</span><span class="params">(<span class="meta">@Part(&quot;name&quot;)</span> RequestBody name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Part(&quot;avatar&quot;)</span> RequestBody avatar)</span></span>;</span><br><span class="line">...</span><br><span class="line">RequestBody namePart =</span><br><span class="line">RequestBody.create(MediaType.parse(<span class="string">&quot;text/plain&quot;</span>),</span><br><span class="line">nameStr);</span><br><span class="line">RequestBody avatarPart =</span><br><span class="line">RequestBody.create(MediaType.parse(<span class="string">&quot;image/jpeg&quot;</span>),</span><br><span class="line">avatarFile);</span><br><span class="line">api.addUser(namePart, avatarPart)</span><br></pre></td></tr></table></figure>
<p> 所以Retrofit 的参数的注解@Query，@Feild 都是因为Content-type不同所以才改变的，它们是不兼容的Body格式。Ps: 用普通表单+base64传图片是错误的。</p>
<p>Retrofit中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body 要用field活着Part注解，它们是不兼容的，user?gender &#x3D; femal  这个@Qurey标签就是管gender字段的</span><br></pre></td></tr></table></figure>
<h5 id="单项内容-文本或非文本都可：application-json-image-jpeg-application-zip-…"><a href="#单项内容-文本或非文本都可：application-json-image-jpeg-application-zip-…" class="headerlink" title="单项内容(文本或非文本都可：application/json , image/jpeg , application/zip …)"></a>单项内容(文本或非文本都可：application/json , image/jpeg , application/zip …)</h5><p>用于 Web Api 的响应或者 POST / PUT 的请求 请求中提交 JSON</p>
<p><strong>application/json , image/jpeg , application/zip …：</strong></p>
<blockquote>
<p>请求中提交Json：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;users HTTP&#x2F;1.1</span><br><span class="line">Host: hencoder.com</span><br><span class="line">Content-Type: application&#x2F;json; charset&#x3D;utf-8</span><br><span class="line">Content-Length: 38</span><br><span class="line">&#123;&quot;name&quot;:&quot;rengwuxian&quot;,&quot;gender&quot;:&quot;male&quot;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/users</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>hencoder.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>38</span><br><span class="line">&#123;&quot;name&quot;:&quot;rengwuxian&quot;,&quot;gender&quot;:&quot;male&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">å<span class="meta">@POST(&quot;/users&quot;)</span></span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">addUser</span><span class="params">(<span class="meta">@Body(&quot;user&quot;)</span> User user)</span></span>;</span><br></pre></td></tr></table></figure>
<p>// 需要使用 JSON 相关的 Converter api.addUser(user);</p>
<p>响应中返回 JSON</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>application/json; charset=utf-8</span><br><span class="line"><span class="attribute">content-length</span><span class="punctuation">: </span>234</span><br><span class="line">[&#123;&quot;login&quot;:&quot;mojombo&quot;,&quot;id&quot;:1,&quot;node_id&quot;:&quot;MDQ6VXNl</span><br><span class="line">cjE=&quot;,&quot;avatar_url&quot;:&quot;https://avatars0.githubuse</span><br><span class="line">rcontent.com/u/1?v=4&quot;,&quot;gravat......</span><br></pre></td></tr></table></figure>


<blockquote>
<p>请求中提交二进制内容</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/user/1/avatar</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>hencoder.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>image/jpeg</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1575</span><br><span class="line">JFIFHH9......</span><br></pre></td></tr></table></figure>
<p>对应 Retrofit 的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST(&quot;users/&#123;id&#125;/avatar&quot;)</span></span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">updateAvatar</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> String id, <span class="meta">@Body</span></span></span></span><br><span class="line"><span class="function"><span class="params">RequestBody avatar)</span></span>;</span><br></pre></td></tr></table></figure>
<p>…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestBody avatarBody =</span><br><span class="line">RequestBody.create(MediaType.parse(<span class="string">&quot;image/jpeg&quot;</span>),</span><br><span class="line">avatarFile);</span><br><span class="line">api.updateAvatar(id, avatarBody)</span><br></pre></td></tr></table></figure>
<p>相应中返回二进制内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>image/jpeg</span><br><span class="line"><span class="attribute">content-length</span><span class="punctuation">: </span>1575</span><br><span class="line">JFIFHH9......</span><br></pre></td></tr></table></figure>
<h3 id="Transfer-chunked-分块传输编码-Chunked-Transfer-Encoding"><a href="#Transfer-chunked-分块传输编码-Chunked-Transfer-Encoding" class="headerlink" title="Transfer: chunked (分块传输编码 Chunked Transfer Encoding)"></a>Transfer: chunked (分块传输编码 Chunked Transfer Encoding)</h3><p>用于当响应发起时，内容⻓度还没能确定的情况下。和 Content-Length 不同时使 用。用途是尽早给出响应，减少用户等待。</p>
<p>格式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line">4 (当前数据块的长度)</span><br><span class="line">Chun</span><br><span class="line">9</span><br><span class="line">ked Trans</span><br><span class="line">12</span><br><span class="line">fer Encoding</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>指定重定向的目标 URL</p>
<h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><p>用户代理，即是谁实际发送请求、接受响应的，例如手机浏览器、某款手机 App。</p>
<h3 id="Range-Accept-Range"><a href="#Range-Accept-Range" class="headerlink" title="Range / Accept-Range"></a>Range / Accept-Range</h3><p>按范围取数据</p>
<p><code>Accept-Range: bytes </code>响应报文中出现，表示服务器支持按字节来取范围数据</p>
<p><code>Range: bytes=&lt;start&gt;-&lt;end&gt; </code>请求报文中出现，表示要取哪段数据</p>
<p><code>Content-Range:&lt;start&gt;-&lt;end&gt;/total</code> 响应报文中出现，表示发送的是哪段 数据</p>
<p>作用:断点续传、多线程下载。</p>
<h3 id="其他-Headers"><a href="#其他-Headers" class="headerlink" title="其他 Headers"></a>其他 Headers</h3><ul>
<li>Accept: 客户端能接受的数据类型。如 text/html </li>
<li>Accept-Charset: 客户端接受的字符集。如 utf-8</li>
<li>Accept-Encoding: 客户端接受的压缩编码类型。如 gzip </li>
<li>Content-Encoding:压缩类型。如 gzip</li>
</ul>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>作用:在客户端或中间网络节点缓存数据，降低从服务器取数据的频率，以提高网络性能。</p>
<p>Cache和Buffer的区别：</p>
<p>Cache：用过了，以后还会用，先存着。</p>
<p>Buffer：针对工作流，下游稍后用，上游先多生产一些。</p>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST 的定义众说纷纭，没有统一答案。 扔物线的观点:REST HTTP 即正确使用 HTTP。包括:</p>
<ul>
<li>使用资源的格式来定义 URL</li>
<li>规范地使用 method 来定义网络请求操作 </li>
<li>规范地使用 status code 来表示响应状态 </li>
<li>其他符合 HTTP 规范的设计准则</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/30/Hexo%20+%20GitHub%20Pages%20+%20Typora%20%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(1)%20Hexo%20%E7%9A%84%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/30/Hexo%20+%20GitHub%20Pages%20+%20Typora%20%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(1)%20Hexo%20%E7%9A%84%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">重新利用hexo和github page 建立了一个blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-30 08:35:31" itemprop="dateCreated datePublished" datetime="2021-04-30T08:35:31+08:00">2021-04-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Hexo-GitHub-Pages-Typora-构建博客-1-Hexo-的安装"><a href="#Hexo-GitHub-Pages-Typora-构建博客-1-Hexo-的安装" class="headerlink" title="Hexo + GitHub Pages + Typora 构建博客 (1) Hexo 的安装"></a>Hexo + GitHub Pages + Typora 构建博客 (1) Hexo 的安装</h2><p>最近在学一些网络知识，但是使用市面上支持 <a target="_blank" rel="noopener" href="https://www.runoob.com/markdown/md-tutorial.html">Markdown </a>的 笔记工具（如简书，有道云笔记，印象笔记）的产品，时常遇到两类问题：</p>
<ol>
<li><p>功能过于复杂（有道，印象），很多功能我用不上，且打开有些卡顿</p>
</li>
<li><p>没有在线存储文件或者图片的能力（Typora）</p>
</li>
<li><p>在线打开操作不够方便，体验不够好（简书，掘金）</p>
</li>
<li><p>需要付费</p>
</li>
</ol>
<p>因此我准备构建一套的博客工具，方案采用</p>
<p> Hexo+Git Page +Typora，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[简易博客系统] --&gt; B(Hexo 生成静态网页)</span><br><span class="line">A --&gt; C(Github Page Mini服务器)</span><br><span class="line">A --&gt; D(Typora Mini客户端 编辑文本)</span><br><span class="line">E[简易博客系统]</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/30/Hexo%20+%20GitHub%20Pages%20+%20Typora%20%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%20(1)%20Hexo%20%E7%9A%84%E5%AE%89%E8%A3%85/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/Kotlin%E6%96%B9%E6%B3%95%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/Kotlin%E6%96%B9%E6%B3%95%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">Kotlin方法与Lambda表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 18:41:00" itemprop="dateCreated datePublished" datetime="2021-04-25T18:41:00+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 00:05:22" itemprop="dateModified" datetime="2021-07-18T00:05:22+08:00">2021-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kotlin/" itemprop="url" rel="index"><span itemprop="name">Kotlin</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kotlin方法与Lambda表达式"><a href="#Kotlin方法与Lambda表达式" class="headerlink" title="Kotlin方法与Lambda表达式"></a>Kotlin方法与Lambda表达式</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/25/Kotlin%E6%96%B9%E6%B3%95%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/12/adb%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/12/adb%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">adb相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-12 19:17:49" itemprop="dateCreated datePublished" datetime="2021-04-12T19:17:49+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-30 08:35:31" itemprop="dateModified" datetime="2021-04-30T08:35:31+08:00">2021-04-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/adb/" itemprop="url" rel="index"><span itemprop="name">adb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="adb相关问题"><a href="#adb相关问题" class="headerlink" title="adb相关问题"></a>adb相关问题</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/12/adb%E7%9B%B8%E5%85%B3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/07/Zygote%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/07/Zygote%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">Zygote的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-07 13:47:03" itemprop="dateCreated datePublished" datetime="2021-04-07T13:47:03+08:00">2021-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-30 08:35:31" itemprop="dateModified" datetime="2021-04-30T08:35:31+08:00">2021-04-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Framework/" itemprop="url" rel="index"><span itemprop="name">Framework</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="oldnineping"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">oldnineping</p>
  <div class="site-description" itemprop="description">技术日记和杂七杂八的dx</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oldnineping</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
