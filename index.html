<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="技术日记和杂七杂八的dx">
<meta property="og:type" content="website">
<meta property="og:title" content="地球上的小东西">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="地球上的小东西">
<meta property="og:description" content="技术日记和杂七杂八的dx">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="oldnineping">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>地球上的小东西</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">地球上的小东西</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hiahiahiahia</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/26/RxJava3%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/26/RxJava3%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">RxJava3原理解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-26 16:40:47" itemprop="dateCreated datePublished" datetime="2021-08-26T16:40:47+08:00">2021-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-06 01:57:15" itemprop="dateModified" datetime="2021-09-06T01:57:15+08:00">2021-09-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/RxJava3/" itemprop="url" rel="index"><span itemprop="name">RxJava3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RxJava-3-的原理完全解析"><a href="#RxJava-3-的原理完全解析" class="headerlink" title="RxJava 3 的原理完全解析"></a>RxJava 3 的原理完全解析</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">				<span class="meta">@GET(<span class="meta-string">&quot;users/&#123;username&#125;/repos&quot;</span>)</span></span><br><span class="line">			  <span class="comment">// Observable和Flow都过重，网络请求 推荐single</span></span><br><span class="line">				<span class="function"><span class="keyword">fun</span> <span class="title">getRepos</span><span class="params">(<span class="meta">@Path(<span class="meta-string">&quot;username&quot;</span>)</span> username: <span class="type">String</span>)</span></span>: Single&lt;List&lt;Repo&gt;&gt;</span><br><span class="line">...</span><br><span class="line">        api.getRepos(<span class="string">&quot;rengwuxian&quot;</span>)</span><br><span class="line">            .subscribeOn(Schedulers.io())<span class="comment">//请求切换到io线程</span></span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())<span class="comment">// 回调在主线程</span></span><br><span class="line">            .subscribe(<span class="keyword">object</span> : SingleObserver&lt;MutableList&lt;Repo&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(repos: <span class="type">MutableList</span>&lt;<span class="type">Repo</span>&gt;)</span></span> &#123;</span><br><span class="line">                    textView.text = <span class="string">&quot;Result :<span class="subst">$&#123;repos!![<span class="number">0</span>].name&#125;</span>&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="type">Disposable</span>?)</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 订阅产生之后就会回调（网络请求之前）所以适合初始化</span></span><br><span class="line">                    <span class="comment">// dispose 丢弃，一般使用时会通知上游停止生产</span></span><br><span class="line">                    textView.text = <span class="string">&quot;正在请求&quot;</span></span><br><span class="line">                    disposeable = d</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                    textView.text = e.message ?: e.javaClass.name</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><p>RxJava 的整体结构是一条链，其中:</p>
<ol>
<li>链的最上游:生产者 Observable</li>
<li>链的最下游:观察者 Observer</li>
<li>链的中间:各个中介节点，既是下游的 Observable，又是上游的 Observer</li>
</ol>
<h2 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h2><p>Single 为例:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> single = Single.just(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"> single.subscribe(<span class="keyword">object</span> : SingleObserver&lt;String?&gt; &#123;</span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(t: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">       textView.text = t</span><br><span class="line">  &#125;</span><br><span class="line">        ...</span><br><span class="line"> &#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span>&lt;<span class="type">@NonNull T</span>&gt; <span class="title">implements</span> <span class="title">SingleSource</span>&lt;<span class="type">T</span>&gt; </span>&#123; </span><br><span class="line"> 	</span><br><span class="line">  <span class="keyword">public</span> static &lt;<span class="meta">@NonNull</span> T&gt; Single&lt;T&gt; just(T item) &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">// 钩子函数，重点在于传入了SingleJust实例</span></span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(new SingleJust&lt;&gt;(item));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> void subscribe(<span class="meta">@NonNull</span> SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">       </span><br><span class="line">				<span class="comment">// 钩子函数，</span></span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重点方法</span></span><br><span class="line">            subscribeActual(observer);</span><br><span class="line">        &#125; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>SingleJust:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleJust</span>&lt;<span class="type">T</span>&gt; <span class="title">extends</span> <span class="title">Single</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleJust(T value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void subscribeActual(SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">      <span class="comment">// Disposable.disposed 表示已经被丢弃</span></span><br><span class="line">      <span class="comment">// singlejust是立刻执行后取消的任务，所以可以直接取消</span></span><br><span class="line">        observer.onSubscribe(Disposable.disposed());</span><br><span class="line">      <span class="comment">// 成功，将内部存储的对象传过去也就是Single.just(&quot;1&quot;)中传的1</span></span><br><span class="line">        observer.onSuccess(value);</span><br><span class="line">      <span class="comment">// 没有onError 因为它是不可能失败的，把一个准备好的对象传过去是不会失败的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210826174653269.png" alt="image-20210826174653269"></p>
<h2 id="操作符-Operator-map-等等"><a href="#操作符-Operator-map-等等" class="headerlink" title="操作符 Operator(map() 等等):"></a>操作符 Operator(map() 等等):</h2><ol>
<li>基于原 Observable 创建一个新的 Observable</li>
<li>Observable 内部创建一个 Observer</li>
<li>通过定制 Observable 的 subscribeActual() 方法和 Observer 的 onSuccess() 方法，来实现自己的中介⻆色(例如数据转换、线程切换)</li>
</ol>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210826174752970.png" alt="image-20210826174752970"></p>
<p>Eg:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">operatorRx</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> single:Single&lt;<span class="built_in">Int</span>&gt; = Single.just(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> singleString = single.map(<span class="keyword">object</span> :Function&lt;<span class="built_in">Int</span>,String&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(t: <span class="type">Int</span>?)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span>  t.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Single.map方法：基于原 Observable 创建一个新的 Observable</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@SchedulerSupport(SchedulerSupport.NONE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;<span class="meta">@NonNull</span> R&gt; Single&lt;R&gt; map(<span class="meta">@NonNull</span> Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper) &#123;</span><br><span class="line">    Objects.requireNonNull(mapper, <span class="string">&quot;mapper is null&quot;</span>);</span><br><span class="line">    <span class="comment">//基于原 Observable 创建一个新的 Observable：创建一个SingleMap，将自己身和需要转换的操作符(map)</span></span><br><span class="line">    <span class="comment">//传过去</span></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(new SingleMap&lt;&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleMap：Observable 内部创建一个 Observer</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleMap</span>&lt;<span class="type">T, R</span>&gt; <span class="title">extends</span> <span class="title">Single</span>&lt;<span class="type">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SingleSource&lt;? extends T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleMap(SingleSource&lt;? extends T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper) &#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">        <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void subscribeActual(<span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> R&gt; t) &#123;</span><br><span class="line">      <span class="comment">// 真正执行的代码，将会创建一个MapSingleObserver</span></span><br><span class="line">        source.subscribe(new MapSingleObserver&lt;T, R&gt;(t, mapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSingleObserver</span>&lt;<span class="type">T, R</span>&gt; <span class="title">implements</span> <span class="title">SingleObserver</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> R&gt; t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapSingleObserver(SingleObserver&lt;? <span class="keyword">super</span> R&gt; t, Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper) &#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onSubscribe(Disposable d) &#123;</span><br><span class="line">            t.onSubscribe(d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onSuccess(T value) &#123;</span><br><span class="line">            R v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 若需要转换则使用传来的操作符接口进行转换</span></span><br><span class="line">                v = Objects.requireNonNull(mapper.apply(value), <span class="string">&quot;The mapper function returned a null value.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(e);</span><br><span class="line">                onError(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">//转换成功后传递给下游（最表面的观察者，也是开发者真正调用的那个接口回调）</span></span><br><span class="line">            t.onSuccess(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若再增加操作符也是一样的，只不过会增加更多的被观察者，观察者</p>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210827153255139.png" alt="image-20210827153255139"></p>
<h2 id="Disposable"><a href="#Disposable" class="headerlink" title="Disposable:"></a>Disposable:</h2><p>上游停止生产，上下游切断联系</p>
<p> 可以通过 dispose() 方法来让上游或内部调度器(或两者都有)停止工作，达到「丢弃」的效果。</p>
<blockquote>
<p> SingleJust，没有延迟没有后续，可以直接取消</p>
</blockquote>
<blockquote>
<p>总结：Disposable是一个桥接器，dispose时，先看这个生产者（被观察者）有没有来自上游的后续任务，有没有自己生产的后续任务（延时任务）停止工作。</p>
</blockquote>
<h3 id="有延迟的任务如何取消"><a href="#有延迟的任务如何取消" class="headerlink" title="有延迟的任务如何取消"></a>有延迟的任务如何取消</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟调用， ，每间隔一秒调用一次</span></span><br><span class="line">Observable.interval(<span class="number">0</span>,<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())<span class="comment">// 延迟发生在子线程，所以回调到主线程主线程</span></span><br><span class="line">    .subscribe(<span class="keyword">object</span>: Observer&lt;<span class="built_in">Long</span>?&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onComplete</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="type">Disposable</span>?)</span></span> &#123; &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNext</span><span class="params">(t: <span class="type">Long</span>?)</span></span> &#123;</span><br><span class="line">            textView.text = t.toString()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>?)</span></span> &#123;&#125;&#125; )</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableInterval</span> <span class="title">extends</span> <span class="title">Observable</span>&lt;<span class="type">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">final</span> long initialDelay;</span><br><span class="line">    <span class="keyword">final</span> long period;</span><br><span class="line">    <span class="keyword">final</span> TimeUnit unit;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void subscribeActual(Observer&lt;? <span class="keyword">super</span> <span class="built_in">Long</span>&gt; observer) &#123;</span><br><span class="line">       <span class="comment">//核心方法 实例化 IntervalObserver(下游的observer)</span></span><br><span class="line">        IntervalObserver <span class="keyword">is</span> = new IntervalObserver(observer);</span><br><span class="line">        ...</span><br><span class="line">      	<span class="keyword">if</span> (sch instanceof TrampolineScheduler) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在后台处理轮训任务，每次执行完毕都会调用  IntervalObserver（is）的run方法</span></span><br><span class="line">            Disposable d = sch.schedulePeriodicallyDirect(<span class="keyword">is</span>, initialDelay, period, unit);</span><br><span class="line">            <span class="keyword">is</span>.setResource(d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 没有继承Observer ,继承了一个可取消的disposable</span></span><br><span class="line">  <span class="comment">// 调用dispose方法时，会调用真正的dispose实现</span></span><br><span class="line">  <span class="comment">// 之所以如此复杂，是因为它既要保持链性结构，又要轮训后执行的run方法和dispose指向同一对象统一管理</span></span><br><span class="line">      static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntervalObserver</span> </span></span><br><span class="line">      extends AtomicReference&lt;Disposable&gt;</span><br><span class="line">      implements Disposable, Runnable &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">public</span> void dispose() &#123;</span><br><span class="line">            DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次轮训回调都会调用一下run方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">get</span>() != DisposableHelper.DISPOSED) &#123;</span><br><span class="line">                downstream.onNext(count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置内部的dispose</span></span><br><span class="line">        <span class="keyword">public</span> void setResource(Disposable d) &#123;</span><br><span class="line">            DisposableHelper.setOnce(<span class="keyword">this</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> DisposableHelper</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 调用内部的disposeable的值</span></span><br><span class="line">  <span class="keyword">public</span> static boolean dispose(AtomicReference&lt;Disposable&gt; field) &#123;</span><br><span class="line">      Disposable current = field.<span class="keyword">get</span>();</span><br><span class="line">      Disposable d = DISPOSED;</span><br><span class="line">    <span class="comment">// 拿到内部的Disposable，若没有被取消，则执行Disposable的dispose方法</span></span><br><span class="line">      <span class="keyword">if</span> (current != d) &#123;</span><br><span class="line">          current = field.getAndSet(d);</span><br><span class="line">          <span class="keyword">if</span> (current != d) &#123;</span><br><span class="line">              <span class="keyword">if</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">                  current.dispose();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 只设置一次disposable对象</span></span><br><span class="line">  <span class="keyword">public</span> static boolean setOnce(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123;</span><br><span class="line">      Objects.requireNonNull(d, <span class="string">&quot;d is null&quot;</span>);</span><br><span class="line">    <span class="comment">//dispose对象为空的时候才设置</span></span><br><span class="line">      <span class="keyword">if</span> (!field.compareAndSet(<span class="literal">null</span>, d)) &#123;</span><br><span class="line">          d.dispose();</span><br><span class="line">          <span class="keyword">if</span> (field.<span class="keyword">get</span>() != DISPOSED) &#123;</span><br><span class="line">              reportDisposableSet();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="有上游的任务该如何取消"><a href="#有上游的任务该如何取消" class="headerlink" title="有上游的任务该如何取消"></a>有上游的任务该如何取消</h3><p>若是没有延迟和后续的single.map：上游dispose对象会直接传递到下一级，取消任务和它无关</p>
<p>若事件是有延迟无后续Singledelay</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Single.just(<span class="number">1</span>)</span><br><span class="line">         .delay(<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line">         .subscribe(<span class="keyword">object</span>: SingleObserver&lt;<span class="built_in">Int</span>?&gt;&#123;</span><br><span class="line">             <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(t: <span class="type">Int</span>?)</span></span> &#123;</span><br><span class="line">             &#125;...&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDelay</span>&lt;<span class="type">T</span>&gt; <span class="title">extends</span> <span class="title">Single</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SingleSource&lt;? extends T&gt; source;</span><br><span class="line">    <span class="keyword">final</span> long time;</span><br><span class="line">    <span class="keyword">final</span> TimeUnit unit;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">final</span> boolean delayError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleDelay(SingleSource&lt;? extends T&gt; source, long time, TimeUnit unit, Scheduler scheduler, boolean delayError) &#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">        <span class="keyword">this</span>.unit = unit;</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">        <span class="keyword">this</span>.delayError = delayError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void subscribeActual(<span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">				<span class="comment">//自己的disposeable 实例</span></span><br><span class="line">        <span class="keyword">final</span> SequentialDisposable sd = new SequentialDisposable();</span><br><span class="line">        observer.onSubscribe(sd);</span><br><span class="line">       <span class="comment">// 不能直接传递上游的disposable，若dipose消息发出时，消息还在上游，上游直接拿到disposable对象，本层终止程序没有问题</span></span><br><span class="line">      <span class="comment">// 若消息已经传到本层级，那么停止消息就应该自己处理（上游singlejust已经没有处理的必要，本层却有延迟功能，这层应该关闭自己的定时器）</span></span><br><span class="line">        source.subscribe(new Delay(sd, observer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Delay</span> <span class="title">implements</span> <span class="title">SingleObserver</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SequentialDisposable sd;</span><br><span class="line">        <span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> T&gt; downstream;</span><br><span class="line"></span><br><span class="line">        Delay(SequentialDisposable sd, SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sd = sd;</span><br><span class="line">            <span class="keyword">this</span>.downstream = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onSubscribe(Disposable d) &#123;</span><br><span class="line">           <span class="comment">//收到上游消息之前，若收到取消任务的通知，直接替换上游的disposable</span></span><br><span class="line">           <span class="comment">//本地的disposable被赋值成上游的，即可通知上游终止任务</span></span><br><span class="line">            sd.replace(d);</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">//若已经收到上游的消息，无论成功失败都需要自己处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onSuccess(<span class="keyword">final</span> T value) &#123;</span><br><span class="line">         		<span class="comment">// disposable替换成线程调度器，若通知取消任务要自主调用线程调度器关闭延时</span></span><br><span class="line">            sd.replace(scheduler.scheduleDirect(new OnSuccess(value), time, unit));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onError(<span class="keyword">final</span> Throwable e) &#123;</span><br><span class="line">          <span class="comment">// disposable替换成线程调度器，若通知取消任务要自主调用线程调度器关闭延时</span></span><br><span class="line">            sd.replace(scheduler.scheduleDirect(new OnError(e), delayError ? time : <span class="number">0</span>, unit));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSuccess</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交给内部的Disposable解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialDisposable</span></span></span><br><span class="line">extends AtomicReference&lt;Disposable&gt;</span><br><span class="line">implements Disposable &#123; ...</span><br><span class="line">    <span class="keyword">public</span> SequentialDisposable(Disposable initial) &#123;</span><br><span class="line">        lazySet(initial);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> boolean replace(Disposable next) &#123;</span><br><span class="line">        <span class="keyword">return</span> DisposableHelper.replace(<span class="keyword">this</span>, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void dispose() &#123;</span><br><span class="line">        DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">    &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有后续无延迟的任务如何取消"><a href="#有后续无延迟的任务如何取消" class="headerlink" title="有后续无延迟的任务如何取消"></a>有后续无延迟的任务如何取消</h3><p>ObservableMap的任务取消</p>
<p>dispose也是拿到上游的disposable进行取消，几乎等同于直接拿到上游的对象进行取消<br>map只是通过包装在消息传达时多做一些操作符操作而已</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="type">T, U</span>&gt; <span class="title">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="type">T, U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function) &#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void subscribeActual(Observer&lt;? <span class="keyword">super</span> U&gt; t) &#123;</span><br><span class="line">        source.subscribe(new MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapObserver</span>&lt;<span class="type">T, U</span>&gt; <span class="title">extends</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="type">T, U</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapObserver(Observer&lt;? <span class="keyword">super</span> U&gt; <span class="keyword">actual</span>, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="keyword">actual</span>);</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onNext(T t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">				...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="type">T, R</span>&gt; <span class="title">implements</span> <span class="title">Observer</span>&lt;<span class="type">T</span>&gt;, <span class="type">QueueDisposable</span>&lt;<span class="type">R</span>&gt; </span>&#123; </span><br><span class="line">  <span class="comment">// 设置下游</span></span><br><span class="line">  <span class="keyword">public</span> BasicFuseableObserver(Observer&lt;? <span class="keyword">super</span> R&gt; downstream) &#123;</span><br><span class="line">        <span class="keyword">this</span>.downstream = downstream;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> void onSubscribe(Disposable d) &#123;</span><br><span class="line">      <span class="comment">//验证过上游</span></span><br><span class="line">        <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.upstream, d)) &#123;</span><br><span class="line">						<span class="comment">// 设置上游</span></span><br><span class="line">            <span class="keyword">this</span>.upstream = d;</span><br><span class="line">            <span class="keyword">if</span> (d instanceof QueueDisposable) &#123;</span><br><span class="line">                <span class="keyword">this</span>.qd = (QueueDisposable&lt;T&gt;)d;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (beforeDownstream()) &#123;</span><br><span class="line"></span><br><span class="line">                downstream.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                afterDownstream();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// dispose也是拿到上游的disposed进行取消，几乎等同于直接拿到上游的对象进行取消</span></span><br><span class="line">  <span class="comment">// map只是通过包装在消息传达时多做一些操作符操作而已</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void dispose() &#123;</span><br><span class="line">        upstream.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有后续有延迟的任务如何取消"><a href="#有后续有延迟的任务如何取消" class="headerlink" title="有后续有延迟的任务如何取消"></a>有后续有延迟的任务如何取消</h3><p>Observable </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; delay(long time, <span class="meta">@NonNull</span> TimeUnit unit, <span class="meta">@NonNull</span> Scheduler scheduler, boolean delayError) &#123;</span><br><span class="line">    Objects.requireNonNull(unit, <span class="string">&quot;unit is null&quot;</span>);</span><br><span class="line">    Objects.requireNonNull(scheduler, <span class="string">&quot;scheduler is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(new ObservableDelay&lt;&gt;(<span class="keyword">this</span>, time, unit, scheduler, delayError));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObservableDelay</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableDelay</span>&lt;<span class="type">T</span>&gt; <span class="title">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="type">T, T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> void subscribeActual(Observer&lt;? <span class="keyword">super</span> T&gt; t) &#123;</span><br><span class="line">        Observer&lt;T&gt; observer;</span><br><span class="line">        <span class="keyword">if</span> (delayError) &#123;</span><br><span class="line">            observer = (Observer&lt;T&gt;)t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            observer = new SerializedObserver&lt;&gt;(t);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 线程调度器，创建延迟任务</span></span><br><span class="line">        Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">        source.subscribe(new DelayObserver&lt;&gt;(observer, delay, unit, w, delayError));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">      static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayObserver</span>&lt;<span class="type">T</span>&gt; <span class="title">implements</span> <span class="title">Observer</span>&lt;<span class="type">T</span>&gt;, <span class="type">Disposable &#123;</span></span></span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; downstream;</span><br><span class="line">        <span class="keyword">final</span> long delay;</span><br><span class="line">        <span class="keyword">final</span> TimeUnit unit;</span><br><span class="line">        <span class="keyword">final</span> Scheduler.Worker w;</span><br><span class="line">        <span class="keyword">final</span> boolean delayError;</span><br><span class="line"></span><br><span class="line">        Disposable upstream;</span><br><span class="line"></span><br><span class="line">        DelayObserver(Observer&lt;? <span class="keyword">super</span> T&gt; <span class="keyword">actual</span>, long delay, TimeUnit unit, Worker w, boolean delayError) &#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.downstream = <span class="keyword">actual</span>;</span><br><span class="line">            <span class="keyword">this</span>.delay = delay;</span><br><span class="line">            <span class="keyword">this</span>.unit = unit;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">            <span class="keyword">this</span>.delayError = delayError;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 上游下游的连接</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onSubscribe(Disposable d) &#123;</span><br><span class="line">          <span class="comment">// 验证上游</span></span><br><span class="line">            <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.upstream, d)) &#123;</span><br><span class="line">              <span class="comment">//上游赋值</span></span><br><span class="line">                <span class="keyword">this</span>.upstream = d;</span><br><span class="line">              <span class="comment">//调用下游的onSubscribe 订阅流程，传递的对象是自身（继承了Disposeable对象）</span></span><br><span class="line">                downstream.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onNext(<span class="keyword">final</span> T t) &#123;</span><br><span class="line">           <span class="comment">// 延迟调度器进行调度</span></span><br><span class="line">            w.schedule(new OnNext(t), delay, unit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onError(<span class="keyword">final</span> Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 延迟调度器进行调度</span></span><br><span class="line">            w.schedule(new OnError(t), delayError ? delay : <span class="number">0</span>, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void dispose() &#123;</span><br><span class="line">            <span class="comment">// 上游取消，不要在发消息了</span></span><br><span class="line">            upstream.dispose();</span><br><span class="line">						<span class="comment">// 延迟调度器也取消，有下游的消息也不要再发了</span></span><br><span class="line">            w.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="线程调度器"><a href="#线程调度器" class="headerlink" title="线程调度器"></a>线程调度器</h2><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn()"></a>subscribeOn()</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在 Scheduler 指定的线程里启动 subscribe()</p>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><ul>
<li>切换起源 Observable 的线程（也就是下游订阅上游事件的时候切线程）;</li>
<li>当多次调用 subscribeOn() 的时候，只有最上面的会对起源 Observable 起作用。</li>
</ul>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210830155354768.png" alt="image-20210830155354768"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleSubscribeOn</span>&lt;<span class="type">T</span>&gt; <span class="title">extends</span> <span class="title">Single</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SingleSource&lt;? extends T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleSubscribeOn(SingleSource&lt;? extends T&gt; source, Scheduler scheduler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void subscribeActual(<span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;&gt;(observer, source);</span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line">				<span class="comment">// 核心方法 切换线程，parent是runnable接口</span></span><br><span class="line">        Disposable f = scheduler.scheduleDirect(parent);</span><br><span class="line">				<span class="comment">// 将上游的disposable对象替换为本地的disposable代理类</span></span><br><span class="line">        parent.task.replace(f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeOnObserver</span>&lt;<span class="type">T</span>&gt;</span></span><br><span class="line">    extends AtomicReference&lt;Disposable&gt;</span><br><span class="line">    implements SingleObserver&lt;T&gt;, Disposable, Runnable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">7000911171163930287L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> T&gt; downstream;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SequentialDisposable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SingleSource&lt;? extends T&gt; source;</span><br><span class="line"></span><br><span class="line">        SubscribeOnObserver(SingleObserver&lt;? <span class="keyword">super</span> T&gt; <span class="keyword">actual</span>, SingleSource&lt;? extends T&gt; source) &#123;</span><br><span class="line">            <span class="keyword">this</span>.downstream = <span class="keyword">actual</span>;</span><br><span class="line">            <span class="keyword">this</span>.source = source;</span><br><span class="line">          	<span class="comment">//task 被赋值，SequentialDisposable 也是个代理类，不执行实际逻辑</span></span><br><span class="line">            <span class="keyword">this</span>.task = new SequentialDisposable();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onSubscribe(Disposable d) &#123;</span><br><span class="line">          <span class="comment">// disposable实际赋值，上游传递来的disposable</span></span><br><span class="line">            DisposableHelper.setOnce(<span class="keyword">this</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onSuccess(T value) &#123;</span><br><span class="line">            downstream.onSuccess(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onError(Throwable e) &#123;</span><br><span class="line">            downstream.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void dispose() &#123;</span><br><span class="line">           <span class="comment">// 通知上游的disposeable取消任务</span></span><br><span class="line">            DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">           <span class="comment">// 通知内部取消任务</span></span><br><span class="line">            task.dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> boolean isDisposed() &#123;</span><br><span class="line">            <span class="keyword">return</span> DisposableHelper.isDisposed(<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">          <span class="comment">// 切换线程后对上游进行订阅</span></span><br><span class="line">            source.subscribe(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialDisposable</span></span></span><br><span class="line">extends AtomicReference&lt;Disposable&gt;</span><br><span class="line">implements Disposable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = -<span class="number">754898800686245608L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SequentialDisposable() &#123;</span><br><span class="line">        <span class="comment">// nothing to do</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> SequentialDisposable(Disposable initial) &#123;</span><br><span class="line">        lazySet(initial);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> boolean update(Disposable next) &#123;</span><br><span class="line">        <span class="keyword">return</span> DisposableHelper.<span class="keyword">set</span>(<span class="keyword">this</span>, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> boolean replace(Disposable next) &#123;</span><br><span class="line">        <span class="keyword">return</span> DisposableHelper.replace(<span class="keyword">this</span>, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void dispose() &#123;</span><br><span class="line">        DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean isDisposed() &#123;</span><br><span class="line">        <span class="keyword">return</span> DisposableHelper.isDisposed(<span class="keyword">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若多次调用subscribeOn方法切换线程，只会有一个线程影响任务的执行，多次调用是没有用的</p>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210830155602490.png" alt="image-20210830155602490"></p>
<h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn()"></a>observeOn()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObserveOn</span>&lt;<span class="type">T</span>&gt; <span class="title">extends</span> <span class="title">Single</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SingleSource&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingleObserveOn(SingleSource&lt;T&gt; source, Scheduler scheduler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void subscribeActual(<span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">       	<span class="comment">// 订阅过程不切线程</span></span><br><span class="line">        source.subscribe(new ObserveOnSingleObserver&lt;&gt;(observer, scheduler));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnSingleObserver</span>&lt;<span class="type">T</span>&gt; <span class="title">extends</span> <span class="title">AtomicReference</span>&lt;<span class="type">Disposable</span>&gt;</span></span><br><span class="line">    implements SingleObserver&lt;T&gt;, Disposable, Runnable &#123;</span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">3528003840217436037L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> T&gt; downstream;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">        T value;</span><br><span class="line">        Throwable error;</span><br><span class="line"></span><br><span class="line">        ObserveOnSingleObserver(SingleObserver&lt;? <span class="keyword">super</span> T&gt; <span class="keyword">actual</span>, Scheduler scheduler) &#123;</span><br><span class="line">            <span class="keyword">this</span>.downstream = <span class="keyword">actual</span>;</span><br><span class="line">            <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onSubscribe(Disposable d) &#123;</span><br><span class="line">           <span class="comment">// 订阅过程，不切换线程</span></span><br><span class="line">            <span class="keyword">if</span> (DisposableHelper.setOnce(<span class="keyword">this</span>, d)) &#123;</span><br><span class="line">               <span class="comment">//赋值dispose（来自上游的disposable），</span></span><br><span class="line">              <span class="comment">//实际上下游取消的时候就会取消掉上游的任务（因为没有切换线程）</span></span><br><span class="line">                downstream.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onSuccess(T value) &#123;</span><br><span class="line">          <span class="comment">// 上游事件到达后切线程</span></span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">          <span class="comment">// 收到线程后再取消，将内部的disposable替换成切线程的任务</span></span><br><span class="line">          <span class="comment">// 不需要通知上游，直接取消即可</span></span><br><span class="line">            Disposable d = scheduler.scheduleDirect(<span class="keyword">this</span>);</span><br><span class="line">            DisposableHelper.replace(<span class="keyword">this</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void onError(Throwable e) &#123;</span><br><span class="line">          <span class="comment">// 事件到达后切线程</span></span><br><span class="line">            <span class="keyword">this</span>.error = e;</span><br><span class="line">          <span class="comment">// 事件到达后取消的是切线程</span></span><br><span class="line">            Disposable d = scheduler.scheduleDirect(<span class="keyword">this</span>);</span><br><span class="line">          <span class="comment">// 将disposable替换呢为b</span></span><br><span class="line">            DisposableHelper.replace(<span class="keyword">this</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            Throwable ex = error;</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">                downstream.onError(ex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                downstream.onSuccess(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void dispose() &#123;</span><br><span class="line">            DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> boolean isDisposed() &#123;</span><br><span class="line">            <span class="keyword">return</span> DisposableHelper.isDisposed(<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在内部创建的 Observer 的 onNext() onError() onSuccess() 等回调方法里，通过 Scheduler 指定的线程来调用下级 Observer 的对应回调方法</p>
<p>在任务下发到下游的时候才切线程，订阅上游事件的时候不切线程</p>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210830155936495.png" alt="image-20210830155936495"></p>
<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><p>切换 observeOn() 下面的 Observer 的回调所在的线程<br> 当多次调用 observeOn() 的时候，每个都会进行一次线程切换，影响范围是它 下面的每个 Observer (除非又遇到新的 observeOn())</p>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210826174959565.png" alt="image-20210826174959565"></p>
<h3 id="Scheduler-的原理"><a href="#Scheduler-的原理" class="headerlink" title="Scheduler 的原理"></a>Scheduler 的原理</h3><ol>
<li><p>Schedulers.newThread() 和 Schedulers.io():</p>
<ul>
<li>当 scheduleDirect() 被调用的时候，会创建一个 Worker，Worker 的内部 会有一个 Executor，由 Executor 来完成实际的线程切换; </li>
<li>scheduleDirect() 还会创建出一个 Disposable 对象，交给外层的 Observer，让它能执行 dispose() 操作，取消订阅链;</li>
<li>newThread() 和 io() 的区别在于，io() 可能会对 Executor 进行重用。</li>
</ul>
</li>
<li><p>androidSchedulers.mainThread():</p>
<p>通过内部的 Handler 把任务放到主线程去做。</p>
</li>
</ol>
<p>Scheduler</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"> <span class="keyword">public</span> Disposable scheduleDirect(<span class="meta">@NonNull</span> Runnable run, long delay, <span class="meta">@NonNull</span> TimeUnit unit) &#123;</span><br><span class="line">     <span class="keyword">final</span> Worker w = createWorker();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">     DisposeTask task = new DisposeTask(decoratedRun, w);</span><br><span class="line"></span><br><span class="line">     w.schedule(task, delay, unit);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> task;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Schedulers-newThread-和iSchedulers-io"><a href="#Schedulers-newThread-和iSchedulers-io" class="headerlink" title="Schedulers.newThread()和iSchedulers.io()"></a>Schedulers.newThread()和iSchedulers.io()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Single.just(<span class="number">1</span>)</span><br><span class="line">    .subscribeOn(Schedulers.newThread())<span class="comment">//newThread()是io的基础</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NewThreadWorker(threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> disposed;</span><br><span class="line">		<span class="comment">//包含一个executor进行线程调度，每次都会用全新的executor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewThreadWorker</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        executor = SchedulerPoolFactory.create(threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerPoolFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">create</span><span class="params">(ThreadFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">1</span>, factory);</span><br><span class="line">        tryPutIntoPool(PURGE_ENABLED, exec);</span><br><span class="line">        <span class="keyword">return</span> exec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IoScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">  	...</span><br><span class="line">		<span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EventLoopWorker(pool.get());</span><br><span class="line">    &#125;  </span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CompositeDisposable tasks;</span><br><span class="line">      <span class="comment">// Executor 重用池，newThread是没有重用池的，这就是io和newThread的区别</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CachedWorkerPool pool;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadWorker threadWorker;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> AtomicBoolean once = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">        EventLoopWorker(CachedWorkerPool pool) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pool = pool;</span><br><span class="line">            <span class="keyword">this</span>.tasks = <span class="keyword">new</span> CompositeDisposable();</span><br><span class="line">            <span class="keyword">this</span>.threadWorker = pool.get();</span><br><span class="line">        &#125;</span><br><span class="line">    ....</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWorker</span> <span class="keyword">extends</span> <span class="title">NewThreadWorker</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 继承了NewThreadWork</span></span><br><span class="line">        <span class="keyword">long</span> expirationTime;</span><br><span class="line"></span><br><span class="line">        ThreadWorker(ThreadFactory threadFactory) &#123;</span><br><span class="line">            <span class="keyword">super</span>(threadFactory);</span><br><span class="line">            <span class="keyword">this</span>.expirationTime = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpirationTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> expirationTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExpirationTime</span><span class="params">(<span class="keyword">long</span> expirationTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.expirationTime = expirationTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h3 id="切到主线程"><a href="#切到主线程" class="headerlink" title="切到主线程"></a>切到主线程</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Single.just(<span class="number">1</span>)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidSchedulers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT</span><br><span class="line">            = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper()), <span class="keyword">true</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;NewApi&quot;)</span> <span class="comment">// Async will only be true when the API is available to call.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (run == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;run == null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;unit == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        run = RxJavaPlugins.onSchedule(run);</span><br><span class="line">        ScheduledRunnable scheduled = <span class="keyword">new</span> ScheduledRunnable(handler, run);</span><br><span class="line">        Message message = Message.obtain(handler, scheduled);</span><br><span class="line">        <span class="keyword">if</span> (async) &#123;</span><br><span class="line">            message.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用handler切回到主线程</span></span><br><span class="line">        handler.sendMessageDelayed(message, unit.toMillis(delay));</span><br><span class="line">        <span class="keyword">return</span> scheduled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/25/Android%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/Android%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android的多线程机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 12:10:57" itemprop="dateCreated datePublished" datetime="2021-08-25T12:10:57+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-27 11:35:03" itemprop="dateModified" datetime="2021-08-27T11:35:03+08:00">2021-08-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android的多线程机制"><a href="#Android的多线程机制" class="headerlink" title="Android的多线程机制"></a>Android的多线程机制</h1><h2 id="Android-Handler-机制模型"><a href="#Android-Handler-机制模型" class="headerlink" title="Android Handler 机制模型"></a>Android Handler 机制模型</h2><p>本质: 在某个指定的运行中的线程上执行代码</p>
<p>思路: 在接受任务的线程上执行循环判断</p>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现:"></a>基本实现:</h3><ul>
<li>Thread 里 while 循环检查</li>
<li>加上 Looper(优势在于自定义 Thread 的代码可以少写很多，,把要处理的任务放入消息队列Messages（一个链表）中)</li>
<li>再加上 Handler进行任务的处理(优势在于功能分拆，而且可以有多个 Handler，hander收到的Message包含int型，runnable【callback】，object)</li>
</ul>
<p>模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Looper looper = <span class="keyword">new</span> Looper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        looper.loop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="keyword">private</span> AtomicBoolean quit = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            quit.set(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 无限循环的线程</span></span><br><span class="line">            <span class="keyword">while</span> (!quit.get()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                        task = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Android-Handler-机制"><a href="#Android-Handler-机制" class="headerlink" title="Android Handler 机制:"></a>Android Handler 机制:</h2><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal:"></a>ThreadLocal:</h3><p>每个线程不共享的内存</p>
<p>Eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadNumber = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadNumber.set(<span class="number">1</span>);</span><br><span class="line">    threadNumber.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadNumber.set(<span class="number">2</span>);</span><br><span class="line">    threadNumber.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>
<p>Android中调用Looper.myLooper() 获取线程持有的Looper对象，会发现它是存储在ThreadLocal中的</p>
<p>Looper:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread:"></a>HandlerThread:</h3><p>具体的线程 </p>
<p>HandlerThread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 启动Looper</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">       <span class="comment">//初始化Looper</span></span><br><span class="line">        onLooperPrepared();</span><br><span class="line">       <span class="comment">// Looper 开启循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper:"></a>Looper:</h3><p>负责循环、条件判断和任务执行 </p>
<p>Looper:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    static <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> static void prepare() &#123;</span><br><span class="line">        prepare(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 初始化，存储当前创建的Looper到ThreadLocal</span></span><br><span class="line">    <span class="keyword">private</span> static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.<span class="keyword">get</span>() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.<span class="keyword">set</span>(new Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 开启Loop循环</span></span><br><span class="line"> 		<span class="keyword">public</span> static void loop() &#123;</span><br><span class="line">       </span><br><span class="line">        ...</span><br><span class="line">				<span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">// 一直拿下一个Message</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            ... </span><br><span class="line">          <span class="comment">//处理Message</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// target是一个Handler ，每个message需要一个Handler来处理</span></span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.<span class="keyword">when</span>) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.<span class="keyword">when</span>, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                        + <span class="built_in">Long</span>.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                        + <span class="built_in">Long</span>.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                        + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler:"></a>Handler:</h3><p>负责任务的定制和线程间传递，本质</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 下发msg</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// callback = runnable</span></span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 执行runnable</span></span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 如果没有callback（runnable）要自己处理message</span></span><br><span class="line">          <span class="comment">// 外界调用它就要自己重写handleMessage 自己定义处理规则</span></span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>创建制定线程/多个Handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread hanlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">Handler handlerSecond = <span class="keyword">new</span> Handler(hanlerThread.getLooper());</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本质是在某个运行中的线程执行指定的代码，Java只能在没有运行的线程中执行代码。</p>
<p>Java的目标是将任务放入后台，Android的线程机制可以指定线程。</p>
<p>Java要是想做到像Android一样循环过程中执行任务，也需要像Android一样不停的循环，再插入任务，不然无法在已运行的线程添加代码。因为线程间的通信只是协同通信，内存/资源共享，线程直接是无法真正对话的。</p>
<h2 id="AsyncTask-的内存泄露"><a href="#AsyncTask-的内存泄露" class="headerlink" title="AsyncTask: 的内存泄露"></a>AsyncTask: 的内存泄露</h2><p>众所周知的原因:AsyncTask 持有外部 Activity 的引用 (官方提示asynctask若不是静态的会持有外部的activity引用导致内存泄漏)</p>
<p>没提到的原因:执行中的线程不会被系统回收</p>
<p>Java 回收策略:没有被 GC Root 直接或间接持有引用的对象，会被回收</p>
<p>所以:</p>
<p>AsyncTask 的内存泄露，其他类型的线程方案(Thread、 Executor、HandlerThread)一样都有，所以不要忽略它们，或者认为 AsyncTask 比别的方案更危险。并没有。</p>
<p>就算是使用 AsyncTask，只要任务的时间不⻓(例如 10 秒之 内)，那就完全没必要做防止内存泄露的处理。</p>
<p>被废弃的原因是因为不好用</p>
<h3 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h3><p>内存中的某个对象已经没用处了但是依然无法被回收。</p>
<h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root:"></a>GC Root:</h3><p>什么是GC Root：</p>
<ol>
<li>运行中的线程</li>
<li>静态对象</li>
<li>来自 native code 中的引用</li>
</ol>
<h2 id="Service-和-IntentService"><a href="#Service-和-IntentService" class="headerlink" title="Service 和 IntentService"></a>Service 和 IntentService</h2><p>Service:后台任务的活动空间（并不会自动切到后台，并不是后台线程）。适用场景:音乐播放器等。</p>
<p>IntentService: 执行单个任务后自动关闭的 Service，既是后台线程工具，又是service工具·</p>
<h2 id="Executor、AsyncTask、HandlerThead、IntentService-的选择"><a href="#Executor、AsyncTask、HandlerThead、IntentService-的选择" class="headerlink" title="Executor、AsyncTask、HandlerThead、IntentService 的选择"></a><strong>Executor</strong>、AsyncTask<strong>、</strong>HandlerThead、<strong>IntentService</strong> 的选择</h2><p>原则:哪个简单用哪个</p>
<ul>
<li>能用 Executor 就用 Executor</li>
<li>需要用到「后台线程推送任务到 UI 线程」时，再考虑 AsyncTask 或者 Handler </li>
<li>HandlerThread 的使用场景:原本它设计的使用场景是「在已经运行的指定线 程上执行代码」，但现实开发中，除了主线程之外，几乎没有这种需求，因为 HandlerThread 和 Executor 相比在实际应用中并没什么优势，反而用起来会麻 烦一点。不过，这二者喜欢用谁就用谁吧。<br> IntentService:首先，它是一个 Service;另外，它在处理线程本身，没有比 Executor 有任何优势</li>
</ul>
<h2 id="关于-Executor-和-HandlerThread-的关闭"><a href="#关于-Executor-和-HandlerThread-的关闭" class="headerlink" title="关于 Executor 和 HandlerThread 的关闭"></a>关于 Executor 和 HandlerThread 的关闭</h2><p>如果在界面组件里创建 Executor 或者 HandlerThread，记得要在关闭的时候(例如 <code>Activity.onDestroy() </code>)关闭 Executor 和 HandlerThread。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">super</span>.onDestroy(); </span><br><span class="line">	executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	handlerThread.quit(); <span class="comment">// 这个其实就是停止 Looper 的循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/24/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">线程间通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-24 16:43:06" itemprop="dateCreated datePublished" datetime="2021-08-24T16:43:06+08:00">2021-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-25 12:08:05" itemprop="dateModified" datetime="2021-08-25T12:08:05+08:00">2021-08-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h2 id="一个线程启动其他线程"><a href="#一个线程启动其他线程" class="headerlink" title="一个线程启动其他线程"></a>一个线程启动其他线程</h2><p>一个线程启动别的线程:new Thread().start()、Executor.execute() 等</p>
<h2 id="一个线程终结其他线程"><a href="#一个线程终结其他线程" class="headerlink" title="一个线程终结其他线程"></a>一个线程终结其他线程</h2><ul>
<li><p>Thread.stop()：强制终结，已启用，无论任务完成与否都会立刻终结会导致程序的不可控。</p>
</li>
<li><p>Thread.interrupt():温和式终结:不立即、不强制。</p>
<p> interrupt()只是将中断状态标记为true，并不是马上终结</p>
<ul>
<li><p>interrupted() 和 isInterrupted():检查(和重置)中断状态</p>
<p>isInterrupted(): 检查中断状态，可以重复使用这个方法判断中断状态</p>
<p>Thread.interrupted(): 检查并重置中断状态，下次再调用它时会返回false</p>
<blockquote>
<p>线程中的内容需要十分配合才会在调用interrupt()之后停止工作，一般会在耗时工作开始之前进行isInterrupted()判断，若线程已被打断则终止。若在耗时工作完成之后再判断只会造成浪费</p>
</blockquote>
</li>
<li><p>InterruptedException:如果在线程「等待」时中断，或者在中断状态 「等待」，直接结束等待过程(因为等待过程什么也不会做，而 interrupt() 的目的是让线程做完收尾工作后尽快终结，所以要跳过等待过程)</p>
<p>也就是线程内部sleep时，线程外部调用了interupted，内部会立刻抛出InterruptedException异常，因为自线程此时没有任何资源操作，系统希望立刻打断线程。</p>
<p>所以在抛出InterruptedException异常时应该做结束线程的收尾工作。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadInteractionDemo</span> <span class="keyword">implements</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isInterrupted()) &#123;</span><br><span class="line">                        <span class="comment">// 擦屁股</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// 擦屁股</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;number: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一个线程和其他线程配合（wait和notify）"><a href="#一个线程和其他线程配合（wait和notify）" class="headerlink" title="一个线程和其他线程配合（wait和notify）"></a>一个线程和其他线程配合（wait和notify）</h2><p>Object.wait() 和 Object.notify() / notifyAll()</p>
<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210825113730312.png" alt="image-20210825113730312" style="zoom:33%;">

<ul>
<li><p>在未达到目标时 wait() </p>
<p>获取锁（monitor）对象的线程，若发现代码块执行的条件不足，可以调用wait方法进入<code>等待区</code>，将锁交还给其他线程使用，注意，等待区可以有不止一个线程等待。</p>
</li>
<li><p>用 while 循环检查 </p>
<p>直到其他线程调用notify()/notifyAll()唤醒线程时,线程才会从<code>等待区</code>出来（若<code>等待区</code>有多个线程，会进行公平竞争）</p>
<ul>
<li><p>notify：通知一个线程从<code>等待区</code>出来（若<code>等待区</code>有多个线程，这样做是危险的）</p>
</li>
<li><p>notifyAll：通知所有<code>等待区</code>线程出来，从<code>等待区</code>出来后，线程也需要和其他线程公平竞争锁，不一定立刻执行</p>
</li>
</ul>
<p>以下例子中，线程会继续while检查条件是否满足，若不满足会继续进入<code>等待区</code>等待</p>
</li>
<li><p>设置完成后 notifyAll()</p>
<p>其他线程若完成对资源的修改可以notifyAll() 或者notify唤醒<code>等待区</code>的线程，wait和notify/notifyAll必须成对出现，否则调用了wait的线程将会一直等待</p>
</li>
<li><p>wait() 和 notify() / notifyAll() 都需要放在synchronized同步代码块里</p>
<p>因为等待的过程正是要通知monitor去缓存区获取等待中的线程，若monitor不存在等待也无意义</p>
</li>
<li><p>wait()，notify()，notifyAll()都是Object的方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitDemo</span> <span class="keyword">implements</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String sharedString;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sharedString = <span class="string">&quot;rengwuxian&quot;</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (sharedString == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;String: &quot;</span> + sharedString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        printString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.start();</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        initString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="join和yeid"><a href="#join和yeid" class="headerlink" title="join和yeid"></a>join和yeid</h2><ul>
<li><p>Thread.join():让另一个线程插在自己前面，</p>
<p>像一个更简化的不需要notify的wait方法，把两个并行的线程变成线性的先后关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitDemo</span> <span class="keyword">implements</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String sharedString;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">initString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sharedString = <span class="string">&quot;rengwuxian&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">printString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;String: &quot;</span> + sharedString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        initString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread2.start();</span><br><span class="line">    <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若不让thread2 初始化字符串线程join到前面，print结果为null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        printString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Thread.yield():</p>
<p>暂时(时间非常短)让出自己的时间片给同优先级的线程</p>
<p>它像是一个时间更短更简化的wait，出让时间后也不会等待其他线程执行完，会马上继续执行</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/24/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B604-%E8%8C%83%E5%9B%B4%E8%A3%81%E5%88%87%E5%92%8C%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B604-%E8%8C%83%E5%9B%B4%E8%A3%81%E5%88%87%E5%92%8C%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">自定义view绘制04:范围裁切和几何变换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-24 11:11:05 / 修改时间：16:42:10" itemprop="dateCreated datePublished" datetime="2021-08-24T11:11:05+08:00">2021-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E8%87%AA%E5%AE%9A%E4%B9%89View/" itemprop="url" rel="index"><span itemprop="name">自定义View</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="范围裁切和几何变换"><a href="#范围裁切和几何变换" class="headerlink" title="范围裁切和几何变换"></a>范围裁切和几何变换</h1><h2 id="Canvas-的范围裁切"><a href="#Canvas-的范围裁切" class="headerlink" title="Canvas 的范围裁切"></a>Canvas 的范围裁切</h2><ul>
<li><p>clipRect： 切成矩形</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//裁切 左上角</span></span><br><span class="line">   canvas.clipRect(BITMAP_PADDING, BITMAP_PADDING,</span><br><span class="line">       BITMAP_PADDING+ BITMAP_SIZE/<span class="number">2</span></span><br><span class="line">       ,BITMAP_PADDING+ BITMAP_SIZE/<span class="number">2</span>)</span><br><span class="line">   canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING,paint)</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824113648691.png" alt="image-20210824113648691"></p>
</li>
<li><p>clipPath() ：切封闭图形</p>
<p> clipPath() 切出来的圆为什么没有抗锯⻮效果?因为「强行切边」，而xfermode会对边缘进行一些模糊处理</p>
</li>
<li><p>clipOutRect() / clipOutPath() 反向版本，切的位置是不要的，其余位置留下</p>
</li>
</ul>
<p>Eg:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> BITMAP_SIZE = <span class="number">200.</span>dp</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> BITMAP_PADDING = <span class="number">100.</span>dp</span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraView</span></span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bitmap = getAvatar(BITMAP_SIZE.toInt())</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> cliped = Path().apply &#123;</span><br><span class="line">        addOval(BITMAP_PADDING, BITMAP_PADDING,</span><br><span class="line">            BITMAP_PADDING+ BITMAP_SIZE</span><br><span class="line">            ,BITMAP_PADDING+ BITMAP_SIZE,Path.Direction.CCW)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        <span class="comment">//范围裁切</span></span><br><span class="line">        <span class="comment">// clipRect：裁切 左上角</span></span><br><span class="line"><span class="comment">//        canvas.clipRect(BITMAP_PADDING, BITMAP_PADDING,</span></span><br><span class="line"><span class="comment">//            BITMAP_PADDING+ BITMAP_SIZE/2</span></span><br><span class="line"><span class="comment">//            ,BITMAP_PADDING+ BITMAP_SIZE/2)</span></span><br><span class="line"><span class="comment">//        canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING,paint)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clipPath：裁切 Path 圆形</span></span><br><span class="line">        canvas.clipPath(cliped)</span><br><span class="line">        canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING,paint)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAvatar</span><span class="params">(width: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">        <span class="keyword">val</span> options = BitmapFactory.Options()</span><br><span class="line">        options.inJustDecodeBounds = <span class="literal">true</span></span><br><span class="line">        BitmapFactory.decodeResource(resources, R.drawable.avatar_rengwuxian, options)</span><br><span class="line">        options.inJustDecodeBounds = <span class="literal">false</span></span><br><span class="line">        options.inDensity = options.outWidth</span><br><span class="line">        options.inTargetDensity = width</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeResource(resources, R.drawable.avatar_rengwuxian, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Canvas-的几何变换"><a href="#Canvas-的几何变换" class="headerlink" title="Canvas 的几何变换"></a>Canvas 的几何变换</h2><ul>
<li><p>translate(x, y)平移</p>
</li>
<li><p>rotate(degree) 旋转</p>
</li>
<li><p>scale(x, y) 缩放</p>
</li>
<li><p>skew(x, y) 错切（斜切）方形切棱形等操作</p>
</li>
</ul>
<p><strong>重点:</strong></p>
<p>Canvas 的几何变换方法参照的是 View 的坐标系，而绘制方法 (drawXxx())参照的是 Canvas 自己的坐标系。</p>
<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824152046675.png" alt="image-20210824152046675" style="zoom:50%;">

<h3 id="关于多重变换"><a href="#关于多重变换" class="headerlink" title="关于多重变换"></a>关于多重变换</h3><p>Canvas 的变换方法多次调用的时候，由于 Canvas 的坐标系会整体被变换，因此当 平移、旋转、放缩、错切等变换多重存在的时候，Canvas 的变换参数会非常难以计 算，因此可以改用倒序的理解方式:</p>
<blockquote>
<p>将 Canvas 的变换理解为 Canvas 的坐标系不变，每次变换是只对内部的绘制内 容进行变换，同时把 Canvas 的变换顺序看作是倒序的(即写在下面的变换先 执行)，可以更加方便进行多重变换的参数计算。</p>
</blockquote>
<h2 id="Matrix的几何变换"><a href="#Matrix的几何变换" class="headerlink" title="Matrix的几何变换"></a>Matrix的几何变换</h2><ul>
<li>reTranslate(x, y) / postTranslate(x, y)</li>
<li>preRotate(degree) / postRotate(degree) </li>
<li>preScale(x, y) / postScale(x, y)</li>
<li>preSkew(x, y) / postSkew(x, y)</li>
</ul>
<p>其中 preXxx() 效果和 Canvas 的准同名方法相同， postXxx() 效果和 Canvas 的准同名方法顺序相反。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果多次绘制时重复使用 Matrix，在使用之前需要用 Matrix.reset() 来把 Matrix 重置。</p>
<h2 id="使用Camera做三维旋转"><a href="#使用Camera做三维旋转" class="headerlink" title="使用Camera做三维旋转"></a>使用Camera做三维旋转</h2><ul>
<li>rotate() / rotateX() / rotateY() / rotateZ() </li>
<li>translate()</li>
<li>setLocation()</li>
</ul>
<p>其中，一般只用 rotateX() 和 rorateY() 来做沿 x 轴或 y 轴的旋转，以及使 用 setLocation() 来调整放缩的视觉幅度。</p>
<p>对 Camera 变换之后，要用 Camera.applyToCanvas(Canvas) 来应用到 Canvas。</p>
<p>三维坐标轴</p>
<p>x： 右为正向 ，y：上为正向，z：向屏幕里面为正向</p>
<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824152852451.png" alt="image-20210824152852451" style="zoom:33%;">

<p>camera存在于空间中，面对沿x轴旋转的图片会呈现出T形</p>
<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824153154902.png" alt="image-20210824153154902" style="zoom:33%;">

<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824153223669.png" alt="image-20210824153223669" style="zoom:33%;">

<p>camera的轴心无法移动，我们可以移动画布，旋转后再移动回原位置</p>
<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824153516440.png" alt="image-20210824153516440" style="zoom:33%;">



<p>Eg：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// camera</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> camera = Camera()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">init</span> &#123;</span><br><span class="line">       <span class="comment">// 没指定轴心，默认为0，0</span></span><br><span class="line">       camera.rotateX(<span class="number">30f</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">       <span class="comment">// Camera</span></span><br><span class="line">       <span class="comment">//对 Camera 变换之后，要用 Camera.applyToCanvas(Canvas) 来应用到 Canvas。</span></span><br><span class="line">       <span class="comment">//camera的轴心无法移动，我们可以移动画布，旋转后再移动回原位置（书写顺序要倒过来）</span></span><br><span class="line">       canvas . translate (BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>,</span><br><span class="line">           BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">       camera.applyToCanvas(canvas)</span><br><span class="line"></span><br><span class="line">       canvas.translate(</span><br><span class="line">           -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>),</span><br><span class="line">           -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">       canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING, paint)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824154045317.png" alt="image-20210824154045317" style="zoom:50%;">

<h3 id="setLocation"><a href="#setLocation" class="headerlink" title="setLocation"></a>setLocation</h3><p>这个方法一般前两个参数都填（x,y） 0，第三个参数为负值(z)。由于这个值的单位是硬编码写 死的，因此像素密度越高的手机，相当于 Camera 距离 View 越近，所以最好把这个 值写成与机器的 density  成正比的一个负值，例如 -6 * density。</p>
<p>Camera距离太近投影看起来就很大：</p>
<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824154554418.png" alt="image-20210824154554418" style="zoom:50%;">





<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上半部分</span></span><br><span class="line">canvas.save()</span><br><span class="line">canvas.translate (BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>,</span><br><span class="line">    BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">canvas.clipRect(- BITMAP_SIZE, - BITMAP_SIZE/<span class="number">2</span>, BITMAP_SIZE/<span class="number">2</span>, <span class="number">0f</span>)</span><br><span class="line">canvas.translate(</span><br><span class="line">    -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>),</span><br><span class="line">    -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>))</span><br><span class="line">canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING, paint)</span><br><span class="line">canvas.restore()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下半部分</span></span><br><span class="line">canvas.translate (BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>,</span><br><span class="line">    BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">camera.applyToCanvas(canvas)</span><br><span class="line">canvas.clipRect(- BITMAP_SIZE, <span class="number">0f</span>, BITMAP_SIZE/<span class="number">2</span>, BITMAP_SIZE/<span class="number">2</span>)</span><br><span class="line">canvas.translate(</span><br><span class="line">    -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>),</span><br><span class="line">    -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>))</span><br><span class="line">canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING, paint)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824161105237.png" alt="image-20210824161105237"></p>
<p>斜切：转动canvas在裁切即可</p>
<p>旋转后需要扩大裁切范围，否则会裁切到原本的图片，裁切范围扩大两倍</p>
<img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824161604856.png" alt="image-20210824161604856" style="zoom:50%;">

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hencoder.customviewdrawing.clipandcamera</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.graphics.*</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> androidx.<span class="keyword">annotation</span>.RequiresApi</span><br><span class="line"><span class="keyword">import</span> com.hencoder.customviewdrawing.R</span><br><span class="line"><span class="keyword">import</span> com.hencoder.customviewdrawing.view.dp</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by amazingZZ on 8/24/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> BITMAP_SIZE = <span class="number">200.</span>dp</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> BITMAP_PADDING = <span class="number">100.</span>dp</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraView</span></span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bitmap = getAvatar(BITMAP_SIZE.toInt())</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> cliped = Path().apply &#123;</span><br><span class="line">        addOval(</span><br><span class="line">            BITMAP_PADDING, BITMAP_PADDING,</span><br><span class="line">            BITMAP_PADDING + BITMAP_SIZE</span><br><span class="line">            , BITMAP_PADDING + BITMAP_SIZE, Path.Direction.CCW</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// camera</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> camera = Camera()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 没指定轴心，默认为0，0</span></span><br><span class="line">        camera.rotateX(<span class="number">30f</span>)</span><br><span class="line">        <span class="comment">// 移动摄像机，单位不是像素是英寸（因为这个方法不是谷歌提供的，1英寸大概72像素）</span></span><br><span class="line">        camera.setLocation(<span class="number">0f</span>, <span class="number">0f</span>, -<span class="number">6</span> * resources.displayMetrics.density)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        <span class="comment">//范围裁切</span></span><br><span class="line">        <span class="comment">// clipRect：裁切 左上角</span></span><br><span class="line"><span class="comment">//        canvas.clipRect(BITMAP_PADDING, BITMAP_PADDING,</span></span><br><span class="line"><span class="comment">//            BITMAP_PADDING+ BITMAP_SIZE/2</span></span><br><span class="line"><span class="comment">//            ,BITMAP_PADDING+ BITMAP_SIZE/2)</span></span><br><span class="line"><span class="comment">//        canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING,paint)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clipPath：裁切 Path 圆形</span></span><br><span class="line"><span class="comment">//        canvas.clipPath(cliped)</span></span><br><span class="line"><span class="comment">//        canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING,paint)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Camera</span></span><br><span class="line">        <span class="comment">//对 Camera 变换之后，要用 Camera.applyToCanvas(Canvas) 来应用到 Canvas。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//camera的轴心无法移动，我们可以移动画布，旋转后再移动回原位置（书写顺序要倒过来）</span></span><br><span class="line">        <span class="comment">// 上半部分</span></span><br><span class="line">        canvas.save()</span><br><span class="line">        canvas.translate (BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>,</span><br><span class="line">            BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>)</span><br><span class="line">        canvas.rotate(-<span class="number">30f</span>)</span><br><span class="line"></span><br><span class="line">        canvas.clipRect(- BITMAP_SIZE, - BITMAP_SIZE, BITMAP_SIZE, <span class="number">0f</span>)</span><br><span class="line">        canvas.rotate(<span class="number">30f</span>)</span><br><span class="line"></span><br><span class="line">        canvas.translate(</span><br><span class="line">            -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>),</span><br><span class="line">            -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>))</span><br><span class="line">        canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING, paint)</span><br><span class="line">        canvas.restore()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下半部分</span></span><br><span class="line">        canvas.translate (BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>,</span><br><span class="line">            BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>)</span><br><span class="line">        canvas.rotate(-<span class="number">30f</span>)</span><br><span class="line"></span><br><span class="line">        camera.applyToCanvas(canvas)</span><br><span class="line">        canvas.clipRect(- BITMAP_SIZE, <span class="number">0f</span>, BITMAP_SIZE, BITMAP_SIZE)</span><br><span class="line">        canvas.rotate(<span class="number">30f</span>)</span><br><span class="line"></span><br><span class="line">        canvas.translate(</span><br><span class="line">            -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>),</span><br><span class="line">            -(BITMAP_PADDING + BITMAP_SIZE / <span class="number">2</span>))</span><br><span class="line">        canvas.drawBitmap(bitmap, BITMAP_PADDING, BITMAP_PADDING, paint)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAvatar</span><span class="params">(width: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">        <span class="keyword">val</span> options = BitmapFactory.Options()</span><br><span class="line">        options.inJustDecodeBounds = <span class="literal">true</span></span><br><span class="line">        BitmapFactory.decodeResource(resources, R.drawable.avatar_rengwuxian, options)</span><br><span class="line">        options.inJustDecodeBounds = <span class="literal">false</span></span><br><span class="line">        options.inDensity = options.outWidth</span><br><span class="line">        options.inTargetDensity = width</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeResource(resources, R.drawable.avatar_rengwuxian, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20210824162040886.png" alt="image-20210824162040886"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/20/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B603-%E6%96%87%E5%AD%97%E7%9A%84%E6%B5%8B%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/20/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B603-%E6%96%87%E5%AD%97%E7%9A%84%E6%B5%8B%E9%87%8F/" class="post-title-link" itemprop="url">自定义view绘制03:文字的测量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-20 15:14:12" itemprop="dateCreated datePublished" datetime="2021-08-20T15:14:12+08:00">2021-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-24 11:05:51" itemprop="dateModified" datetime="2021-08-24T11:05:51+08:00">2021-08-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E8%87%AA%E5%AE%9A%E4%B9%89view/" itemprop="url" rel="index"><span itemprop="name">自定义view</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文字测量"><a href="#文字测量" class="headerlink" title="文字测量"></a>文字测量</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/20/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B603-%E6%96%87%E5%AD%97%E7%9A%84%E6%B5%8B%E9%87%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/17/Jvm%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/17/Jvm%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Jvm原理解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-17 17:31:59" itemprop="dateCreated datePublished" datetime="2021-08-17T17:31:59+08:00">2021-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-20 10:23:05" itemprop="dateModified" datetime="2021-08-20T10:23:05+08:00">2021-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Jvm原理解析"><a href="#Jvm原理解析" class="headerlink" title="Jvm原理解析"></a>Jvm原理解析</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p> Java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的Java虚拟机进行解释，最后再转换为不同平台的机器码。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/17/Jvm%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/17/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B602-Xfermode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/17/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B602-Xfermode/" class="post-title-link" itemprop="url">自定义view绘制02-Xfermode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-17 12:10:56 / 修改时间：14:54:14" itemprop="dateCreated datePublished" datetime="2021-08-17T12:10:56+08:00">2021-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E8%87%AA%E5%AE%9A%E4%B9%89view/" itemprop="url" rel="index"><span itemprop="name">自定义view</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Xfermode完全使用解析"><a href="#Xfermode完全使用解析" class="headerlink" title="Xfermode完全使用解析"></a>Xfermode完全使用解析</h1><p>为什么要 Xfermode?为了把多次绘制进行「合成」，例如蒙版效果:用 A 的形状和 B 的图案</p>
<p>怎么做?</p>
<ol>
<li>Canvas.saveLayer() 把绘制区域拉到单独的离屏缓冲里</li>
<li>绘制 A 图形</li>
<li>用 Paint.setXfermode() 设置 Xfermode</li>
<li>绘制 B 图形</li>
<li>用 Paint.setXfermode(null) 恢复 Xfermode</li>
<li>用 Canvas.restoreToCount() 把离屏缓冲中的合成后的图形放回绘制区域</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> IMAGE_WIDTH = <span class="number">200f</span>.px</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> IMAGE_PADDING = <span class="number">20f</span>.px</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> XFERMODE = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvatarView</span></span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;</span><br><span class="line">    <span class="keyword">var</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">    <span class="keyword">var</span> bounds = RectF()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">        bounds.left = IMAGE_PADDING</span><br><span class="line">        bounds.top = IMAGE_PADDING</span><br><span class="line">        bounds.right = IMAGE_PADDING + IMAGE_WIDTH</span><br><span class="line">        bounds.bottom = IMAGE_PADDING + IMAGE_WIDTH</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        <span class="comment">//  把绘制区域拉到单独的离屏缓冲里</span></span><br><span class="line">        <span class="keyword">var</span> count = canvas.saveLayer(bounds,<span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 绘制图形a</span></span><br><span class="line">        canvas.drawOval(</span><br><span class="line">            bounds,</span><br><span class="line">            paint</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 设置 Xfermode，PorterDuff是创作者的名字，其他模式已经过时</span></span><br><span class="line">        paint.xfermode = XFERMODE</span><br><span class="line">        <span class="comment">//绘制图形b</span></span><br><span class="line">        canvas.drawBitmap(</span><br><span class="line">            getAvatar(IMAGE_WIDTH.toInt()),</span><br><span class="line">            IMAGE_PADDING, IMAGE_PADDING,</span><br><span class="line">            paint</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复 Xfermode</span></span><br><span class="line">        paint.xfermode = <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 把离屏缓冲中的合成后的图形放回绘制区域 count 记录了绘制状态</span></span><br><span class="line">        canvas.restoreToCount(count)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAvatar</span><span class="params">(width: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">        <span class="comment">// 利用option 可以提高读取bitmap的速度（只读取指定的大小）</span></span><br><span class="line">        <span class="keyword">val</span> options = BitmapFactory.Options()</span><br><span class="line">        options.inJustDecodeBounds = <span class="literal">true</span></span><br><span class="line">        BitmapFactory.decodeResource(resources, R.drawable.avatar_rengwuxian, options)</span><br><span class="line">        options.inJustDecodeBounds = <span class="literal">false</span></span><br><span class="line">        options.inDensity = options.outWidth</span><br><span class="line">        options.inTargetDensity = width</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeResource(resources, R.drawable.avatar_rengwuxian, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要用 saveLayer() 才能正确绘制 ?</p>
<p>为了把需要互相作用的图形放在单独的位置来绘制，不会受 View 本身的影响。 如果不使用 saveLayer()，绘制的目标区域将总是整个 View 的范围，两个图形 的交叉区域就错误了。</p>
<p>Ps</p>
<p>如果想做到像官网示例一样的效果，除了构建图形，还需要画出透明的bitmap底图</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> XFERMODE = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XfermodeView</span></span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bounds = RectF(<span class="number">150f</span>.px, <span class="number">50f</span>.px, <span class="number">300f</span>.px, <span class="number">200f</span>.px)</span><br><span class="line">    <span class="comment">// 本来是100dp 为了符合官方文档，增加50dp作为底部画布，</span></span><br><span class="line">    <span class="comment">// 合成并不仅仅是所画的图形，透明的部分也会参与合成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> circleBitmap = Bitmap.createBitmap(<span class="number">150f</span>.px.toInt(), <span class="number">150f</span>.px.toInt(), Bitmap.Config.ARGB_8888)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> squareBitmap = Bitmap.createBitmap(<span class="number">150f</span>.px.toInt(), <span class="number">150f</span>.px.toInt(), Bitmap.Config.ARGB_8888)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> canvas = Canvas(circleBitmap)</span><br><span class="line">        paint.color = Color.parseColor(<span class="string">&quot;#D81B60&quot;</span>)</span><br><span class="line">        canvas.drawOval(<span class="number">50f</span>.px, <span class="number">0f</span>.px, <span class="number">150f</span>.px, <span class="number">100f</span>.px, paint)</span><br><span class="line">        paint.color = Color.parseColor(<span class="string">&quot;#2196F3&quot;</span>)</span><br><span class="line">        canvas.setBitmap(squareBitmap)</span><br><span class="line">        canvas.drawRect(<span class="number">0f</span>.px, <span class="number">50f</span>.px, <span class="number">100f</span>.px, <span class="number">150f</span>.px, paint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> count = canvas.saveLayer(bounds, <span class="literal">null</span>)</span><br><span class="line">        canvas.drawBitmap(circleBitmap, <span class="number">150f</span>.px, <span class="number">50f</span>.px, paint)</span><br><span class="line">        paint.xfermode = XFERMODE</span><br><span class="line">        canvas.drawBitmap(squareBitmap, <span class="number">150f</span>.px, <span class="number">50f</span>.px, paint)</span><br><span class="line">        paint.xfermode = <span class="literal">null</span></span><br><span class="line">        canvas.restoreToCount(count)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/" class="post-title-link" itemprop="url">自定义view绘制01:图形的位置和尺寸测量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-16 13:16:43" itemprop="dateCreated datePublished" datetime="2021-08-16T13:16:43+08:00">2021-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-17 11:53:22" itemprop="dateModified" datetime="2021-08-17T11:53:22+08:00">2021-08-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E8%87%AA%E5%AE%9A%E4%B9%89view/" itemprop="url" rel="index"><span itemprop="name">自定义view</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图形的位置和尺寸测量"><a href="#图形的位置和尺寸测量" class="headerlink" title="图形的位置和尺寸测量"></a>图形的位置和尺寸测量</h1><p>绘制的基本要素:</p>
<ul>
<li>重写 onDraw() </li>
<li>使用 Canvas 来绘制</li>
<li> 使用 Paint 来配置 </li>
<li>坐标系</li>
</ul>
<p>坐标系：</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816132956286.png" alt="image-20210816132956286" style="zoom:50%;">

<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816132934924.png" alt="image-20210816132934924" style="zoom: 33%;">

<h2 id="尺寸单位，像素px，而不是-dp。转换方式"><a href="#尺寸单位，像素px，而不是-dp。转换方式" class="headerlink" title="尺寸单位，像素px，而不是 dp。转换方式:"></a>尺寸单位，像素px，而不是 dp。转换方式:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">dp2px</span><span class="params">(<span class="keyword">float</span> dp)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp,Resources</span><br><span class="line">                                 .getSystem()</span><br><span class="line"> 																.getDisplayMetrics());&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Path-的方向以及封闭图形的内外判断"><a href="#Path-的方向以及封闭图形的内外判断" class="headerlink" title="Path 的方向以及封闭图形的内外判断:"></a>Path 的方向以及封闭图形的内外判断:</h2><p>path不见得是路径，可能是路径圈出来的形状</p>
<p>FillType：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        p path.reset()</span><br><span class="line">        path.addCircle(width/<span class="number">2f</span>,height/<span class="number">2f</span>, RADIUS,Path.Direction.CW)</span><br><span class="line">        path.addRect(width/<span class="number">2f</span>- RADIUS,height/<span class="number">2f</span>,</span><br><span class="line">            width/<span class="number">2f</span>+ RADIUS, height/<span class="number">2f</span>+<span class="number">2</span>*RADIUS,Path.Direction.CCW)</span><br><span class="line">        path.addCircle(width/<span class="number">2f</span>,height/<span class="number">2f</span>, RADIUS*<span class="number">1.5f</span>,Path.Direction.CW)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CWclockwise 正向</span></span><br><span class="line">        <span class="comment">// CCWcounter-clockwise 反向</span></span><br><span class="line"><span class="comment">//        Path.FillType.WINDING 方向相同的都算内部，不等则为外部</span></span><br><span class="line"><span class="comment">//        Path.FillType.EVEN_ODD 不考虑方向。穿插奇数次则为内部，偶数次则为外部:</span></span><br><span class="line">        path.fillType =Path.FillType.EVEN_ODD</span><br></pre></td></tr></table></figure>


<ul>
<li><p>Winding: 如果方向相反的穿插次数相等则为内部，不等则为外部:</p>
<p>单圆:</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816160231091.png" alt="image-20210816160231091" style="zoom:33%;">

<p>双圆同向:</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816160304666.png" alt="image-20210816160304666" style="zoom:33%;">

<p>双圆不同向:</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816160334531.png" alt="image-20210816160334531" style="zoom:33%;">
</li>
<li><p>Even Odd:不考虑方向。穿插奇数次则为内部，偶数次则为外部:</p>
<p>单圆:</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816160411299.png" alt="image-20210816160411299" style="zoom:33%;">

<p>双圆：</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816160445789.png" alt="image-20210816160445789" style="zoom:33%;">

</li>
</ul>
<h2 id="PathMeasure"><a href="#PathMeasure" class="headerlink" title="PathMeasure"></a>PathMeasure</h2><p>把 Path 对象填入，用于对 Path 做针对性的计算(例如图形周⻓)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> pathMeasure: PathMeasure</span><br><span class="line"> <span class="comment">// bool 意思时是否需要封口后再测量</span></span><br><span class="line"> pathMeasure = PathMeasure(path,<span class="literal">false</span>)</span><br><span class="line"> <span class="comment">// 周长</span></span><br><span class="line"> pathMeasure.length</span><br><span class="line"> <span class="comment">// 切角</span></span><br><span class="line"> pathMeasure.getPosTan()</span><br></pre></td></tr></table></figure>
<h2 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h2><ul>
<li>用 drawArc() 绘制弧形</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// args 坐标：左上右下也可以传Rect矩形，起始角度startAngle，</span></span><br><span class="line"><span class="comment">// 扫过角度sweepAngle，是否扫过中心bool，画笔paint</span></span><br><span class="line">canvas.drawArc(</span><br><span class="line">    width / <span class="number">2f</span> - <span class="number">150f</span>.px,</span><br><span class="line">    height / <span class="number">2f</span> - <span class="number">150f</span>.px,</span><br><span class="line">    width / <span class="number">2f</span> + <span class="number">150f</span>.px,</span><br><span class="line">    height / <span class="number">2f</span> + <span class="number">150f</span>.px,</span><br><span class="line">    <span class="number">90</span> + OPEN_ANGLE / <span class="number">2f</span>,</span><br><span class="line">    <span class="number">360f</span> - OPEN_ANGLE, <span class="literal">false</span>, paint)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>三⻆函数的计算 横向的位移是 cos，纵向的位移是 sin</p>
</li>
<li><p>PathDashPathEffect</p>
</li>
<li><p>Path 效果，其中就有虚线效果</p>
<ul>
<li><p>加上 PathEffect 之后，就只绘制 effect，而不绘制原图形。所以需要弧线和 刻度分别绘制，一共两</p>
</li>
<li><p>dash 的方向</p>
<ul>
<li><p>绘制 dash 的轨迹是这样的:</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816181754809.png" alt="image-20210816181754809" style="zoom:33%;">
</li>
<li><p>而由于 x 轴的正向是轨迹的正向(这是规定)，所以实际上的物理模型 是这样的:</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816181821486.png" alt="image-20210816181821486" style="zoom:33%;">
</li>
<li><p>那么，如果你要加上刻度，就应该这样设置:</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816181858172.png" alt="image-20210816181858172" style="zoom:33%;">
</li>
<li><p>然后，你的刻度就会沿着轨迹绘制:</p>
<img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210816182109475.png" alt="image-20210816182109475" style="zoom:33%;">

</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hencoder.customviewdrawing.view</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.graphics.*</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> java.lang.Math.cos</span><br><span class="line"><span class="keyword">import</span> java.lang.Math.sin</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by amazingZZ on 8/16/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//仪表盘开口角度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> OPEN_ANGLE = <span class="number">120f</span></span><br><span class="line"> <span class="keyword">val</span> DASH_WIDTH = <span class="number">2f</span>.px</span><br><span class="line"> <span class="keyword">val</span> DASH_LENGTH = <span class="number">10f</span>.px</span><br><span class="line"> <span class="keyword">val</span> MARK = <span class="number">4</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> RADIUS = <span class="number">150f</span>.px</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> LENGTH = <span class="number">120f</span>.px</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DashboardView</span></span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;</span><br><span class="line">    <span class="comment">// Paint.ANTI_ALIAS_FLAG 抗锯齿，会破坏原本的构图，经常使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dash =Path()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> path =Path()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> pathEffect: PathDashPathEffect</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        paint.strokeWidth= <span class="number">3f</span>.px</span><br><span class="line">        paint.style = Paint.Style.STROKE</span><br><span class="line">        dash.addRect(<span class="number">0f</span>,<span class="number">0f</span>, DASH_WIDTH, DASH_LENGTH,Path.Direction.CCW)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">        path.addArc(width / <span class="number">2f</span> - <span class="number">150f</span>.px,</span><br><span class="line">            height / <span class="number">2f</span> - <span class="number">150f</span>.px,</span><br><span class="line">            width / <span class="number">2f</span> + <span class="number">150f</span>.px,</span><br><span class="line">            height / <span class="number">2f</span> + <span class="number">150f</span>.px,</span><br><span class="line">            <span class="number">90</span> + OPEN_ANGLE / <span class="number">2f</span>,</span><br><span class="line">            <span class="number">360f</span> - OPEN_ANGLE)</span><br><span class="line">        <span class="keyword">val</span> pathMeasure = PathMeasure(path,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//args :path ,advance是图形之间的间距，phase是path的偏移量，显示风格</span></span><br><span class="line">        pathEffect = PathDashPathEffect(</span><br><span class="line">            dash,</span><br><span class="line">            (pathMeasure.length - DASH_WIDTH)/<span class="number">20f</span>,<span class="number">0f</span>,</span><br><span class="line">            PathDashPathEffect.Style.ROTATE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.draw(canvas)</span><br><span class="line">        <span class="comment">// 画弧</span></span><br><span class="line">        <span class="comment">// args 坐标：左上右下也可以传Rect矩形，起始角度startAngle，</span></span><br><span class="line">        <span class="comment">// 扫过角度sweepAngle，是否扫过中心bool，画笔paint</span></span><br><span class="line"><span class="comment">//        canvas.drawArc(</span></span><br><span class="line"><span class="comment">//            rectf,</span></span><br><span class="line"><span class="comment">//            90 + OPEN_ANGLE / 2f,</span></span><br><span class="line"><span class="comment">//            360f - OPEN_ANGLE, false, paint)</span></span><br><span class="line">        canvas.drawPath(path,paint)</span><br><span class="line">        <span class="comment">// 画刻度</span></span><br><span class="line">        paint.pathEffect = pathEffect</span><br><span class="line">        canvas.drawArc(</span><br><span class="line">            width / <span class="number">2f</span> - <span class="number">150f</span>.px,</span><br><span class="line">            height / <span class="number">2f</span> - <span class="number">150f</span>.px,</span><br><span class="line">            width / <span class="number">2f</span> + <span class="number">150f</span>.px,</span><br><span class="line">            height / <span class="number">2f</span> + <span class="number">150f</span>.px,</span><br><span class="line">            <span class="number">90</span> + OPEN_ANGLE / <span class="number">2f</span>,</span><br><span class="line">            <span class="number">360f</span> - OPEN_ANGLE, <span class="literal">false</span>, paint)</span><br><span class="line">        paint.pathEffect = <span class="literal">null</span></span><br><span class="line">        canvas.drawLine(width/<span class="number">2f</span>,</span><br><span class="line">            height/<span class="number">2f</span>,</span><br><span class="line">            (width/<span class="number">2f</span>+ LENGTH* cos(markToRadians(MARK))).toFloat(),</span><br><span class="line">            (height/<span class="number">2f</span>+ LENGTH* sin(markToRadians(MARK))).toFloat(),</span><br><span class="line">            paint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">markToRadians</span><span class="params">(mark:<span class="type">Int</span>)</span></span> =</span><br><span class="line">        Math.toRadians(((<span class="number">90</span> + OPEN_ANGLE / <span class="number">2f</span> + (<span class="number">360f</span> - OPEN_ANGLE) / <span class="number">20f</span> * mark).toDouble()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><ul>
<li><p>用 drawArc() 绘制扇形</p>
</li>
<li><p>用 Canvas.translate() 来移动扇形，并用 Canvas.save() 和 Canvas.restore() 来 保存和恢复位置</p>
</li>
<li><p>用三⻆函数 cos 和 sin 来计算偏移</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hencoder.customviewdrawing.view</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.graphics.*</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> java.lang.Math.cos</span><br><span class="line"><span class="keyword">import</span> java.lang.Math.sin</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饼图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> RADIUS = <span class="number">150f</span>.px</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> ANGLES = floatArrayOf(<span class="number">60f</span>, <span class="number">90f</span>, <span class="number">150f</span>, <span class="number">60f</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> COLORS = listOf(</span><br><span class="line">    Color.parseColor(<span class="string">&quot;#C2185B&quot;</span>),</span><br><span class="line">    Color.parseColor(<span class="string">&quot;#00AAC1&quot;</span>),</span><br><span class="line">    Color.parseColor(<span class="string">&quot;#558B2F&quot;</span>),</span><br><span class="line">    Color.parseColor(<span class="string">&quot;#5D4037&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> OFFSET_LENGTH = <span class="number">20f</span>.px</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PieView</span></span>(context: Context?, attrs: AttributeSet?) : View(context, attrs) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> pathEffect: PathDashPathEffect</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> rectF: RectF</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        paint.strokeWidth = <span class="number">3f</span>.px</span><br><span class="line">        paint.style = Paint.Style.FILL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">        rectF = RectF(</span><br><span class="line">            width / <span class="number">2f</span> - RADIUS,</span><br><span class="line">            height / <span class="number">2</span> - RADIUS,</span><br><span class="line">            width / <span class="number">2f</span> + RADIUS,</span><br><span class="line">            height / <span class="number">2f</span> + RADIUS</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.draw(canvas)</span><br><span class="line">        <span class="keyword">var</span> startAngle = <span class="number">0f</span></span><br><span class="line">        <span class="keyword">for</span> ((index, angle) <span class="keyword">in</span> ANGLES.withIndex()) &#123;</span><br><span class="line"></span><br><span class="line">            paint.color = COLORS[index]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 偏移计算</span></span><br><span class="line">                canvas.save()</span><br><span class="line">                canvas.translate(OFFSET_LENGTH * cos(Math.toRadians(startAngle + angle / <span class="number">2f</span>.toDouble())).toFloat(), OFFSET_LENGTH * sin(Math.toRadians(startAngle + angle / <span class="number">2f</span>.toDouble())).toFloat())</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.drawArc(</span><br><span class="line">                rectF,</span><br><span class="line">                startAngle,</span><br><span class="line">                angle,</span><br><span class="line">                <span class="literal">true</span>,</span><br><span class="line">                paint</span><br><span class="line">            )</span><br><span class="line">            startAngle += angle</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 恢复</span></span><br><span class="line">                canvas.restore()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/16/%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%98%E5%88%B601-%E5%9B%BE%E5%BD%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%B0%BA%E5%AF%B8%E6%B5%8B%E9%87%8F/image-20210817115311948.png" alt="image-20210817115311948"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">剖析Framework面试（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-28 08:32:58" itemprop="dateCreated datePublished" datetime="2021-07-28T08:32:58+08:00">2021-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-16 10:02:26" itemprop="dateModified" datetime="2021-08-16T10:02:26+08:00">2021-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Framework/" itemprop="url" rel="index"><span itemprop="name">Framework</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Framework/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">系统服务</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="应用服务相关"><a href="#应用服务相关" class="headerlink" title="应用服务相关"></a>应用服务相关</h1><p>网络图，方便理解</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210803102239629.png" alt="image-20210803102239629"></p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210810065021622.png" alt="image-20210810065021622" style="zoom: 50%;">

<p><img src="https://pic4.zhimg.com/80/v2-03255ea729dc76cdd3f4a6e195c4304f_1440w.jpg" alt="img"></p>
<h2 id="谈谈对Zygote的理解"><a href="#谈谈对Zygote的理解" class="headerlink" title="谈谈对Zygote的理解"></a>谈谈对Zygote的理解</h2><p>考察点：Zygote的作用、Zygote的启动流程、Zygote的工作原理</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p>启动SystemServer</p>
<p>系统服务进程SystemServer是由Zygote进程fork出的（系统中比较重要的ActivityManagerService、PackageManagerService，WindowManagerService以及PowerManagerService等也是由SystemServer进程创建而来的），fork出的SystemServer进程会继承Zygote的资源，比如：常用类、JNI函数、主题资源、共享库等。</p>
</li>
<li><p>孵化应用进程</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/HUandroid/article/details/103454434">参考android的启动流程</a><br>里面有一个方法zygoteSendArgsAndGetResult方法，就是AMS请求Zygote来创建新的应用程序进程的。</p>
<h3 id="启动三段式"><a href="#启动三段式" class="headerlink" title="启动三段式"></a>启动三段式</h3><p>Android进程启动常用套路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[进程启动] --&gt; B[准备工作]</span><br><span class="line">B --&gt; C[Loop-不停接收&#x2F;处理消息]</span><br></pre></td></tr></table></figure>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><h4 id="启动Zygote进程"><a href="#启动Zygote进程" class="headerlink" title="启动Zygote进程"></a>启动Zygote进程</h4><p>Init进程：Linux启动后用户空间的第一个进程</p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728092209535.png" alt="image-20210728092209535" style="zoom:50%;">

<ol>
<li>Init进程启动后，首先会去加载一个启动配置文件<code>init.rc</code>。</li>
<li>查看启动配置文件定义了哪些需要启动的系统服务 <code>Zygote</code>服务也是需要启动的进程之一，<code>Service Manager</code>也是需要启动的进程。</li>
<li>通过 <code>fork</code>和 <code>execve</code>系统调用，启动<code>Zygote</code>。</li>
</ol>
<h5 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h5><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728092629781.png" alt="image-20210728092629781" style="zoom:50%;">

<p>红色：service的名称。蓝色：可执行路径。黄色：参数。</p>
<p>进程启动靠的是fork和exeve系统调用，需要传可执行的路径和参数，</p>
<h5 id="启动进程"><a href="#启动进程" class="headerlink" title="启动进程"></a>启动进程</h5><p>启动进程有两种方式</p>
<ul>
<li><p>fork + handle</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>( pid == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// child process</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// parent process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>fork + exeve</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>( pid == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// child process</span></span><br><span class="line">  execve(path,argv,env);<span class="comment">// 执行程序路径，执行程序参数，环境变量</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// parent process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步都调用<code>fork</code>函数创建子进程。<code>fork()</code>函数会返回两次，子进程父进程各一次。区别在于子进程的<code>pid</code>返回0 ，父进程的pid返回的是子进程的<code>pid</code> ，所以可以根据判断pid是不是0判断是否是子进程还是父进程。</p>
</li>
</ul>
<p>默认来说创建的子进程会继承父进程的所有资源，调用<code>execve</code>系统调用去启动新的二进制程序，子进程继承的父进程资源就会被清掉，完全被新的二进制程序替换。</p>
<h5 id="信号处理-SiGCHILD"><a href="#信号处理-SiGCHILD" class="headerlink" title="信号处理- SiGCHILD"></a>信号处理- SiGCHILD</h5><p>fork进程的时候父进程一般都要关注这个信号。</p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728095502377.png" alt="image-20210728095502377" style="zoom:50%;">

<p>如果父进程<code>fork</code>一个子进程，子进程挂了会发送一个<code>SIGCHILD</code>信号给父进程，这时父进程就可以做一些处理。比如<code>Zygote</code>挂了就会发送一个<code>SIGCHILD</code>信号给<code>Init</code>进程进行重启。</p>
<h4 id="Zygote进程启动之后做了什么？"><a href="#Zygote进程启动之后做了什么？" class="headerlink" title="Zygote进程启动之后做了什么？"></a>Zygote进程启动之后做了什么？</h4><ul>
<li><p>Native 部分（准备部分）</p>
<p>Zygote启动之后执行了一个<code>execve</code>系统调用,执行一个二进制可执行程序（c++，里面有一个<code>main</code>函数作为入口）所以说Zygote天生就是Native的，做一些准备工作之后就切到Java中运行了。</p>
</li>
<li><p>Java 部分实际运行</p>
</li>
</ul>
<h5 id="Native部分"><a href="#Native部分" class="headerlink" title="Native部分"></a>Native部分</h5><p>目的是为了Java执行做准备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[启动Android虚拟机] --&gt; B[注册Android系统关键类的JNI函数]</span><br><span class="line">B --&gt; C[JNI调用进入Java部分]</span><br></pre></td></tr></table></figure>
<h6 id="Native切换到Java"><a href="#Native切换到Java" class="headerlink" title="Native切换到Java"></a>Native切换到Java</h6><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728101441277.png" alt="image-20210728101441277" style="zoom:50%;">

<p>关键： JNICreateJavaVM 函数创建虚拟机。</p>
<ol>
<li>JNICreateJavaVM 创建虚拟机</li>
<li>找到ZygoteInit这个Java类</li>
<li>在ZygoteInit类中找到 Main这个静态函数</li>
<li>用CallStaticVoidMethod去调用这个函数</li>
<li>最后DestoryJavaVM 销毁Java虚拟机</li>
</ol>
<p>应用进程不需要创建虚拟机，是因为在Zygote进程中已经加载好了，我们应用进程是由Zygote孵化出来的，继承了Java虚拟机，只需要在进程启动的时候重置一下虚拟机的状态属性，再重启一下虚拟机就可以了</p>
<p>c++代码看着太难受，说下入口是哪里，想研究可看下：<br><code>app_main.cpp </code>是<code>app_process</code>的入口文件<br>创建虚拟机的位置在：<br><code>AndroidRuntime.cpp</code>中的<code>startVm</code>方法来启动虚拟机，<code>startReg</code>来注册JNI函数，<code>CallStaticVoidMethod(startClass, startMeth, strArray)</code>来调用<code>ZygoteInit</code>类的<code>main</code>方法，启动Java部分。<br>注意点：应用程序的虚拟机是继承Zygote进程的，然后再重置虚拟机的状态，再重启下虚拟机。</p>
<h5 id="Java部分"><a href="#Java部分" class="headerlink" title="Java部分"></a>Java部分</h5><p>主要做了三件事</p>
<ol>
<li>预加载资源：孵化子进程的时候可以继承给他们，包括常用类、主题相关的资源、共享库。</li>
<li>fork 启动SystemServer进程。</li>
<li>进入Loop循环，等待Socket消息。用于AMS通信，参考android启动流程中的ZygoteState.connect(mSocket)，这里会创建Socket链接，在接受到AMS跨进程发过来的消息后，会调用handleChildProc启动ActivityThread.main()方法，进入新的进程了。</li>
</ol>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728104550796.png" alt="image-20210728104550796" style="zoom:50%;">

<h6 id="Loop循环"><a href="#Loop循环" class="headerlink" title="Loop循环"></a>Loop循环</h6><p>Zygote启动之后，会启动Socket Loop循环，会不断轮询Socket，当有请求过来的时候会执行runOnce函数。</p>
<p>runOnece方法：</p>
<ol>
<li><p>读取参数列表 readArgumentLIst()。</p>
</li>
<li><p>根据参数启动子进程 forkAndSpecialize()。</p>
</li>
<li><p>子进程启动后调用ActivityThread.Main函数</p>
<p>子进程中调用 handleChidPro()，它会在子进程中调用一个Java类的Main函数，Java类名来自于读取的参数列表，是由AMS跨进程发过来的，类名其实是ActivityThread</p>
</li>
</ol>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210728105334941.png" alt="image-20210728105334941" style="zoom:33%;">



<h3 id="细节与问题"><a href="#细节与问题" class="headerlink" title="细节与问题"></a>细节与问题</h3><h4 id="Zygote-fork-要单线程"><a href="#Zygote-fork-要单线程" class="headerlink" title="Zygote fork 要单线程"></a>Zygote fork 要单线程</h4><p>Zygote里面有很多其他线程，为了保证状态一致并避免死锁，在fork子进程的时候，会停掉其他线程，在fork完成后，再恢复。可以理解为fork只能拷贝当前线程，不支持多线程的fork。</p>
<p>我们知道，应用在启动的时候需要做很多准备工作，包括启动虚拟机，加载各类系统资源等等，这些都是非常耗时的，如果能在zygote里就给这些必要的初始化工作做好，子进程在fork的时候就能直接共享，那么这样的话效率就会非常高。</p>
<p>这个就是zygote存在的价值，这一点呢SystemServer是替代不了的，主要是因为SystemServer里跑了一堆系统服务，这些是不能继承到应用进程的。所以给SystemServer和应用进程里都要用到的资源抽出来单独放在一个进程里，也就是这的zygote进程，然后zygote进程再分别孵化出SystemServer进程和应用进程。</p>
<h4 id="Zygote的IPC为啥没有采用binder通信？"><a href="#Zygote的IPC为啥没有采用binder通信？" class="headerlink" title="Zygote的IPC为啥没有采用binder通信？"></a>Zygote的IPC为啥没有采用binder通信？</h4><p>Zygote的mian方法中会创建一个server端Socket（LocalSocket\LocalServerSocket），用于等待AMS请求Zygote来创建新的应用程序进程的，并且封装了TCP/IP协议，去掉网络相关。<br>首先这里<strong>有一坑</strong>，别跳：binder线程的初始化是在ServiceManger初始化的，而ServiceManger是Init进程孵化的，比Zygote进程更早，所以就<strong>不存在先后顺序问题</strong>。<br>原因：</p>
<ol>
<li>为了避免父亲进程死锁、状态不一致等其他多线程问题，如果采用binder，在父进程binder线程有锁，然后子进程的主线程一直在等其子线程的资源，但是其实父进程的子进程并没有被拷贝过来，造成死锁，所以fork进程不允许存在多线程。而Binder通信是多线程的。</li>
<li>对于Zygote和SystemServer而言，Socket更加简单便捷，也符合单线程规范。</li>
</ol>
<h4 id="孵化应用进程为什么不交给SystemServer来做，而专门设计一个zygote？"><a href="#孵化应用进程为什么不交给SystemServer来做，而专门设计一个zygote？" class="headerlink" title="孵化应用进程为什么不交给SystemServer来做，而专门设计一个zygote？"></a>孵化应用进程为什么不交给SystemServer来做，而专门设计一个zygote？</h4><p>因为效率问题，SystemServer里面会跑一些其他的服务，如果SystemServer来fork进程，可能造成资源污染，不适合继承。而Zygote进程专门设计来干这事的。</p>
<h2 id="说一说Android系统的启动流程"><a href="#说一说Android系统的启动流程" class="headerlink" title="说一说Android系统的启动流程"></a>说一说Android系统的启动流程</h2><h3 id="android有那些主要的系统进程？"><a href="#android有那些主要的系统进程？" class="headerlink" title="android有那些主要的系统进程？"></a>android有那些主要的系统进程？</h3><p>主要的系统进程，可以查看<code>init.rc</code></p>
<ul>
<li><p>service <code>zygote</code> system/bin/app_process..</p>
</li>
<li><p>service <code>servicemanager</code> system/bin/servicemanager..</p>
</li>
<li><p>service <code>surfacefilinger</code> system/bin/<code>surfacefilinger</code> ..</p>
</li>
<li><p>service <code>media</code> system/bin/media..</p>
</li>
<li><p>……</p>
</li>
</ul>
<p><code>zygote</code> <code>ServiceManager</code> <code>surfaceflinger</code> <code>media</code> <code>SystemServer</code> <code>AMS</code> <code>PMS</code>等</p>
<h3 id="这些系统进程怎么启动的？"><a href="#这些系统进程怎么启动的？" class="headerlink" title="这些系统进程怎么启动的？"></a>这些系统进程怎么启动的？</h3><p>主要说下<code>zygote</code>、<code>ServiceManager</code> <code>SystemServer</code></p>
<h3 id="ServiceManager启动流程"><a href="#ServiceManager启动流程" class="headerlink" title="ServiceManager启动流程"></a>ServiceManager启动流程</h3><p>先看网上博主的流程图，方便理解：后面会讲。</p>
<p><img src="https://img-blog.csdnimg.cn/20210402152226284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVYW5kcm9pZA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Zygote启动流程"><a href="#Zygote启动流程" class="headerlink" title="Zygote启动流程"></a>Zygote启动流程</h3><p>参考上面。</p>
<h3 id="SystemServer启动流程"><a href="#SystemServer启动流程" class="headerlink" title="SystemServer启动流程"></a>SystemServer启动流程</h3><h4 id="zygote启动部分"><a href="#zygote启动部分" class="headerlink" title="zygote启动部分"></a>zygote启动部分</h4><p>看下zygote启动SystemServer的伪代码：<br>pid为0就是处于fork后的子进程，大于0就是处于父进程。<br>具体源码位置：frameworks/base/core/java/com/android/internal/os/ZygoteInit.jav</p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210802154029544.png" alt="image-20210802154029544" style="zoom:50%;">

<p>通过zygote来fork出SystemServer ，然后再处理<code>handleSystemServerProcess(parsedArgs)</code>方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再到<code>ZygoteInit.zygoteInit</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        RuntimeInit.redirectLogStreams();</span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码地址：/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java<br><code>RuntimeInit.redirectLogStreams()是</code>初始化日志、<code>RuntimeInit.commonInit()</code>是公用初始化、<code>ZygoteInit.nativeZygoteInit()</code>是用来启用binder机制，注意不是创建，启动了一个binder线程、<code>RuntimeInit.applicationInit</code>来启动<code>SystemServer</code>的java类入口。</p>
<h4 id="SystemServer的部分"><a href="#SystemServer的部分" class="headerlink" title="SystemServer的部分"></a>SystemServer的部分</h4><p>看下<code>RuntimeInit.applicationInit</code>代码，会调用到<code>findStaticMain()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">           ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//className 就是上面传进来的 com.android.server.SystemServer</span></span><br><span class="line">       Class&lt;?&gt; cl;</span><br><span class="line">       cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">       Method m;</span><br><span class="line">       m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);    </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>就是反射启动Java类调用main方法，类名为<code>com.android.server.SystemServer</code>，跟进看SystemServer.java的main方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>直接执行<code>run()</code>函数，代码太多，看伪代码了：</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210803170335310.png" alt="image-20210803170335310"></p>
<p>根据上面伪代码，可看出主要干了：</p>
<ol>
<li>给主线程绑定一个Looper</li>
<li>加载一个共享库android_servers，是SystemServer系统层的代码</li>
<li>创建一个系统的上下文，可看成一个应用</li>
<li>启动bootstrap引导相关Services，AMS、DisplayManagerService等服务。</li>
<li>启动Core核心相关Services , BatteryService、UserStatsService和WebviewUpdateService。</li>
<li>启动Other其他相关Services，AlarmMangerService、VibratorService。</li>
<li>开始Looper的轮询</li>
</ol>
<h4 id="桌面的启动"><a href="#桌面的启动" class="headerlink" title="桌面的启动"></a>桌面的启动</h4><p>当SystemServer服务就绪的时候，会调用<code> startHomeActivityLocked(currentUserId, &quot;systemReady&quot;)</code>方法，然后会调用<code>ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</code>去找到<code>Launcher</code>启动的<code>Activity</code>，然后调用<code>mActivityStartController.startHomeActivity(intent, aInfo, myReason)</code>来通过意图启动Launcher。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.HOME&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;com.aliyun.ushell.action.detailpage&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="细节与问题-1"><a href="#细节与问题-1" class="headerlink" title="细节与问题"></a>细节与问题</h3><h4 id="系统服务是怎么发布，让应用程序可见？"><a href="#系统服务是怎么发布，让应用程序可见？" class="headerlink" title="系统服务是怎么发布，让应用程序可见？"></a>系统服务是怎么发布，让应用程序可见？</h4><p>绑定到ServiceManager</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804063533311.png" alt="image-20210804063533311"></p>
<h4 id="系统服务跑在什么线程？"><a href="#系统服务跑在什么线程？" class="headerlink" title="系统服务跑在什么线程？"></a>系统服务跑在什么线程？</h4><p>几乎没有在主线程上的，大部分创建在binder线程，部分例如DisplayThread、FgThread(前台线程)、IoThread、UiThread跑在工作线程</p>
<ol>
<li>为什么系统服务不都跑在binder线程里？<br>因为binder线程是共享的，存在资源抢占问题，会影响系统服务响应的实时性。</li>
<li>为什么系统服务不都跑在自己私有的工作线程里？<br>开辟的线程太多，系统负载高，同时会浪费资源在切换线程里。</li>
<li>跑在binder线程和跑在工作线程，如何取舍？<br>对于实时性不高、耗时不多的可以跑在binder线程里</li>
</ol>
<h4 id="怎么解决系统服务之间的相互依赖"><a href="#怎么解决系统服务之间的相互依赖" class="headerlink" title="怎么解决系统服务之间的相互依赖"></a>怎么解决系统服务之间的相互依赖</h4><p>分批启动：比较基础的服务放在前面启动，比如AMS、PKMS<br>分阶段启动：每到一个阶段告诉Service，那些资源可用，可以做那些初始化</p>
<h2 id="怎么添加一个系统服务"><a href="#怎么添加一个系统服务" class="headerlink" title="怎么添加一个系统服务"></a>怎么添加一个系统服务</h2><h3 id="如何使用系统服务"><a href="#如何使用系统服务" class="headerlink" title="如何使用系统服务"></a>如何使用系统服务</h3><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804073153462.png" alt="image-20210804073153462" style="zoom:50%;">

<p>接着看下<code>ServiceFetcher</code>中<code>getService(ctx)</code>的实现：</p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804073233676.png" alt="image-20210804073233676" style="zoom: 33%;">

<p>然后看createService()相关代码，这里以POWER_SERVICE为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.POWER_SERVICE, PowerManager.class,</span><br><span class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;PowerManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> PowerManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> <span class="keyword">throws</span> ServiceNotFoundException </span>&#123;</span><br><span class="line">               <span class="comment">//ServiceManager 通过名称拿到IBinder对象</span></span><br><span class="line">                IBinder b = ServiceManager.getServiceOrThrow(Context.POWER_SERVICE);</span><br><span class="line">                <span class="comment">//IPowerManager 是业务类</span></span><br><span class="line">                IPowerManager service = IPowerManager.Stub.asInterface(b);</span><br><span class="line">                <span class="comment">//PowerManager 是IPowerManager 的包装类，调用还是在IPowerManager里面</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PowerManager(ctx.getOuterContext(),</span><br><span class="line">                        service, ctx.mMainThread.getHandler());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体来看<code>getServiceOrThrow</code>方法，就是调用<code>getService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache for the &quot;well known&quot; services, such as WM and AM.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, IBinder&gt; sCache = <span class="keyword">new</span> HashMap&lt;String, IBinder&gt;()</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IBinder service = sCache.get(name);</span><br><span class="line">            <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> service;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Binder.allowBlocking(rawGetService(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;error in getService&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中<code>rawGetService(name)</code>会通过<code>ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</code>返回IBinder对象。</p>
<h3 id="服务的注册原理"><a href="#服务的注册原理" class="headerlink" title="服务的注册原理"></a>服务的注册原理</h3><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804073709062.png" alt="image-20210804073709062" style="zoom:50%;">

<p>部分系统服务注册是在SystemService初始化注册的。<br>独立进程的系统服务，需要改init.rc的配置且要有main入口函数。</p>
<h3 id="怎么添加一个系统服务-1"><a href="#怎么添加一个系统服务-1" class="headerlink" title="怎么添加一个系统服务"></a>怎么添加一个系统服务</h3><h4 id="添加时机"><a href="#添加时机" class="headerlink" title="添加时机"></a>添加时机</h4><p>添加系统服务的时机：如果想跑到SystemServer里，可以利用SystemServer发布自己的服务；如果想跑在单独的进程，需要改init.rc的配置且要有main入口函数</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>启用binder机制和其他线程通信</p>
<ol>
<li>打开binder驱动</li>
<li>映射内存，分配缓冲区</li>
<li>启动binder线程，进入binder loop</li>
</ol>
<p>初始化配置<br>把服务的binder注册到ServiceManager</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>为了保证调用方式一致，需要为这个服务注册ServiceFactory。</p>
<h2 id="系统服务和bind的应用服务区别"><a href="#系统服务和bind的应用服务区别" class="headerlink" title="系统服务和bind的应用服务区别"></a>系统服务和bind的应用服务区别</h2><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><h4 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h4><p>在SystemServer里面进行分批、分阶段启动，大部分都跑在binder线程里面。</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804074431859.png" alt="image-20210804074431859"></p>
<h4 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a>应用服务</h4><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804080145885.png" alt="image-20210804080145885" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, <span class="keyword">boolean</span> requireForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">            UserHandle user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            validateServiceIntent(service);</span><br><span class="line">            service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">            ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                            getContentResolver()), requireForeground,</span><br><span class="line">                            getOpPackageName(), user.getIdentifier());</span><br><span class="line">            <span class="keyword">if</span> (cn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">&quot;!&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                            <span class="string">&quot;Not allowed to start service &quot;</span> + service</span><br><span class="line">                            + <span class="string">&quot; without permission &quot;</span> + cn.getClassName());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">&quot;!!&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                            <span class="string">&quot;Unable to start service &quot;</span> + service</span><br><span class="line">                            + <span class="string">&quot;: &quot;</span> + cn.getClassName());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                            <span class="string">&quot;Not allowed to start service &quot;</span> + service + <span class="string">&quot;: &quot;</span> + cn.getClassName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cn;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>ActivityManager.getService().startService()</code>启动的，后面会跟到源码<code>ActiveServices</code>这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveServices</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ... ...</span><br><span class="line"></span><br><span class="line">            app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                    mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo), app.getReportedProcState());</span><br><span class="line">            ... ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>app 对象的 thread 会调用到客户端的 ActivityThread 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> <span class="keyword">extends</span> <span class="title">ClientTransactionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApplicationThread 是一个 Binder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">IApplicationThread</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">                ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">            updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">            CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">            s.token = token;</span><br><span class="line">            s.info = info;</span><br><span class="line">            s.compatInfo = compatInfo;</span><br><span class="line">            sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很熟悉的<code>sendMessage</code>方法，会发送消息到<code>H</code>类里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">			 ...	</span><br><span class="line">                <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">&quot;serviceCreate: &quot;</span> + String.valueOf(msg.obj)));</span><br><span class="line">                    handleCreateService((CreateServiceData)msg.obj);    <span class="comment">// 调用 handleCreateService() 方法</span></span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">			...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>跟入<code>handleCreateService((CreateServiceData)msg.obj)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">        <span class="comment">// we are back active so skip it.</span></span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                data.info.applicationInfo, data.compatInfo);</span><br><span class="line">        Service service = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = packageInfo.getAppFactory()</span><br><span class="line">                .instantiateService(cl, data.info.name, data.intent);</span><br><span class="line">        </span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManager.getService());</span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>分开看，<code>instantiateService</code>用来构建Service对象，<code>attach</code>给service赋予application，最后调用<code>onCreate</code>方法。</p>
<h3 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h3><h4 id="系统服务-1"><a href="#系统服务-1" class="headerlink" title="系统服务"></a>系统服务</h4><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804075326480.png" alt="image-20210804075326480" style="zoom:50%;">

<p>总体上无论SystemServer、还是单独进程，都是要注册到ServiceManager上的。</p>
<h4 id="应用服务-1"><a href="#应用服务-1" class="headerlink" title="应用服务"></a>应用服务</h4><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804075355725.png" alt="image-20210804075355725"></p>
<ol>
<li>应用端会向AMS发起bindService。</li>
<li>AMS会先判断这个Service是否已经注册过了，注册过就直接把之前发布的binder返回给应用；如果没有，AMS会像Service请求binder对象。（AMS请求的，属于被动注册）</li>
<li>Service会响应AMS的请求，发布这个binder对象到AMS</li>
<li>AMS再把这个binder对象回调给应用</li>
</ol>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="系统服务-2"><a href="#系统服务-2" class="headerlink" title="系统服务"></a>系统服务</h4><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804080507956.png" alt="image-20210804080507956"></p>
<p>通过服务名去找到对应的ServiceFetcher对象：</p>
<ol>
<li>先通过SM.getService拿到binder对象</li>
<li>封装了一层拿到服务的管理对象。</li>
</ol>
<h4 id="应用服务-2"><a href="#应用服务-2" class="headerlink" title="应用服务"></a>应用服务</h4><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804080742597.png" alt="image-20210804080742597" style="zoom: 50%;">

<ol>
<li>通过bindService向AMS发送绑定服务端请求</li>
<li>AMS通过onServiceConnected()回调把服务的binder对象返回给业务端，然后把这个对象封装成业务接口对象给业务接口调用。</li>
</ol>
<h2 id="ServiceManager启动和工作原理"><a href="#ServiceManager启动和工作原理" class="headerlink" title="ServiceManager启动和工作原理"></a>ServiceManager启动和工作原理</h2><h3 id="ServiceManager启动流程-1"><a href="#ServiceManager启动流程-1" class="headerlink" title="ServiceManager启动流程"></a>ServiceManager启动流程</h3><ol>
<li>启动进程</li>
<li>启用Binder机制</li>
<li>发布自己的服务</li>
<li>等待并响应请求</li>
</ol>
<p><strong>具体流程：</strong><br>ServiceManager也是配置<code>init.rc</code>启动文件中的,也是通过init进程拉起来的。</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804081458144.png" alt="image-20210804081458144"></p>
<p>然后执行了<code>service_manager.c</code>的main函数：<br>frameworks/native/cmds/servicemanager/service_manager.c</p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804081539244.png" alt="image-20210804081539244" style="zoom:33%;">

<p><code>binder_open(128*1024)</code>，打开binder驱动。</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804082613885.png" alt="image-20210804082613885"></p>
<p>主要是打开binder驱动，会返回一个描述符，然后再调用mmap给描述符创建一块内存（128K，业务比较简单，够用了）。</p>
<p><code>binder_become_context_manager(bs)</code>，把自己注册成上下文管理者。</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804082653707.png" alt="image-20210804082653707"></p>
<p>就是告诉binder驱动，自身已经准备就绪了。</p>
<p><code>binder_loop(bs,svcmgr_handler)</code>，开启轮询，等待并处理请求。</p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804082818267.png" alt="image-20210804082818267" style="zoom:33%;">

<p>binder_write用来处理读写请求的。<br>BINDER_WRITE_READ 是读写指令，如何判断是读还是写，是看read_size和write_size是否大于0，都大于0 ，优先写。）</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804083621329.png" alt="image-20210804083621329"></p>
<p><code>for(;;)</code>开启轮询，然后调用<code>binder_parse</code>去执行请求。</p>
<h3 id="获取ServiceManager的binder对象"><a href="#获取ServiceManager的binder对象" class="headerlink" title="获取ServiceManager的binder对象"></a>获取ServiceManager的binder对象</h3><p>以SurfaceFlinger获取SM为例子，<code>defaultServiceManager()</code>来获取ServiceManager：</p>
<p><img src="https://img-blog.csdnimg.cn/20210407195759677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVYW5kcm9pZA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>先判断缓存是否存在，不存在会开启一个等待。SurfaceFlinger也是init.rc拉起来，存在ServiceManager还没初始化完成的状态。通过getContextObject获取ServiceManager的binder对象。</p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804174154785.png" alt="image-20210804174154785" style="zoom: 50%;">

<p>IBinder对象就是BpBinder。    </p>
<h3 id="向ServiceManager添加服务"><a href="#向ServiceManager添加服务" class="headerlink" title="向ServiceManager添加服务"></a>向ServiceManager添加服务</h3><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804174449051.png" alt="image-20210804174449051"></p>
<p>通过remote()获得BpBinder对象，再调用BpBinder的transcat函数：</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804175100203.png" alt="image-20210804175100203"></p>
<p>IPCThreadState是线程内的单例，负责与binder交互的，通过Handle与驱动交互。<br>再看ServiceManager接收方：</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804175136552.png" alt="image-20210804175136552"></p>
<p>通过svcmgr_handler()，switch处理code，调用<code>do_add_service(bs,s,len,handle,...)</code>，注册一个handler插入到一个单链表里面。</p>
<h3 id="从ServiceManager获取服务"><a href="#从ServiceManager获取服务" class="headerlink" title="从ServiceManager获取服务"></a>从ServiceManager获取服务</h3><p>跟注册服务差不多，发起binder调用：</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804175259418.png" alt="image-20210804175259418"></p>
<p>跟上面一样，ServiceManager接受handler消息处理：</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804175409056.png" alt="image-20210804175409056"></p>
<p>接收方也是通过svcmgr_handler()，switch处理code，调用<code>do_find_service</code>找到对应binder对象的handle值返回。</p>
<h1 id="应用进程相关"><a href="#应用进程相关" class="headerlink" title="应用进程相关"></a>应用进程相关</h1><h2 id="应用进程是怎么启动的"><a href="#应用进程是怎么启动的" class="headerlink" title="应用进程是怎么启动的"></a>应用进程是怎么启动的</h2><h3 id="Linux下进程的启动方式"><a href="#Linux下进程的启动方式" class="headerlink" title="Linux下进程的启动方式"></a>Linux下进程的启动方式</h3><p>还记得前面提到SystemService的启动么，都是通过fork()孵化出来的：</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804175629452.png" alt="image-20210804175629452"></p>
<p>两者区别就是exevce方法的执行，普通fork()子进程会共享父进程资源，而exevce的fork()出的子进程资源会被path替换掉，path是一个二进制程序的路径。</p>
<h3 id="应用进程启动的原理"><a href="#应用进程启动的原理" class="headerlink" title="应用进程启动的原理"></a>应用进程启动的原理</h3><h4 id="什么时候触发的进程启动？谁发起的？"><a href="#什么时候触发的进程启动？谁发起的？" class="headerlink" title="什么时候触发的进程启动？谁发起的？"></a>什么时候触发的进程启动？谁发起的？</h4><p>一般是被动触发的，对于android而言，如果要启动的组件所在进程未启动，就会启动进程了。</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804175720944.png" alt="image-20210804175720944"></p>
<p>解释下<code>app.thread</code>:</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804175836378.png" alt="image-20210804175836378"></p>
<p>在应用启动的时候，会向AMS通信，即会调用IActivityManager的函数告诉AMS自身启动意图和注册IApplicationThread句柄（句柄是一个标识符）。</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804180002280.png" alt="image-20210804180002280"></p>
<h4 id="进程是谁启动的？怎么启动？"><a href="#进程是谁启动的？怎么启动？" class="headerlink" title="进程是谁启动的？怎么启动？"></a>进程是谁启动的？怎么启动？</h4><p>启动参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/HUandroid/article/details/103454434">9.0app启动</a></p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804180031051.png" alt="image-20210804180031051"></p>
<p>zygote启动loop后，收到消息会调用runOnce函数，里面会fork进程后，子进程（pid==0）会调用handleChildProc()方法，会启动ActivityThread的入口函数main；父进程（pid&gt;0）会调用handlePanrentProc（pid..）方法，会通过socket将pid写回去。</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804180132194.png" alt="image-20210804180132194"></p>
<ol>
<li>由AMS通过socket向zygote发起 –&gt; socket是为了避免启动多线程</li>
<li>zygote fork出应用进程，即通过startProcessLocked方法，打开本地socket，发送参数列表，返回创建的进程id，执行ActivityThread的main函数</li>
<li>进程启动之后向AMS报告，整个启动才算结束（AMS确定进程启动后才能去启动各个组件</li>
</ol>
<h2 id="应用怎么启用Binder机制的"><a href="#应用怎么启用Binder机制的" class="headerlink" title="应用怎么启用Binder机制的"></a>应用怎么启用Binder机制的</h2><h3 id="支持binder时机"><a href="#支持binder时机" class="headerlink" title="支持binder时机"></a>支持binder时机</h3><p>根据前面系统启动可知，binder机制是zygote拉起SystemServer时候就开始支持的。</p>
<h3 id="怎么启动Binder机制"><a href="#怎么启动Binder机制" class="headerlink" title="怎么启动Binder机制"></a>怎么启动Binder机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[打开binder驱动] --&gt; B[映射内存分配缓冲区]</span><br><span class="line">B --&gt; C[注册Binder线程]</span><br><span class="line">C --&gt; D[进入BinderLoop]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="对Application的理解"><a href="#对Application的理解" class="headerlink" title="对Application的理解"></a>对Application的理解</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>保存应用进程内的全局变量</li>
<li>提供应用的上下文</li>
<li>提供初始化入口</li>
</ul>
<p>注意：Application是对应的进程，而不是应用。一般情况下，一个应用对应一个进程一个虚拟机，也可以在清单文件中配置多个进程，这样Application会初始化多次。</p>
<h3 id="类继承关系及生命周期～"><a href="#类继承关系及生命周期～" class="headerlink" title="类继承关系及生命周期～"></a>类继承关系及生命周期～</h3><p>直接看图：</p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804180946698.png" alt="image-20210804180946698" style="zoom:70%;">

<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804181048614.png" alt="image-20210804181048614"></p>
<p>Application就是一个全局的上下文。<br>生命周期：</p>
<ul>
<li>构造函数</li>
<li>attachBaseContext</li>
<li>onCreate</li>
</ul>
<p>调用顺序请查看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/HUandroid/article/details/103454434">9.0app启动</a></p>
<h3 id="初始化原理"><a href="#初始化原理" class="headerlink" title="初始化原理"></a>初始化原理</h3><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804181152621.png" alt="image-20210804181152621"></p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804181441522.png" alt="image-20210804181441522"></p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804181504518.png" alt="image-20210804181504518"></p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804181533453.png" alt="image-20210804181533453"></p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804181607318.png" alt="image-20210804181607318"></p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804181643148.png" alt="image-20210804181643148"></p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804181725021.png" alt="image-20210804181725021"></p>
<p>面试题：Application创建、Application.onCreate()、Activity创建、Activity.onCreate()的执行顺序？<br>答：Activity创建 -》Application创建-》Application.onCreate()-》Activity.onCreate()<br>注意点1：不要在Application初始化阶段，执行耗时操作。<br>注意点2: Application中使用使用静态变量的问题，在挂在后台后，再次进入应用可能会内存重建（内存不足，杀掉app，再进入前台后创建进程和恢复activity），这个静态变量可能没有初始化导致的bug。对Context的理解</p>
<h2 id="对Context的理解"><a href="#对Context的理解" class="headerlink" title="对Context的理解"></a>对Context的理解</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804181927911.png" alt="image-20210804181927911"></p>
<p>根据官方注解，Context是一个有关应用程序环境的全局信息的接口。这是一个抽象类，其实现由Android系统提供。它允许访问特定于应用程序的资源和类，以及对应用程序级操作（例如启动活动，广播和接收意图等）的调用。<br>而具体实现是由ContextImpl来实现的：包含了各类资源的调用。</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804182136345.png" alt="image-20210804182136345"></p>
<h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>Context 的创建分为三种组件：<code>Application</code> <code>Activity</code> <code>Service</code>。</p>
<h4 id="Application的Context"><a href="#Application的Context" class="headerlink" title="Application的Context"></a>Application的Context</h4><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804182604515.png" alt="image-20210804182604515"></p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804184505501.png" alt="image-20210804184505501"></p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804185118638.png" alt="image-20210804185118638"></p>
<p>而Application继承于ContextWrapper的：</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804185657489.png" alt="image-20210804185657489"></p>
<p>将创建的ContextImpl的实现类给交了ContextWrapper，ContextWrapper就是作为一个包装类来使用。</p>
<h4 id="Activity的Context"><a href="#Activity的Context" class="headerlink" title="Activity的Context"></a>Activity的Context</h4><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804185840788.png" alt="image-20210804185840788"></p>
<h4 id="Service的context"><a href="#Service的context" class="headerlink" title="Service的context"></a>Service的context</h4><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210804190417559.png" alt="image-20210804190417559"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>应用里面有多少个Context？不同Context之间有什么区别？<br>application+activity+service，注意多进程。activity的context是继承ContextThemeWrapper，多了UI组件。</li>
<li>Activty里的this和getBaseContext有什么区别？<br>this是返回自身，而getBaseContext 是返回ContextWrapper里面的mBase。</li>
<li>getApplication和getApplicationContext有什么区别？<br>getApplication是Activity和Service里面特有的，getApplicationContext是Context里面的抽象函数。</li>
<li>Dialog使用Application作为context为什么会报错？<br>使用Application的context构建dialog会报BadTokenException，因为activity这类context是带有Token信息的。每一个ActivityRecord里面都有一个appToken变量，它是一个Binder对象，主要用于维持该Activity在AMS里与WindowManager之间的联系。它在ActivityRecord的构造函数中被初始化，通过调用WindowManager.addAppToken方法将该Token注册到WindowManagerService里面。</li>
</ol>
<h1 id="Activity组件相关"><a href="#Activity组件相关" class="headerlink" title="Activity组件相关"></a>Activity组件相关</h1><h2 id="Activity的启动流程"><a href="#Activity的启动流程" class="headerlink" title="Activity的启动流程"></a>Activity的启动流程</h2><p>参考9.0启动流程<a target="_blank" rel="noopener" href="https://blog.csdn.net/HUandroid/article/details/103454434">https://blog.csdn.net/HUandroid/article/details/103454434</a></p>
<h2 id="Activity的显示原理"><a href="#Activity的显示原理" class="headerlink" title="Activity的显示原理"></a>Activity的显示原理</h2><h3 id="显示原理"><a href="#显示原理" class="headerlink" title="显示原理"></a>显示原理</h3><p>Activity启动的时候会调用到<code>handleResumeActivity()</code>，实现在<code>ActivityThread</code>里面的简化代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">         String reason)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">     <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">     r.window = r.activity.getWindow();</span><br><span class="line">     View decor = r.window.getDecorView();</span><br><span class="line">     <span class="comment">//makeVisible 方法会设置VISIBLE</span></span><br><span class="line">     decor.setVisibility(View.INVISIBLE);</span><br><span class="line">   	<span class="comment">//获取ViewManager 其实就是WindowManager</span></span><br><span class="line">     ViewManager wm = a.getWindowManager();</span><br><span class="line">     <span class="comment">//a.mWindowAdded = true;</span></span><br><span class="line">    <span class="comment">// wm.addView(decor, layoutParams);</span></span><br><span class="line">      r.activity.makeVisible()</span><br><span class="line">     Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先理解两个概念Window、WindowManager：</p>
<p><strong>Window</strong>是一个抽象类，<strong>PhoneWindow</strong>是它的唯一实现类。Android中的所有视图都是通过Window来实现的。不管是Activity、Dialog还是Toast，它们的视图实际上都是附加在Window上的。View是Android中呈现视图的方式，但是View不能单独存在，必须附着在Window这个抽象的概念上。<strong>每个Window都对应着一个View和一个ViewRootImpl</strong>，Window和View通过ViewRootImpl来建立联系。</p>
<p><strong>WindowManager</strong><br>Window的管理者，可以<strong>创建Window</strong>。Window的具体实现是在WindowManagerService中，WindowManager和WindowManagerService之间的交互是一个<strong>IPC</strong>过程。WindowManager的实现类是WindowManagerImpl，而WindowManagerImpl是个包装类，真正干活的是WindowManagerGlobal，提供了WMS的通信。</p>
<p>接着跟进<code>makeVisible</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">           ViewManager wm = getWindowManager();</span><br><span class="line">           wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">           mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>回调用ViewManager的addView方法，其实就是就是调用WindowManager的addView方法，最后由<code>WindowManagerGlobal</code>实现<code>addView</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line">   <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">   <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">           <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> ArraySet&lt;View&gt;();</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">           Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">       ViewRootImpl root;</span><br><span class="line">       View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">           root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">           view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">           mViews.add(view);</span><br><span class="line">           mRoots.add(root);</span><br><span class="line">           mParams.add(wparams);</span><br><span class="line">           root.setView(view, wparams, panelParentView);</span><br><span class="line">           <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               root.setView(view, wparams, panelParentView);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">               <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">               <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后是调用<code>ViewRootImpl</code>去<code>setView</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               ...</span><br><span class="line">               <span class="comment">//请求绘制</span></span><br><span class="line">               requestLayout();</span><br><span class="line">               <span class="comment">//收集属性</span></span><br><span class="line"> 				collectViewAttributes();</span><br><span class="line">               res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                           getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,</span><br><span class="line">                           mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                           mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,</span><br><span class="line">                           mTempInsets);</span><br><span class="line">                   setFrame(mTmpFrame);</span><br><span class="line">             </span><br><span class="line">               ...               </span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重要的方法<code>requestLayout()</code>，大家都很熟悉，会调用到<code>scheduleTraversals()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">           checkThread();</span><br><span class="line">           mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">           scheduleTraversals();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终会走到<code>performTraversals()</code>方法，执行<code>performMeasure()</code> <code>performLayout()</code> <code>performDraw()</code>，完成view的绘制。</p>
<p>分析<code>mWindowSession</code>：</p>
<p>IWindowSession其实是个binder对象，其最后是一个Session对象，负责与WMS通信的。</p>
<img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210805173156984.png" alt="image-20210805173156984" style="zoom:50%;">

<p>分析<code>addToDisplay</code>调用：</p>
<p>主要是将mWindow注册到WMS端构成双向绑定，重要的是WMS将获取到的Window信息进行汇总即位置、层级、大小等进行合成，显示在屏幕的缓冲区里面。</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210805173332193.png" alt="image-20210805173332193"></p>
<p><strong>setContentView原理是什么：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        getWindow().setContentView(layoutResID);</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>getWindow()</code> 是返回Window对象，在attach()函数里初始化的: <code>mWindow = new PhoneWindow(this, window, activityConfigCallback)</code>,跟进<code>PhoneWindow.setContentView</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">       <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">       <span class="comment">// before this happens.</span></span><br><span class="line">       <span class="comment">// 用来装ContentView的</span></span><br><span class="line">       <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">           installDecor();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">           mContentParent.removeAllViews();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">           <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                   getContext());</span><br><span class="line">           transitionTo(newScene);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//将生成的view 装入mContentParent里面</span></span><br><span class="line">           mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">       &#125;</span><br><span class="line">       mContentParent.requestApplyInsets();</span><br><span class="line">       <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">       <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">           cb.onContentChanged();</span><br><span class="line">       &#125;</span><br><span class="line">       mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以要看看 <code>installDecor()</code>干了那些活：</p>
<img src="https://img-blog.csdnimg.cn/20210513152139484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVYW5kcm9pZA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;">

<p>然后大致可以理解成这样的：</p>
<img src="https://img-blog.csdnimg.cn/20210513154936180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVYW5kcm9pZA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;">

<h3 id="UI线程"><a href="#UI线程" class="headerlink" title="UI线程"></a>UI线程</h3><p>UI线程是刷新UI所在的线程，是单线程模型。</p>
<h4 id="UI线程是主线程嘛？"><a href="#UI线程是主线程嘛？" class="headerlink" title="UI线程是主线程嘛？"></a>UI线程是主线程嘛？</h4><p>从<code>Activity.runOnUiThread(Runnable)</code>和<code>View.post(Runnable)</code>对比找到答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">         mHandler.post(action);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         action.run();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其中mHandle是activity中创建的，所以对应的是activity创建所在的线程的Looper。<br>而mUiThread是在activty的attach函数中赋值的。而Activity的创建都是在主线程的，所以，对与 Activity来说，UI线程就是主线程。<br>再看View.post(Runnable)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></span><br><span class="line">        <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></span><br><span class="line">        getRunQueue().post(action);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>attachInfo是在视图被添加到window时候附加的信息，即是ViewTree在递归的时候对每个view赋予的，在ViewRootImpl构造函数里面创建的。所以attachInfo.mHandler就是ViewRootImpl.ViewRootHandler,所以对应的当前线程就是创建ViewRootImpl的线程。<br>另一种情况：attachInfo==null （因为ViewRootImpl是在onResume创建的）,会将action丢到HandlerActionQueue里面，也是绑定了创建ViewRootImpl的线程。所以，<strong>对View来说，它的UI线程就是ViewRootImpl创建时候所在的线程。</strong></p>
<h4 id="一个异常"><a href="#一个异常" class="headerlink" title="一个异常"></a>一个异常</h4><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210805174116712.png" alt="image-20210805174116712"></p>
<p>具体位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                  <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中mThread就是ViewRootImpl初始化的，对应就是ViewRootImpl创建的线程。所以要理解ViewRootImpl创建流程：</p>
<p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210805174155699.png" alt="image-20210805174155699"></p>
<p>所以，<strong>Activty的DecorView对应的ViewRootImpl是在主线程创建的！</strong>    </p>
<h4 id="三个结论"><a href="#三个结论" class="headerlink" title="三个结论"></a>三个结论</h4><p><img src="/2021/07/28/%E5%89%96%E6%9E%90Framework%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/image-20210805174251588.png" alt="image-20210805174251588"></p>
<p>根据上面的结论，可退出：<strong>UI线程==主线程</strong></p>
<h4 id="非UI线程能更新UI嘛"><a href="#非UI线程能更新UI嘛" class="headerlink" title="非UI线程能更新UI嘛"></a>非UI线程能更新UI嘛</h4><p>所以，又有一个经典问题：非UI线程能更新UI嘛？<br>答：特定情况能更新，为啥了？<br>还记得checkThread()的报错么？是ViewRootImpl报的，如果ViewRootImpl还没被创建，就能更新UI了。ViewRootImpl的创建是在onResume之后执行的。<br>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_test);</span><br><span class="line">      TextView textView = (TextView) findViewById(R.id.actv_test);</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              textView.setText(<span class="string">&quot;子线程更新UI&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>发现textView的文本发生了变化，是不是达到了非UI线程更新UI的效果了。<br>然后在理解理解这句话 对View来说，它的UI线程就是ViewRootImpl创建时候所在的线程，记得每个window是跟ViewRootImpl是对应关系的，所以我们也可以在非UI线程添加窗口，并操作。反而你在主线程操作反而会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">WindowManager.LayoutParams layoutParams = <span class="keyword">new</span> WindowManager.LayoutParams(<span class="number">300</span>, <span class="number">300</span>, WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, <span class="number">0</span>, PixelFormat.RGBA_8888);</span><br><span class="line">            layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;</span><br><span class="line">            layoutParams.gravity = Gravity.CENTER;</span><br><span class="line">            WindowManager mWindowManager = (WindowManager) getApplicationContext().getSystemService(WINDOW_SERVICE);</span><br><span class="line"></span><br><span class="line">            mWindowManager.addView(button1,layoutParams);</span><br><span class="line">             <span class="comment">//当前线程绑定view，所以能操作view</span></span><br><span class="line">            button1.setText(<span class="string">&quot;非&quot;</span>);</span><br><span class="line">            button1.setTextSize(<span class="number">66</span>);</span><br><span class="line">            </span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Handler sHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">    sHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里放开就会报CalledFromWrongThreadException错，就是checkThread()报的</span></span><br><span class="line">            <span class="comment">//   button1.setText(&quot;主&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/27/%E4%BB%8EOkHttp%E7%9A%84%E5%8E%9F%E7%90%86%E6%9D%A5%E7%9C%8BHTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/27/%E4%BB%8EOkHttp%E7%9A%84%E5%8E%9F%E7%90%86%E6%9D%A5%E7%9C%8BHTTP/" class="post-title-link" itemprop="url">从OkHttp的原理来看HTTP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-27 18:08:58" itemprop="dateCreated datePublished" datetime="2021-07-27T18:08:58+08:00">2021-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-06 17:21:59" itemprop="dateModified" datetime="2021-09-06T17:21:59+08:00">2021-09-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/OkHttp/" itemprop="url" rel="index"><span itemprop="name">OkHttp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从OkHttp的原理来看HTTP"><a href="#从OkHttp的原理来看HTTP" class="headerlink" title="从OkHttp的原理来看HTTP"></a>从OkHttp的原理来看HTTP</h1><h2 id="OkHttp的演进之路"><a href="#OkHttp的演进之路" class="headerlink" title="OkHttp的演进之路"></a>OkHttp的演进之路</h2><ul>
<li>原生方案不好用，Square 自己造： OkHttp的初版</li>
<li>从头撸到脚：脱离对原生的依赖</li>
<li>被Android官方收录: 成为业界公认最佳方案</li>
</ul>
<h2 id="OkHttp基本使用方法"><a href="#OkHttp基本使用方法" class="headerlink" title="OkHttp基本使用方法"></a>OkHttp基本使用方法</h2><ol>
<li><p>创建一个OkHttp的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder().build();</span><br></pre></td></tr></table></figure></li>
<li><p>创建Request</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">&quot;http://hencoder.com&quot;</span>).build();</span><br></pre></td></tr></table></figure></li>
<li><p>创建<code>Call</code>并发起请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123; </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;okhttp response&quot;</span>,response.body().string());</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="OkHttp-框架结构分析"><a href="#OkHttp-框架结构分析" class="headerlink" title="OkHttp 框架结构分析"></a>OkHttp 框架结构分析</h2><p>发出请求的大框架：<code>client.newCall(request).enqueue(new Callback()&#123;...&#125;)</code></p>
<ol>
<li>先是newCall 里面创建一个RealCall，创建完之后执行的enqueue方法也就是RealCall的enqueue方法</li>
<li>RealCall的enqueue调用了Dispatcher的enqueue方法，将最新的call扔进readyAsyncCalls里（将准备好要执行还没执行的List）</li>
<li>符合条件的call全部执行一遍：将符合条件的call放进 executableCalls，遍历执行每个asyncCall的executeOn方法</li>
<li>executeOn本质上执行runnable的run方法，到了run里面会调用getResponseWithInterceptorChain()获得响应，最终获得响应就会给responseCallback返回结果，出错就会返回responseCallback的onFailure()</li>
<li>同步执行execute一般不会使用，但是例如拿到token之后再请求一次就需要用到同步请求，它会直接调用getResponseWithInterceptorChain()方法发起请求获得响应</li>
</ol>
<p><code>enqueue</code>方法，是一个抽象接口调用的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Call</span> : <span class="type">Cloneable &#123;...fun enqueue</span></span>(responseCallback: Callback)...&#125;</span><br></pre></td></tr></table></figure>
<p><code>newCall</code> 方法是<code>HttpClient</code>中的方法,会返回一个<code>RealCall</code>对象，他<code>Call</code>接口的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Prepares the [request] to be executed at some point in the future. */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h3 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealCall</span></span>(</span><br><span class="line">  <span class="comment">//OkHttpClient：Okhttp的大总管，所有的通用配置都在这配置比如超时时间等</span></span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="comment">//初始的请求，后续会多次封装，对于Okhttp来说request就是你发起一个Http请求需要的所有条件（method，body，header等）</span></span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="comment">// WebSocket：应用层协议，服务器可以主动给客户端发送消息，适用于频繁刷新数据，链接是通过HTTP协议建立的（为了兼容浏览器）</span></span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;...&#125;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跟踪错误，监听请求内容</span></span><br><span class="line">    callStart()</span><br><span class="line">    <span class="comment">//调用dispatcher执行enqueue</span></span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">callStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 跟踪出现的错误用于错误分析</span></span><br><span class="line">    <span class="keyword">this</span>.callStackTrace=Platform.<span class="keyword">get</span>().getStackTraceForCloseable(<span class="string">&quot;response.body().close()&quot;</span>)</span><br><span class="line">   <span class="comment">// 反馈/回调，evetnListener是Http交互过程的监听器，他会监听各种内容【header，body开始发送/接收，TCP    的链接（socket）等】，对整个程序没有干预。</span></span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ..</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">      client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 切换线程执行 runnable方法</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">        timeout.enter()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//拿到服务器的响应</span></span><br><span class="line">          <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">          signalledCallback = <span class="literal">true</span></span><br><span class="line">          <span class="comment">//responseCallback就是在真正使用时调用的Callback：client.newCall(request).enqueue(new Callback()&#123;...&#125;)</span></span><br><span class="line">          responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">          <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">          ...</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>Dispatcher</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">  <span class="comment">//依靠Excutor进行线程调度，若没有线程调度同时有多个请求发生时只能排队</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// maxRequests： 最大有多少个请求同时进行，超出需要等待。可以配置</span></span><br><span class="line">  <span class="meta">@get:Synchronized</span> <span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line">    <span class="keyword">set</span>(maxRequests) &#123;</span><br><span class="line">      require(maxRequests &gt;= <span class="number">1</span>) &#123; <span class="string">&quot;max &lt; 1: <span class="variable">$maxRequests</span>&quot;</span> &#125;</span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        field = maxRequests</span><br><span class="line">      &#125;</span><br><span class="line">      promoteAndExecute()</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//maxRequestsPerHost你的每个主机同时能有多少个请求，超出需要等待。可以配置</span></span><br><span class="line">  <span class="meta">@get:Synchronized</span> <span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line">    <span class="keyword">set</span>(maxRequestsPerHost) &#123;</span><br><span class="line">      require(maxRequestsPerHost &gt;= <span class="number">1</span>) &#123; <span class="string">&quot;max &lt; 1: <span class="variable">$maxRequestsPerHost</span>&quot;</span> &#125;</span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        field = maxRequestsPerHost</span><br><span class="line">      &#125;</span><br><span class="line">      promoteAndExecute()</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 双向队列，存放准备好执行还没执行的请求</span></span><br><span class="line">  <span class="comment">//这种请求有两种，</span></span><br><span class="line">  <span class="comment">//1. 调用enqueue传递的call: AsyncCall</span></span><br><span class="line">  <span class="comment">//2. 刚才传递来的call：AsynCall，因为稍后的请求个数被限制了被挡住的请求。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">        <span class="comment">// 和主机的连接数是根据主机名存储的变量，存在每个AsyncCall内部且可以共享</span></span><br><span class="line">        <span class="comment">// 遍历已有的AsyncCall，如果有和这次请求的Host建立的链接就拿出来</span></span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行readyAsyncCalls里的请求</span></span><br><span class="line">    promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// promote:推举 Execute：执行，把符合条件（还没执行过且执行它不会超负载）的没有执行的Call全部推举出来拿去执行。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//遍历已经准备好的Call</span></span><br><span class="line">      <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">      <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line">				<span class="comment">//把符合条件的筛选出来（不超过maxRequests和maxRequestsPerHost最大限制）</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">        i.remove()</span><br><span class="line">        asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">        <span class="comment">//将筛选过的Call推举出来，即加入专门的Listzhong（executableCalls）</span></span><br><span class="line">        executableCalls.add(asyncCall)</span><br><span class="line">        <span class="comment">//顺便加入正在执行的Calls，用于做记录</span></span><br><span class="line">        runningAsyncCalls.add(asyncCall)</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//将推举出的asyncCall挨个去执行，遍历执行AsyncCall的ExecuteOn函数</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">      asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">      client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line">       ...</span><br><span class="line">        <span class="comment">//切换线程，将Runnable丢过去执行</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">       ...</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><code>execute</code>方法同步执行,一般来说请求网络都是要异步的，但也有例外比如：请求过程中拿到一个token要继续请求，我们不需要切换线程。</p>
<p>RealCall: 直接调用getResponseWithInterceptorChain</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">   synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">     check(!executed) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">     executed = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   timeout.enter()</span><br><span class="line">   callStart()</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">     <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="OkHttpClient-配置清单"><a href="#OkHttpClient-配置清单" class="headerlink" title="OkHttpClient 配置清单"></a>OkHttpClient 配置清单</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">	<span class="comment">//调度器，用于调度后台发起的网络请求， 有后台总请求数和单主机总请求数的控制。</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;dispatcher&quot;</span>) <span class="keyword">val</span> dispatcher: Dispatcher = builder.dispatcher</span><br><span class="line">  <span class="comment">//连接池：管理连接的工具，存储批量的连接，创建一个连接的时候不先创建，先看连接池里有没有，有就直接调用</span></span><br><span class="line">  <span class="comment">//若调用结束也不急着销毁，先存储在连接池，超时不用再销毁（看配置）</span></span><br><span class="line">  <span class="comment">//池概念：同类变量的管理，通过资源复用和动态回收形成性能和资源占用的动态平衡。</span></span><br><span class="line">  <span class="comment">//连接池重用 </span></span><br><span class="line">  <span class="comment">//http1：已经用完了的连接可以在创建其他连接时重用</span></span><br><span class="line">  <span class="comment">//http2：正在使用的连接也可以重用（多路复用）</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;connectionPool&quot;</span>) <span class="keyword">val</span> connectionPool: ConnectionPool = builder.connectionPool</span><br><span class="line">  <span class="comment">//拦截器</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;interceptors&quot;</span>) <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.interceptors.toImmutableList()</span><br><span class="line">  <span class="comment">//请求拦截器</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;networkInterceptors&quot;</span>) <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.networkInterceptors.toImmutableList()</span><br><span class="line">  <span class="comment">//生产eventListener 的工厂，是监听各种事件的监听器（请求发起，连接创立等）</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;eventListenerFactory&quot;</span>) <span class="keyword">val</span> eventListenerFactory: EventListener.Factory =</span><br><span class="line">      builder.eventListenerFactory</span><br><span class="line">  <span class="comment">//连接失败/请求失败是否重试的配置，403不算失败，管理的是TCP请求连接失败或者无响应，默认true</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;retryOnConnectionFailure&quot;</span>) <span class="keyword">val</span> retryOnConnectionFailure: <span class="built_in">Boolean</span> =</span><br><span class="line">      builder.retryOnConnectionFailure</span><br><span class="line">	<span class="comment">//自动重新认证。配置之后，在 请求收到 401 状态码的响应时，会直接调用authenticator，手动加入Authorization header 之后自动重新发起请求</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;authenticator&quot;</span>) <span class="keyword">val</span> authenticator: Authenticator = builder.authenticator</span><br><span class="line">	<span class="comment">//重定向时，如果原先请求的是 http 而重定向的目标是 https，或者原先请求的是 https 而重定向的目标是 //http，是否依然自动 follow。(记得，不是「是否自动 follow HTTPS URL 重定向的意思，而是是否自动 follow //在 HTTP 和 HTTPS 之间切换的重定向)</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;followRedirects&quot;</span>) <span class="keyword">val</span> followRedirects: <span class="built_in">Boolean</span> = builder.followRedirects</span><br><span class="line">	<span class="comment">//额外开关默认true：上面开关打开的前提下，重定向的时候发生协议切换的时候是否进行重定向，有人可以利用协议切换进行恶意攻击</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;followSslRedirects&quot;</span>) <span class="keyword">val</span> followSslRedirects: <span class="built_in">Boolean</span> = builder.followSslRedirects</span><br><span class="line">  <span class="comment">//饼干罐cookie：饼干Jar：罐子，存储是默认不实现的。想用要自己实现</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;cookieJar&quot;</span>) <span class="keyword">val</span> cookieJar: CookieJar = builder.cookieJar</span><br><span class="line">  <span class="comment">//缓存，本地缓存</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;cache&quot;</span>) <span class="keyword">val</span> cache: Cache? = builder.cache</span><br><span class="line">	<span class="comment">//域名解析成ip地址，使用的Java原生方法</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;dns&quot;</span>) <span class="keyword">val</span> dns: Dns = builder.dns</span><br><span class="line">  <span class="comment">//代理，为了做网络管制，请求都要由代理服务器选择性转发可以代理 DIRECT(直连),HTTP,SOCKS，默认null</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;proxy&quot;</span>) <span class="keyword">val</span> proxy: Proxy? = builder.proxy</span><br><span class="line">  <span class="comment">//proxySelector的select方法会返回一个List&lt;Proxy&gt;，若proxy没配置，则会在连接后调用select()遍历</span></span><br><span class="line">  <span class="comment">//List&lt;Proxy&gt; 选择可以使用的Proxy（默认直连）</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;proxySelector&quot;</span>) <span class="keyword">val</span> proxySelector: ProxySelector =</span><br><span class="line">      <span class="keyword">when</span> &#123;</span><br><span class="line">        builder.proxy != <span class="literal">null</span> -&gt; NullProxySelector</span><br><span class="line">        <span class="keyword">else</span> -&gt; builder.proxySelector ?: ProxySelector.getDefault() ?: NullProxySelector</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="comment">// Proxy独立的验证机制</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;proxyAuthenticator&quot;</span>) <span class="keyword">val</span> proxyAuthenticator: Authenticator =</span><br><span class="line">      builder.proxyAuthenticator</span><br><span class="line">	<span class="comment">//Http的请求本质是个Socket，使用socketFactory创建</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;socketFactory&quot;</span>) <span class="keyword">val</span> socketFactory: SocketFactory = builder.socketFactory</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> sslSocketFactoryOrNull: SSLSocketFactory?</span><br><span class="line">  <span class="comment">// socket TCP连接开始之前 </span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;sslSocketFactory&quot;</span>) <span class="keyword">val</span> sslSocketFactory: SSLSocketFactory</span><br><span class="line">    <span class="keyword">get</span>() = sslSocketFactoryOrNull ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;CLEARTEXT-only client&quot;</span>)</span><br><span class="line">	<span class="comment">// 证书的验证器，（x509是证书格式标准，是系统提供的类）</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;x509TrustManager&quot;</span>) <span class="keyword">val</span> x509TrustManager: X509TrustManager?</span><br><span class="line">  <span class="comment">//连接标准，应用层支持的 Socket 设置，即使用明文传输(用于 HTTP)还是某个版本的 TLS(用于 HTTPS)。</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;connectionSpecs&quot;</span>) <span class="keyword">val</span> connectionSpecs: List&lt;ConnectionSpec&gt; =</span><br><span class="line">      builder.connectionSpecs</span><br><span class="line">	<span class="comment">//支持的应用层协议，即 HTTP/1.1、 HTTP/2 等。</span></span><br><span class="line">  <span class="comment">// SPDY_3（http2前身，已经废弃）</span></span><br><span class="line">  <span class="comment">// H2_PRIOR_KNOWLEDGE 没有TLS的HTTP2</span></span><br><span class="line">  <span class="comment">// 浏览器是无法确定是否支持HTTP2，一般会加一个Upgrade： h2c的header试着请求，询问服务器是否支持</span></span><br><span class="line">  <span class="comment">//Http2.0，但是Android客户端不需要这样试探</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;protocols&quot;</span>) <span class="keyword">val</span> protocols: List&lt;Protocol&gt; = builder.protocols</span><br><span class="line">  <span class="comment">// --------证书验证相关--------------</span></span><br><span class="line">  <span class="comment">// 验证证书的Host是否是自己请求的</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;hostnameVerifier&quot;</span>) <span class="keyword">val</span> hostnameVerifier: HostnameVerifier = builder.hostnameVerifier</span><br><span class="line">  <span class="comment">//用于设置 HTTPS 握手 过程中针对某个 Host 额外的的 Certificate Public Key Pinner，即把网站证 书链</span></span><br><span class="line">  <span class="comment">//中的每一个证书公钥直接拿来提前配置进 OkHttpClient 里去，作为正常的证书验证机制之外的一次额外验证。</span></span><br><span class="line">  <span class="comment">//最好不要使用，因为若是换了签发机构，但是客户端的信息还是写的老证书的信息，可能造成问题</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;certificatePinner&quot;</span>) <span class="keyword">val</span> certificatePinner: CertificatePinner</span><br><span class="line">	<span class="comment">// x509TrustManager的操作员，验证证书是否合法</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;certificateChainCleaner&quot;</span>) <span class="keyword">val</span> certificateChainCleaner: CertificateChainCleaner?</span><br><span class="line">  <span class="comment">// --------证书验证相关--------------</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;callTimeoutMillis&quot;</span>) <span class="keyword">val</span> callTimeoutMillis: <span class="built_in">Int</span> = builder.callTimeout</span><br><span class="line">  <span class="comment">//建立连接(TCP 或 TLS)的超时时间。</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;connectTimeoutMillis&quot;</span>) <span class="keyword">val</span> connectTimeoutMillis: <span class="built_in">Int</span> = builder.connectTimeout</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发起请求到读到响应数据的超时时间。</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;readTimeoutMillis&quot;</span>) <span class="keyword">val</span> readTimeoutMillis: <span class="built_in">Int</span> = builder.readTimeout</span><br><span class="line">  <span class="comment">//发起请求并被目标服务器接受的超时时间。(为什么?因为有时候对方服务器可能由于某种原因而不读取你的 Request)</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;writeTimeoutMillis&quot;</span>) <span class="keyword">val</span> writeTimeoutMillis: <span class="built_in">Int</span> = builder.writeTimeout</span><br><span class="line">  <span class="comment">//心跳机制</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;pingIntervalMillis&quot;</span>) <span class="keyword">val</span> pingIntervalMillis: <span class="built_in">Int</span> = builder.pingInterval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OkHttpClient 相当于配置中心，所有的请求都会共享这些配置(例如出错</p>
<p>是否重试、共享的连接池)。 OkHttpClient 中的配置主要有</p>
<p>Dns：Java 自带的方法，从域名获得ip地址</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Dns</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Throws(UnknownHostException::class)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">lookup</span><span class="params">(hostname: <span class="type">String</span>)</span></span>: List&lt;InetAddress&gt;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">val</span> SYSTEM: Dns = DnsSystem()</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DnsSystem</span> : <span class="type">Dns &#123;</span></span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">lookup</span><span class="params">(hostname: <span class="type">String</span>)</span></span>: List&lt;InetAddress&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> InetAddress.getAllByName(hostname).toList()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: NullPointerException) &#123;</span><br><span class="line">          <span class="keyword">throw</span> UnknownHostException(<span class="string">&quot;Broken system behaviour for dns lookup of <span class="variable">$hostname</span>&quot;</span>).apply &#123;</span><br><span class="line">            initCause(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getResponseWithInterceptorChain"><a href="#getResponseWithInterceptorChain" class="headerlink" title="getResponseWithInterceptorChain()"></a>getResponseWithInterceptorChain()</h3><p>RealCall</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">   <span class="comment">//第一部分 把一个个的Interceptor加入List中，网络事件拦截器（雁过插毛器）</span></span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">   interceptors += client.interceptors</span><br><span class="line">   interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">   interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">   interceptors += CacheInterceptor(client.cache)</span><br><span class="line">   interceptors += ConnectInterceptor</span><br><span class="line">   <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">     interceptors += client.networkInterceptors</span><br><span class="line">   &#125;</span><br><span class="line">   interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"><span class="comment">//第二部分： 创建一个 RealInterceptorChain实例（拦截器的链），核心仍然是Interceptor的List，不过封装</span></span><br><span class="line"> <span class="comment">//了一些功能</span></span><br><span class="line">   <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">       call = <span class="keyword">this</span>,</span><br><span class="line">       interceptors = interceptors,<span class="comment">//Interceptor组成的List</span></span><br><span class="line">       index = <span class="number">0</span>,</span><br><span class="line">       exchange = <span class="literal">null</span>,</span><br><span class="line">       request = originalRequest,</span><br><span class="line">       connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">       readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">       writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">   )</span><br><span class="line"><span class="comment">// 第三部分： 调用这个拦截器链</span></span><br><span class="line">   <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//拦截器链处理初始request</span></span><br><span class="line">     <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">     <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">       response.closeQuietly()</span><br><span class="line">       <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> response</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">     calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">       noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>链式调用模型：</p>
<p>拦截器依次调用过去，再调用回来，每个拦截器都有前置/中间/后置工作，除了最后一环。</p>
<p><img src="/2021/07/27/%E4%BB%8EOkHttp%E7%9A%84%E5%8E%9F%E7%90%86%E6%9D%A5%E7%9C%8BHTTP/image-20210812172830889.png" alt="image-20210812172830889"></p>
<h3 id="RealInterceptorChain"><a href="#RealInterceptorChain" class="headerlink" title="RealInterceptorChain:"></a>RealInterceptorChain:</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  index: <span class="type">Int</span> = this.index,</span></span></span><br><span class="line"><span class="function"><span class="params">  exchange: <span class="type">Exchange</span>? = this.exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">  request: <span class="type">Request</span> = this.request,</span></span></span><br><span class="line"><span class="function"><span class="params">  connectTimeoutMillis: <span class="type">Int</span> = this.connectTimeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">  readTimeoutMillis: <span class="type">Int</span> = this.readTimeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">  writeTimeoutMillis: <span class="type">Int</span> = this.writeTimeoutMillis</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> = RealInterceptorChain(call, interceptors, index, exchange, request, connectTimeoutMillis,</span><br><span class="line">    readTimeoutMillis, writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span> <span class="comment">//proceed 继续</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">  check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">  calls++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">    check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取第index个 interceptor</span></span><br><span class="line">  <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">  <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Suppress(<span class="meta-string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">  <span class="comment">//执行 interceptor的拦截方法 注意，interceptor是个接口，我们接下来拿默认的实例</span></span><br><span class="line">  <span class="comment">//RetryAndFollowUpInterceptor举例</span></span><br><span class="line">  <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">      <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">    check(index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RetryAndFollowUpInterceptor："><a href="#RetryAndFollowUpInterceptor：" class="headerlink" title="RetryAndFollowUpInterceptor："></a>RetryAndFollowUpInterceptor：</h3><p>它会对连接做一些初始化工作，并且负责在请求失败时的重试，以及重定向的自动后续请求。它的存在，可以让重试和重定向对于开发者是无感知的;</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重试&amp;重定向拦截器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetryAndFollowUpInterceptor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 前置工作</span></span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">var</span> request = chain.request</span><br><span class="line">    <span class="keyword">val</span> call = realChain.call</span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 始终执行请求，直到不需要重试或者重定向</span></span><br><span class="line">    <span class="comment">// 循环的一直是中间/后置工作</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 准备去找到找一个可用的连接（TCP/TLS 连接）</span></span><br><span class="line">      <span class="comment">// 并不是真正连接（连接还没发生）只是做好连接准备，所以这是一个初始化过程</span></span><br><span class="line">      <span class="comment">// 它会初始化一个address对象</span></span><br><span class="line">      <span class="comment">// 包含从url中解析的host地址和端口号，以及从okhttpclient 配置的dns等信息</span></span><br><span class="line">      <span class="comment">// 这些初始化的内容和信息会交给connectInterceptor去建立真正的TCP/TLS连接</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// newExchangeFinder 默认为true，会创建一个默认的ExchangeFinder对象 </span></span><br><span class="line">      <span class="comment">// 在connectinterceptor中会用于寻找连接</span></span><br><span class="line">      <span class="comment">// ExchangeFinder对象会让原有nextRouteToTry等信息失效，</span></span><br><span class="line">      <span class="comment">// 所以重试时newExchangeFinder = false 使用原有的ExchangeFinder建立连接</span></span><br><span class="line">      </span><br><span class="line">      call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> response: Response</span><br><span class="line">      <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 1.发起请求</span></span><br><span class="line">          <span class="comment">// 中间工作：交给下一棒</span></span><br><span class="line">          response = realChain.proceed(request)</span><br><span class="line">          <span class="comment">// 后置工作：拿到下一棒返回的response再进行</span></span><br><span class="line">          newExchangeFinder = <span class="literal">true</span></span><br><span class="line">          <span class="comment">// 2.出错时看下要不要重试</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: RouteException) &#123; </span><br><span class="line">          <span class="comment">// 通过某条连接线路连接失败了，是否可以重试如果不能，直接抛异常，可以回复调用recover方法</span></span><br><span class="line">          <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.firstConnectException</span><br><span class="line">          &#125;</span><br><span class="line">          newExchangeFinder = <span class="literal">false</span></span><br><span class="line">          <span class="comment">//继续请求</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">          <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">          <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e</span><br><span class="line">          &#125;</span><br><span class="line">          newExchangeFinder = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">          response = response.newBuilder()</span><br><span class="line">              .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                  .body(<span class="literal">null</span>)</span><br><span class="line">                  .build())</span><br><span class="line">              .build()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">        <span class="comment">// 3. 若没出错，返回301，302，304等信息，则需要进行重定向，发起重新请求</span></span><br><span class="line">        <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line">				<span class="comment">// 4. 若不需要重定向，直接返回请求结果response，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">            call.timeoutEarlyExit()</span><br><span class="line">          </span><br><span class="line">          closeActiveExchange = <span class="literal">false</span></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">        <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">          closeActiveExchange = <span class="literal">false</span></span><br><span class="line">           </span><br><span class="line">          <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//5. 若发生重定向则继续进行下一轮循环</span></span><br><span class="line">        response.body?.closeQuietly()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request = followUp</span><br><span class="line">        priorResponse = response</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到一个可用的连接</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">enterNetworkInterceptorExchange</span><span class="params">(request: <span class="type">Request</span>, newExchangeFinder: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    check(interceptorScopedExchange == <span class="literal">null</span>)</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newExchangeFinder) &#123;</span><br><span class="line">      <span class="comment">// ExchangeFinder 找到一个数据交换者，其实也就是可用的TCP连接或者SSL文件，总之就是找到一个可用的连接， 准备好连接所需参数</span></span><br><span class="line">      <span class="keyword">this</span>.exchangeFinder = ExchangeFinder(</span><br><span class="line">          connectionPool,</span><br><span class="line">          createAddress(request.url),</span><br><span class="line">          <span class="keyword">this</span>,</span><br><span class="line">          eventListener</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// recover 恢复连接方法，在请求出错时触发</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    e: <span class="type">IOException</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    call: <span class="type">RealCall</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    userRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    requestSendStarted: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// okhttp client配置是否需要重试</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 判断是否可以恢复连接</span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isRecoverable</span><span class="params">(e: <span class="type">IOException</span>, requestSendStarted: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否可以恢复连接</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> ProtocolException) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> InterruptedIOException) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重定向判断</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">followUpRequest</span><span class="params">(userResponse: <span class="type">Response</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Request? &#123;</span><br><span class="line">    <span class="keyword">val</span> route = exchange?.connection?.route()</span><br><span class="line">    <span class="keyword">val</span> responseCode = userResponse.code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> method = userResponse.request.method</span><br><span class="line">    <span class="keyword">when</span> (responseCode) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">      HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;     </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpURLConnection</span> <span class="title">extends</span> <span class="title">URLConnection</span> </span>&#123;  	</span><br><span class="line">   	<span class="comment">//重定向</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> int HTTP_MULT_CHOICE = <span class="number">300</span>;	</span><br><span class="line">		<span class="comment">//永久移动</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> int HTTP_MOVED_PERM = <span class="number">301</span>;</span><br><span class="line">		<span class="comment">//暂时移动</span></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> int HTTP_MOVED_TEMP = <span class="number">302</span>;</span><br><span class="line">&#125;			</span><br></pre></td></tr></table></figure>
<h4 id="RealCall-enterNetworkInterceptorExchange"><a href="#RealCall-enterNetworkInterceptorExchange" class="headerlink" title="RealCall.enterNetworkInterceptorExchange"></a>RealCall.enterNetworkInterceptorExchange</h4><p>retryfllowupInterceptor 用于初始化创建TCP/TLS连接的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">enterNetworkInterceptorExchange</span><span class="params">(request: <span class="type">Request</span>, newExchangeFinder: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">  check(interceptorScopedExchange == <span class="literal">null</span>)</span><br><span class="line">  check(exchange == <span class="literal">null</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 若发生重连/重定向， newExchangeFinder 会传入false，仍就使用原有的exchangeFinder对象  </span></span><br><span class="line">  <span class="keyword">if</span> (newExchangeFinder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.exchangeFinder = ExchangeFinder(</span><br><span class="line">        connectionPool,</span><br><span class="line">     </span><br><span class="line">        createAddress(request.url),</span><br><span class="line">        <span class="keyword">this</span>,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Adress对象， 包含从url分析的host 地址，port端口号，okhttp client 配置好的信息</span></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createAddress</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: Address &#123;</span><br><span class="line">    <span class="keyword">var</span> sslSocketFactory: SSLSocketFactory? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> hostnameVerifier: HostnameVerifier? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> certificatePinner: CertificatePinner? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (url.isHttps) &#123;</span><br><span class="line">      sslSocketFactory = client.sslSocketFactory</span><br><span class="line">      hostnameVerifier = client.hostnameVerifier</span><br><span class="line">      certificatePinner = client.certificatePinner</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Address(</span><br><span class="line">        uriHost = url.host,</span><br><span class="line">        uriPort = url.port,</span><br><span class="line">        dns = client.dns,</span><br><span class="line">        socketFactory = client.socketFactory,</span><br><span class="line">        sslSocketFactory = sslSocketFactory,</span><br><span class="line">        ...</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><p>桥接Interceptor，你所准备好的和即将要发布的请求做一个连接</p>
<p>负责一些不影响开发者开发，但影响 HTTP 交互的一些额外预处理。例如，<code>Content-Length</code> 的计算和添加、<code>gzip</code> 的支持<code> (Accept-Encoding: gzip)</code>、<code>gzip</code> 压缩数据的解包，都是发生在这里;</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> cookieJar: CookieJar) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//添加加各种header，若发生重定向/重连，header内容已经被赋值过，已经有是否为空的判断，不会重复赋值</span></span><br><span class="line">      <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 内容数据类型</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="comment">// body长度</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不定长度类型</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// gzip的支持</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="literal">true</span></span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line">		<span class="comment">//拿到response响应后解析gzip压缩的内容</span></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">        <span class="string">&quot;gzip&quot;</span>.equals(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">      <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">      <span class="comment">// 拿到响应后解析各种header</span></span><br><span class="line">    	<span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>负责 Cache 的处理。把它放在后面的网络交互相关<code>Interceptor</code>的前面的好处是，如果本地有了可用的 Cache，一个 请求可以在没有发生实质网络交互的情况下就返回缓存结果，而完全不需要 开发者做出任何的额外工作，让 Cache 更加无感知;</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span></span>(<span class="keyword">internal</span> <span class="keyword">val</span> cache: Cache?) : Interceptor &#123; </span><br><span class="line">	<span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CacheStrategy缓存相关逻辑都在这里，内容相对独立</span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前置工作：查看是否有缓存，如果有可用的缓存直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中置工作， 交棒进行实质上的网络请求</span></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置工作，请求完成判断响应的网络数据的是不是可以缓存</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">     	<span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>最难理解的拦截器</p>
<p>Okhttp使用ConnectInterceptor责建立连接：</p>
<p>HTTP请求会创建出网络请求所需要的 TCP 连接，</p>
<p>HTTPS请求回创建建立在 TCP 连接之上 的 TLS 连接(如果是 )</p>
<p>根据连接创建出对应的 <code>HttpCodec </code>对象 (用于编码解码 HTTP 请求，不同的协议 http1/2不同的读取规则)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ConnectInterceptor : Interceptor &#123;</span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 前置工作： 创建连接</span></span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="comment">// 所以核心就是前置工作的initExchange，它是Realcall的一个方法</span></span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">     <span class="comment">// 中置工作：交棒</span></span><br><span class="line">    <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">    <span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br><span class="line">    <span class="comment">// 后置工作：实际连接交给连接池处理，所以没有</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RealCall-initExchange"><a href="#RealCall-initExchange" class="headerlink" title="RealCall.initExchange()"></a>RealCall.initExchange()</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个Exchange，也就是RetryAndFollowUpInterceptor中FindExchange寻找却没找到的TCP/TLS连接</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">initExchange</span><span class="params">(chain: <span class="type">RealInterceptorChain</span>)</span></span>: Exchange &#123;</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    check(!noMoreExchanges) &#123; <span class="string">&quot;released&quot;</span> &#125;</span><br><span class="line">    check(exchange == <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// codec 即 coder &amp; decoder 编码解码器</span></span><br><span class="line">  <span class="comment">// 按照http1/http2需要按照不同的格式来读，需要根据不同的协议返回不同的codec</span></span><br><span class="line">  <span class="comment">// 除了编码器，还包含一个可用的连接</span></span><br><span class="line">  <span class="comment">// 接下来只要用codec读/写就可以向网络读/写</span></span><br><span class="line">  <span class="keyword">val</span> codec = exchangeFinder!!.find(client, chain)</span><br><span class="line">  <span class="comment">// 将codec封装进Exchange ，Exchange将使用codec读写数据</span></span><br><span class="line">  <span class="comment">// 本地与网络一来一回的数据读/写交互即为Exchange（交互）</span></span><br><span class="line">  <span class="keyword">val</span> result = Exchange(<span class="keyword">this</span>, eventListener, exchangeFinder!!, codec)</span><br><span class="line">  <span class="keyword">this</span>.interceptorScopedExchange = result</span><br><span class="line"></span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    <span class="keyword">this</span>.exchange = result</span><br><span class="line">    <span class="keyword">this</span>.exchangeRequestDone = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.exchangeResponseDone = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ExchangeFinder-（核心）"><a href="#ExchangeFinder-（核心）" class="headerlink" title="ExchangeFinder （核心）"></a>ExchangeFinder （核心）</h4><p>创建TCP/TLS连接的步骤</p>
<ol>
<li>call对象中的connection连接不为空（发生过重定向/重连可能会这样），校验连接是否可以在新的请求复用（host地址，端口，代理信息是否一致），校验通过接复用</li>
<li>从连接池获取符合http1连接复用条件的连接进行复用</li>
<li>从连接池中获取满足http2多路复用或者http1复用条件的连接</li>
<li>创建新连接后，从连接池获取只满足http2多路复用条件的连接，若验证可以复用到新请求则直接复用</li>
<li>使用新创建的连接</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExchangeFinder</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> connectionPool: RealConnectionPool,</span><br><span class="line">  ...</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">var</span> routeSelection: RouteSelector.Selection? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    chain: <span class="type">RealInterceptorChain</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: ExchangeCodec &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 找到一个可用的连接</span></span><br><span class="line">      <span class="keyword">val</span> resultConnection = findHealthyConnection(</span><br><span class="line">          connectTimeout = chain.connectTimeoutMillis,</span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">      )</span><br><span class="line">     <span class="comment">//  健康的连接(可用且没有关闭)</span></span><br><span class="line">      <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        <span class="comment">// 连接可用且健康才执行下一步 </span></span><br><span class="line">        candidate.noNewExchanges()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据连接创建出编码解码器（HttpCodec）确定编码规则http1 or http2？</span></span><br><span class="line">      <span class="keyword">return</span> resultConnection.newCodec(client, chain)</span><br><span class="line">    &#125; ...</span><br><span class="line">  <span class="comment">// 查找健康（可用）连接的方法  </span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findHealthyConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   ...</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: RealConnection &#123;</span><br><span class="line">    <span class="comment">// 循环寻找可用连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 先找到一个可用连接</span></span><br><span class="line">      <span class="keyword">val</span> candidate = findConnection(</span><br><span class="line">          connectTimeout = connectTimeout,</span><br><span class="line">          ...</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 查看是否健康</span></span><br><span class="line">      <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        candidate.noNewExchanges()</span><br><span class="line">        <span class="comment">// 不可用继续找</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">//可用返回连接</span></span><br><span class="line">      <span class="keyword">return</span> candidate</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查找连接（无论会否可用）</span></span><br><span class="line">   <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: RealConnection &#123;</span><br><span class="line">    <span class="keyword">var</span> foundPooledConnection = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> result: RealConnection? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> selectedRoute: Route? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> releasedConnection: RealConnection?</span><br><span class="line">    <span class="comment">// 待关闭的连接</span></span><br><span class="line">    <span class="keyword">val</span> toClose: Socket?</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      <span class="comment">// 若取消，则抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">     </span><br><span class="line">			<span class="comment">// 第五种情况，若发生重定向/重新连接，call的connection对象不再为空可以复用连接</span></span><br><span class="line">      <span class="keyword">val</span> callConnection = call.connection <span class="comment">// changes within this overall method</span></span><br><span class="line">      releasedConnection = callConnection</span><br><span class="line">      <span class="comment">// 如果要进行一次新的请求，而call对象中包含的连接不能复用，则需要close它</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// toClose 待关闭连接，判断条件：</span></span><br><span class="line">      <span class="comment">// callConnection != null 连接创建成功，又再次请求，call内部的connection 不为null</span></span><br><span class="line">      <span class="comment">// callConnection.noNewExchanges 不再接受新的连接</span></span><br><span class="line">      <span class="comment">// callConnection.route().address.url))： 原有连接不适合新的url（端口或者url或host是否一致）</span></span><br><span class="line">      toClose = <span class="keyword">if</span> (callConnection != <span class="literal">null</span> &amp;&amp; (callConnection.noNewExchanges ||</span><br><span class="line">              !sameHostAndPort(callConnection.route().address.url))) &#123;</span><br><span class="line">        <span class="comment">// 将call的connection连接置空 释放连接</span></span><br><span class="line">        <span class="comment">//toClose通过 eleaseConnectionNoEvents()拿到一个socket对象（ return released.socket()）</span></span><br><span class="line">        call.releaseConnectionNoEvents()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若经过call的connection对象是否可以复用的判断依然没有置为空，说明连接可以复用</span></span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// call的connection对象可以复用，其他创建连接的方式可以忽略，逻辑会直接return result</span></span><br><span class="line">        result = call.connection</span><br><span class="line">        releasedConnection = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//1. 第一次从连接池取连接 </span></span><br><span class="line">      <span class="comment">// reslut初始值为空，所以第一次一定走这里</span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// The connection hasn&#x27;t had any problems for this call.</span></span><br><span class="line">        refusedStreamCount = <span class="number">0</span></span><br><span class="line">        connectionShutdownCount = <span class="number">0</span></span><br><span class="line">        otherFailureCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次尝试拿连接 直接从连接池拿连接</span></span><br><span class="line">        <span class="comment">// callAcquirePooledConnection </span></span><br><span class="line">        <span class="comment">// route 参数为空 无法满足http2的连接合并判断条件，只能使用http1的连接复用条件判断</span></span><br><span class="line">        <span class="comment">// 所以第一次只拿不能满足http2多路复用的连接</span></span><br><span class="line">        <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">          foundPooledConnection = <span class="literal">true</span></span><br><span class="line">          result = call.connection</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">          selectedRoute = nextRouteToTry</span><br><span class="line">          nextRouteToTry = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭待关闭的连接（toClose是一个socket实际调用的是Socket.closeQuietly()）</span></span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">   	<span class="comment">// 发通知，连接已释放</span></span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果成功从连接池拿到连接，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we found an already-allocated or pooled connection, we&#x27;re done.</span></span><br><span class="line">      <span class="keyword">return</span> result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次从连接池拿连接： 若第一次没有成功从连接池拿到连接，</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newRouteSelection = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// Route 路由对象，包含proxy代理信息，ip地址，Adress对象（包含port端口号)</span></span><br><span class="line">    <span class="comment">// routeSelection: 类型是一个Selection，内部是 List&lt;Route&gt;包含多个Route</span></span><br><span class="line">    <span class="comment">// 同一个 Selection 代理模式和端口都是一样的，只有ip地址不一样（端口可以通过uri推断，proxy可配置）</span></span><br><span class="line">    <span class="comment">// RouteSelector：包含多个routeSelection</span></span><br><span class="line">    <span class="comment">// RouteSelector &gt; Selection(routeSelection) 按代理/端口分组 &gt; Route</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="literal">null</span> &amp;&amp; (routeSelection == <span class="literal">null</span> || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">      <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">      <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">        localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">        <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">      &#125;</span><br><span class="line">      newRouteSelection = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 默认返回值是直连，无代理，routeSelection包含多个route（ip地址不同）</span></span><br><span class="line">      <span class="comment">// 实际上我们会遍历RouteSelector中存储的Selection，Selection又会遍历存储的routes</span></span><br><span class="line">      routeSelection = localRouteSelector.next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> routes: List&lt;Route&gt;? = <span class="literal">null</span></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">        <span class="comment">// 从当前route分组routeSelection拿到route信息 </span></span><br><span class="line">        routes = routeSelection!!.routes</span><br><span class="line">        <span class="comment">//第二次：从连接池再次去取连接</span></span><br><span class="line">        <span class="comment">// routes不再是空，所以这次调用可以满足http2的连接合并的判断条件，有机会拿到符合连接合并条件的连接</span></span><br><span class="line">        <span class="comment">// 第三个参数 requireMultiplexed = false 代表不只取满足http2多路复用连接条件的连接</span></span><br><span class="line">        <span class="comment">// 这次取连接拿到满足http1条件和满足http2多路复用条件的连接的可能性都存在</span></span><br><span class="line">        <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">          foundPooledConnection = <span class="literal">true</span></span><br><span class="line">          result = call.connection</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">// 第三次拿连接，若第二次还拿不到，自己新建连接</span></span><br><span class="line">      <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 从route分组拿到route</span></span><br><span class="line">          selectedRoute = routeSelection!!.next()</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//新建连接</span></span><br><span class="line">        result = RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">        connectingConnection = result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次若从线程池拿到连接，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">      <span class="keyword">return</span> result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三次连接：用自己新建的连接,进行网络连接（阻塞TCP/TLS握手）</span></span><br><span class="line">    result!!.connect(</span><br><span class="line">       ...</span><br><span class="line">    )</span><br><span class="line">    call.client.routeDatabase.connected(result!!.route())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> socket: Socket? = <span class="literal">null</span></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      connectingConnection = <span class="literal">null</span></span><br><span class="line">      <span class="comment">// 第四次连接：创建新连接后再次尝试从连接池里拿可以支持http2多路复用的连接</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 因为极端情况下，连接池为空时，同时有两个甚至多个可以复用连接http2请求发生</span></span><br><span class="line">      <span class="comment">// 第一次只取http1配置条件的连接，所以肯定无法取到</span></span><br><span class="line">      <span class="comment">// 第二次取时连接池为空，也无法取到</span></span><br><span class="line">      <span class="comment">// 所以第三次创建连接后也要再次尝试从连接池取连接</span></span><br><span class="line">      <span class="comment">// 这样若是此时其他请求刚好创建好支持http2多路复用的连接并放入连接池，直接复用能节约资源</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 最后一个参数 true 表示需要多路复用（是否只拿多路复用的连接 </span></span><br><span class="line">      <span class="comment">//  http1使用完的连接可以复用， http2使用中的连接可以复用也就是多路复用）</span></span><br><span class="line">      <span class="comment">// 第三个参数 requireMultiplexed =true 表示只取支持http2多路复用的连接</span></span><br><span class="line">      <span class="comment">// 前两次取连接这个参数为false</span></span><br><span class="line">      <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="comment">//不再接受新连接</span></span><br><span class="line">        result!!.noNewExchanges = <span class="literal">true</span></span><br><span class="line">        socket = result!!.socket()</span><br><span class="line">        <span class="comment">// 若连接池中有可以复用的连接，则赋值给result返回</span></span><br><span class="line">        result = call.connectionh.</span><br><span class="line">        <span class="comment">// 虽然新建的连接被丢弃了，但是这种复用方式是不稳定的，其他请求可能创建连接后又马上丢弃连接</span></span><br><span class="line">        <span class="comment">// 若发生这种情况，我们仍需要重新创建连接，既然我们的连接新建成功了，那么它的selectedRoute信息是</span></span><br><span class="line">        <span class="comment">// 可信任的，我们把它存储到临时变量  nextRouteToTry中，下次创建连接信息的时候可以优先使用这个信息</span></span><br><span class="line">        nextRouteToTry = selectedRoute</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第三次自自己创建连接后，塞入连接池，和其他请求共享</span></span><br><span class="line">        connectionPool.put(result!!)</span><br><span class="line">        call.acquireConnectionNoEvents(result!!)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    <span class="keyword">return</span> result!!      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="RealConnectionPool-callAcquirePooledConnection"><a href="#RealConnectionPool-callAcquirePooledConnection" class="headerlink" title="RealConnectionPool.callAcquirePooledConnection"></a>RealConnectionPool.callAcquirePooledConnection</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealConnectionPool</span></span>(</span><br><span class="line">  <span class="comment">//帮call拿已经在连接池里的连接</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callAcquirePooledConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 对象包含： host ip地址，port端口，okhttp client 配置好的相关信息（代理模式）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  address: <span class="type">Address</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  call: <span class="type">RealCall</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  routes: <span class="type">List</span>&lt;<span class="type">Route</span>&gt;?,</span></span></span><br><span class="line"><span class="function"><span class="params">  requireMultiplexed: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.assertThreadHoldsLock()</span><br><span class="line">	<span class="comment">//遍历池中所有连接，看能不能用</span></span><br><span class="line">  <span class="keyword">for</span> (connection <span class="keyword">in</span> connections) &#123;</span><br><span class="line">    <span class="comment">// requireMultiplex参数：true/false 只取http2可以多路复用的连接</span></span><br><span class="line">    <span class="comment">// 第一、二次请求requireMultiplex的值是false所以不会执行，这个参数为true，</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// isMultiplexed 是指HTTP2中的多路复用</span></span><br><span class="line">    <span class="comment">// isMultiplexed: Boolean get() = http2Connection != null 池中http2连接不为null时=true</span></span><br><span class="line">    <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed) <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">// isEligible 判断连接是否可用（连接数没有超标，连接方式相同）</span></span><br><span class="line">    <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">continue</span></span><br><span class="line">     <span class="comment">// 连接可用则重用连接</span></span><br><span class="line">    <span class="comment">// 连接可用执行  call.acquireConnectionNoEvents (拿到连接并且不发出任何事件),</span></span><br><span class="line">    <span class="comment">// 即： 若判断连接剋用 isEligible返回true 则执行 acquireConnectionNoEvents 拿到连接</span></span><br><span class="line">  </span><br><span class="line">    call.acquireConnectionNoEvents(connection)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sameHostAndPort</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="comment">// 端口或者url或host是否一致，</span></span><br><span class="line">  <span class="keyword">val</span> routeUrl = address.url</span><br><span class="line">  <span class="keyword">return</span> url.port == routeUrl.port &amp;&amp; url.host == routeUrl.host</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="RealCall-acquireConnectionNoEvents"><a href="#RealCall-acquireConnectionNoEvents" class="headerlink" title="RealCall. acquireConnectionNoEvents"></a>RealCall. acquireConnectionNoEvents</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acquireConnectionNoEvents</span><span class="params">(connection: <span class="type">RealConnection</span>)</span></span> &#123;...</span><br><span class="line">  <span class="comment">// 将连接直接复制给realcall</span></span><br><span class="line">  <span class="keyword">this</span>.connection = connection ...</span><br></pre></td></tr></table></figure>
<h4 id="RealConnection-isEligible"><a href="#RealConnection-isEligible" class="headerlink" title="RealConnection.isEligible"></a>RealConnection.isEligible</h4><p>判断连接是否可用：</p>
<ol>
<li>连接数没有超标：http1:连接的请求数只能为1，http2不超过限定的值</li>
<li>连接采用同样的配置方式，端口号，tls版本，代理，ip地址（不相同也要满足http2的要求，证书相同）都相同</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span></span>( <span class="keyword">val</span> connectionPool: RealConnectionPool,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> route: Route</span><br><span class="line">) : Http2Connection.Listener(), Connection &#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 判断连接是否可用</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEligible</span><span class="params">(address: <span class="type">Address</span>, routes: <span class="type">List</span>&lt;<span class="type">Route</span>&gt;?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="comment">// calls.size连接承受的请求数量没有超过限制（http2之前，每个连接只能承受一个请求）</span></span><br><span class="line">  <span class="comment">// noNewExchanges = true 表示愿意接受新请求</span></span><br><span class="line">  <span class="comment">// 算上本次请求不能超过限制，而且愿意接受新的请求</span></span><br><span class="line"> <span class="keyword">if</span> (calls.size &gt;= allocationLimit || noNewExchanges) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 端口：http 80， https 443</span></span><br><span class="line">  <span class="comment">// 所谓建立连接应该是戳到了对方主机到某个端口，具体应该是主机ip地址到某个TCP端口</span></span><br><span class="line">  <span class="comment">// 所以ip地址和tcp端口都要对才能用一个连接发两个请求</span></span><br><span class="line">  <span class="comment">// 除此之外，TLS版本，代理配置也也需要保持一致</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 验证当前连接的配置是否和需要连接的主机配置是否一致</span></span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">this</span>.route.address.equalsNonHost(address)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		</span><br><span class="line">  <span class="comment">// 验证主机地址是否一致</span></span><br><span class="line"> <span class="keyword">if</span> (address.url.host == <span class="keyword">this</span>.route().address.url.host) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// This connection is a perfect match.</span></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// http2 特殊的连接合并规则 connection coalescing</span></span><br><span class="line">  <span class="comment">// 若两个连接地址的ip地址一样，那么说明他们所在的主机一样，那么连接可以重用</span></span><br><span class="line">  <span class="comment">// 但是由于虚拟主机的存在，同一个ip地址下不同的网址可能指向的是不同的主机</span></span><br><span class="line">  <span class="comment">// 所以在https的协议下，我们可以通过验证证书是否一致来决定连接是否可以重用</span></span><br><span class="line">  <span class="comment">// 若ip地址和https下发的服务器证书一致，http2可以将这个连接重用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若非http2协议，以下的规则不适用</span></span><br><span class="line">    <span class="keyword">if</span> (http2Connection == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ip 以及代理信息一致， routes不能为空（ip，代理信息都存在routes中）</span></span><br><span class="line">    <span class="keyword">if</span> (routes == <span class="literal">null</span> || !routeMatchesAny(routes)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// hostnameVerifie （证书）是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (address.hostnameVerifier !== OkHostnameVerifier) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// supportsUrl(address.url) </span></span><br><span class="line">    <span class="comment">// 端口是否一致</span></span><br><span class="line">    <span class="comment">// 验证当前重用的连接的证书是否可以用在新请求的网站</span></span><br><span class="line">    <span class="keyword">if</span> (!supportsUrl(address.url)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Certificate pinning 是否一致</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      address.certificatePinner!!.check(address.url.host, handshake()!!.peerCertificates)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_: SSLPeerUnverifiedException) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 全部符合http2 的连接合并要求，则可以重用此连接 </span></span><br><span class="line">  </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Address-equalsNonHost"><a href="#Address-equalsNonHost" class="headerlink" title="Address.equalsNonHost"></a>Address.equalsNonHost</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证连接的配置是否相同，包括端口，代理等各项配置</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">equalsNonHost</span><span class="params">(that: <span class="type">Address</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dns == that.dns &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.proxyAuthenticator == that.proxyAuthenticator &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.protocols == that.protocols &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.connectionSpecs == that.connectionSpecs &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.proxySelector == that.proxySelector &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.proxy == that.proxy &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.sslSocketFactory == that.sslSocketFactory &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.hostnameVerifier == that.hostnameVerifier &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.certificatePinner == that.certificatePinner &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.url.port == that.url.port</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="RealConnection-supportsUrl"><a href="#RealConnection-supportsUrl" class="headerlink" title="RealConnection.supportsUrl"></a>RealConnection.supportsUrl</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">supportsUrl</span><span class="params">(url: <span class="type">HttpUrl</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> routeUrl = route.address.url</span><br><span class="line"><span class="comment">// 验证端口号</span></span><br><span class="line">  <span class="keyword">if</span> (url.port != routeUrl.port) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// Port mismatch.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (url.host == routeUrl.host) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// Host match. The URL is supported.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 验证当前重用的连接的证书是否可以用在新请求的网站</span></span><br><span class="line">  <span class="keyword">return</span> !noCoalescedConnections &amp;&amp; handshake != <span class="literal">null</span> &amp;&amp; certificateSupportHost(url, handshake!!)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">certificateSupportHost</span><span class="params">(url: <span class="type">HttpUrl</span>, handshake: <span class="type">Handshake</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> peerCertificates = handshake.peerCertificates</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> peerCertificates.isNotEmpty() &amp;&amp; OkHostnameVerifier.verify(url.host,</span><br><span class="line">      peerCertificates[<span class="number">0</span>] <span class="keyword">as</span> X509Certificate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h4><p>包含ip地址/端口号，都是从url解析得到的，来自RetryAndFollowUPInterceptor配置</p>
<p>其他相关配置都是直接从HttpClient的配置中读取的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>(</span><br><span class="line">  uriHost: String, <span class="comment">// host 地址</span></span><br><span class="line">  uriPort: <span class="built_in">Int</span>, <span class="comment">//端口</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;dns&quot;</span>) <span class="keyword">val</span> dns: Dns,<span class="comment">//OkhttpClient 配置的信息</span></span><br><span class="line">  ....</span><br></pre></td></tr></table></figure>
<h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><p>路由，包含 Address对象，代理和ip地址</p>
<p>Adress对象包含host地址/端口号</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span></span>(</span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;address&quot;</span>) <span class="keyword">val</span> address: Address,</span><br><span class="line">  <span class="comment">// 代理</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;proxy&quot;</span>) <span class="keyword">val</span> proxy: Proxy,</span><br><span class="line">  <span class="comment">// ip地址</span></span><br><span class="line">  <span class="meta">@get:JvmName</span>(<span class="string">&quot;socketAddress&quot;</span>) <span class="keyword">val</span> socketAddress: InetSocketAddress</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="RealCall-releaseConnectionNoEvents"><a href="#RealCall-releaseConnectionNoEvents" class="headerlink" title="RealCall.releaseConnectionNoEvents()"></a>RealCall.releaseConnectionNoEvents()</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">releaseConnectionNoEvents</span><span class="params">()</span></span>: Socket? &#123;</span><br><span class="line">  connectionPool.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> index = connection!!.calls.indexOfFirst &#123; it.<span class="keyword">get</span>() == <span class="keyword">this</span><span class="symbol">@RealCall</span> &#125;</span><br><span class="line">  check(index != -<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 连接置空</span></span><br><span class="line">  <span class="keyword">val</span> released = <span class="keyword">this</span>.connection</span><br><span class="line">  released!!.calls.removeAt(index)</span><br><span class="line">  <span class="keyword">this</span>.connection = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (released.calls.isEmpty()) &#123;</span><br><span class="line">    released.idleAtNs = System.nanoTime()</span><br><span class="line">    <span class="keyword">if</span> (connectionPool.connectionBecameIdle(released)) &#123;</span><br><span class="line">      <span class="comment">// 释放连接，返回一个socket</span></span><br><span class="line">      <span class="keyword">return</span> released.socket()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RealConnection-核心"><a href="#RealConnection-核心" class="headerlink" title="RealConnection(核心)"></a>RealConnection(核心)</h4><p>建立一个新连接的过程</p>
<p>以sslSocketFactory 是否为空判断连接是否需要加密</p>
<p>先判断是否需要HTTP Tunnel</p>
<ol>
<li>请求类型是是http，且内容需要加密，要按HTTP Tunnel规范向服务器发一段专有信息并建立socket通道，这样就能用http代理https请求</li>
<li>若请求只是普通的http请求,则直接建立TCP连接（socket）</li>
</ol>
<p>再建立实际的连接（http1/http2/https）</p>
<ul>
<li><p>不需要加密 sslSocketFactory = null</p>
<ol>
<li>http2请求需要先发送一个preface</li>
<li>http1请求直接返回即可</li>
</ol>
</li>
<li><p>需要加密 </p>
<ol>
<li><p>http2请求先发送preface</p>
</li>
<li><p>http1请求直接创建TLS连接</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rawSocket是TCP连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> rawSocket: Socket? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// socket就是具体写数据的对象：https： socket是TLS连接，http： socket是TCP连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> socket: Socket? = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ...</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> (route.address.sslSocketFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ConnectionSpec.CLEARTEXT !<span class="keyword">in</span> connectionSpecs) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">            <span class="string">&quot;CLEARTEXT communication not enabled for client&quot;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">     ...</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Tunnel 专有名词：例如建立一个http连接，但访问的资源却是https的，就需要服务器帮替你转接</span></span><br><span class="line">    <span class="comment">// HTTP Tunnel是一种很标准的用http代理https的方式 是http协议本身支持的</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// requiresTunnel：有sslSocketFactory并且代理是http时返回true</span></span><br><span class="line">      <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">        <span class="comment">// 若是http请求https资源，则需要创建 Http Tunnel</span></span><br><span class="line">        connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">        <span class="keyword">if</span> (rawSocket == <span class="literal">null</span>) &#123;  </span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是http代理请求https资源，则直接创建普通的 tcp socket</span></span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 建立实际的https或http2的连接</span></span><br><span class="line">      establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建Tunnel</span></span><br><span class="line">	<span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectTunnel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tunnelRequest: Request = createTunnelRequest()</span><br><span class="line">    <span class="keyword">val</span> url = tunnelRequest.url</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until MAX_TUNNEL_ATTEMPTS) &#123;</span><br><span class="line">      <span class="comment">// 建立一个TCP连接（Socket），因为我们要用它发送http请求，然后用它创建一个TLS连接发送https请求</span></span><br><span class="line">      connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">      <span class="comment">// 建好之后我们基于这个socket再搭建一个通道(HTTP Tunnel，它是一种很标准的用http代理https的方式)</span></span><br><span class="line">      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url)</span><br><span class="line">          ?: <span class="keyword">break</span> <span class="comment">// Tunnel successfully created.</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">      rawSocket?.closeQuietly()</span><br><span class="line">      rawSocket = <span class="literal">null</span></span><br><span class="line">      sink = <span class="literal">null</span></span><br><span class="line">      source = <span class="literal">null</span></span><br><span class="line">      eventListener.connectEnd(call, route.socketAddress, route.proxy, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基于socket创建一个HTTP Tunnel，它是一种很标准的用http代理https的方式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createTunnel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">    tunnelRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    url: <span class="type">HttpUrl</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: Request? &#123;</span><br><span class="line">    <span class="keyword">var</span> nextRequest = tunnelRequest</span><br><span class="line">    <span class="comment">// 向服务器发送一段Http请求，来建立标准的http tunnel</span></span><br><span class="line">    <span class="keyword">val</span> requestLine = <span class="string">&quot;CONNECT <span class="subst">$&#123;url.toHostHeader(includeDefaultPort = true)&#125;</span> HTTP/1.1&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> source = <span class="keyword">this</span>.source!!</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">when</span> (response.code) &#123;</span><br><span class="line">        HTTP_OK -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建TCP Socket      </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectSocket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> &#123;</span><br><span class="line">    <span class="comment">// 代理</span></span><br><span class="line">    <span class="keyword">val</span> proxy = route.proxy</span><br><span class="line">    <span class="comment">// Address对象 包含uriHost，uriPort，以及OkHttp Client配置的DNS信息等内容</span></span><br><span class="line">    <span class="keyword">val</span> address = route.address</span><br><span class="line">    <span class="comment">// rawSocket就是TCP连接</span></span><br><span class="line">    <span class="keyword">val</span> rawSocket = <span class="keyword">when</span> (proxy.type()) &#123;</span><br><span class="line">      <span class="comment">// 将TCP 连接建立出来</span></span><br><span class="line">      Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">      <span class="keyword">else</span> -&gt; Socket(proxy)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值给RealConnection中的rawSocket，就是实际TCP连接的端口</span></span><br><span class="line">    <span class="keyword">this</span>.rawSocket = rawSocket</span><br><span class="line"></span><br><span class="line">    ..</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 创建实际的http/http2/https连接，完成连接协议</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">establishProtocol</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    connectionSpecSelector: <span class="type">ConnectionSpecSelector</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    call: <span class="type">Call</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    eventListener: <span class="type">EventListener</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> &#123;</span><br><span class="line">    <span class="comment">// sslSocketFactory == null 表示不需要加密</span></span><br><span class="line">    <span class="comment">// 分两种情况</span></span><br><span class="line">    <span class="comment">// 1.http2连接需要先发送一个preface</span></span><br><span class="line">    <span class="comment">// 2.http1连接直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (route.address.sslSocketFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Protocol.H2_PRIOR_KNOWLEDGE若很确定服务器是http2的那么可以直接明文连接</span></span><br><span class="line">     </span><br><span class="line">      <span class="keyword">if</span> (Protocol.H2_PRIOR_KNOWLEDGE <span class="keyword">in</span> route.address.protocols) &#123;</span><br><span class="line">        socket = rawSocket</span><br><span class="line">        protocol = Protocol.H2_PRIOR_KNOWLEDGE</span><br><span class="line">        <span class="comment">//1. 建立http2 连接（也就是先发一个preface给服务器作为http2的招手）</span></span><br><span class="line">        startHttp2(pingIntervalMillis)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">// 2. 如果是http1 则直接返回</span></span><br><span class="line">      socket = rawSocket</span><br><span class="line">      protocol = Protocol.HTTP_1_1</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventListener.secureConnectStart(call)</span><br><span class="line">    <span class="comment">// 3. 建立加密连接TLS（http1的加密连接）</span></span><br><span class="line">    connectTls(connectionSpecSelector)</span><br><span class="line">    eventListener.secureConnectEnd(call, handshake)</span><br><span class="line">    <span class="comment">// 4. 若是基于http2的加密连接，需要先发送preface握手</span></span><br><span class="line">    <span class="keyword">if</span> (protocol === Protocol.HTTP_2) &#123;</span><br><span class="line">      startHttp2(pingIntervalMillis)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startHttp2</span><span class="params">(pingIntervalMillis: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 建立http2连接</span></span><br><span class="line">    http2Connection.start()</span><br><span class="line">  &#125; </span><br><span class="line"> <span class="comment">// 建立加密连接TLS</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectTls</span><span class="params">(connectionSpecSelector: <span class="type">ConnectionSpecSelector</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> address = route.address</span><br><span class="line">    <span class="keyword">val</span> sslSocketFactory = address.sslSocketFactory</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> sslSocket: SSLSocket? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建TCP Socket 建立TCP连接</span></span><br><span class="line">      sslSocket = sslSocketFactory!!.createSocket(</span><br><span class="line">          rawSocket, address.url.host, address.url.port, <span class="literal">true</span> <span class="comment">/* autoClose */</span>) <span class="keyword">as</span> SSLSocket</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Configure the socket&#x27;s ciphers, TLS versions, and extensions.</span></span><br><span class="line">      <span class="keyword">val</span> connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket)</span><br><span class="line">      <span class="keyword">if</span> (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">        Platform.<span class="keyword">get</span>().configureTlsExtensions(sslSocket, address.url.host, address.protocols)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始TlS handshake</span></span><br><span class="line">      sslSocket.startHandshake()</span><br><span class="line">      <span class="comment">// block for session establishment</span></span><br><span class="line">      <span class="keyword">val</span> sslSocketSession = sslSocket.session</span><br><span class="line">      <span class="keyword">val</span> unverifiedHandshake = sslSocketSession.handshake()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 验证证书的Host Name 是否正确</span></span><br><span class="line">      <span class="keyword">if</span> (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) &#123;</span><br><span class="line">        <span class="keyword">val</span> peerCertificates = unverifiedHandshake.peerCertificates</span><br><span class="line">        <span class="keyword">if</span> (peerCertificates.isNotEmpty()) &#123;</span><br><span class="line">          <span class="keyword">val</span> cert = peerCertificates[<span class="number">0</span>] <span class="keyword">as</span> X509Certificate</span><br><span class="line">          <span class="keyword">throw</span> SSLPeerUnverifiedException(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              |Hostname <span class="subst">$&#123;address.url.host&#125;</span> not verified:</span></span><br><span class="line"><span class="string">              |    certificate: <span class="subst">$&#123;CertificatePinner.pin(cert)&#125;</span></span></span><br><span class="line"><span class="string">              |    DN: <span class="subst">$&#123;cert.subjectDN.name&#125;</span></span></span><br><span class="line"><span class="string">              |    subjectAltNames: <span class="subst">$&#123;OkHostnameVerifier.allSubjectAltNames(cert)&#125;</span></span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>.trimMargin())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> SSLPeerUnverifiedException(</span><br><span class="line">              <span class="string">&quot;Hostname <span class="subst">$&#123;address.url.host&#125;</span> not verified (no certificates)&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> certificatePinner = address.certificatePinner!!</span><br><span class="line"></span><br><span class="line">      handshake = Handshake(unverifiedHandshake.tlsVersion, unverifiedHandshake.cipherSuite,</span><br><span class="line">          unverifiedHandshake.localCertificates) &#123;</span><br><span class="line">        <span class="comment">// 验证证书合法性</span></span><br><span class="line">        certificatePinner.certificateChainCleaner!!.clean(unverifiedHandshake.peerCertificates,</span><br><span class="line">            address.url.host)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查pinner 是否符合要求</span></span><br><span class="line">      certificatePinner.check(address.url.host) &#123;</span><br><span class="line">        handshake!!.peerCertificates.map &#123; it <span class="keyword">as</span> X509Certificate &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Success! Save the handshake and the ALPN protocol.</span></span><br><span class="line">      <span class="keyword">val</span> maybeProtocol = <span class="keyword">if</span> (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">        Platform.<span class="keyword">get</span>().getSelectedProtocol(sslSocket)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// socket赋值成 ssl Socket ，TLS连接</span></span><br><span class="line">      socket = sslSocket</span><br><span class="line">      source = sslSocket.source().buffer()</span><br><span class="line">      sink = sslSocket.sink().buffer()</span><br><span class="line">      protocol = <span class="keyword">if</span> (maybeProtocol != <span class="literal">null</span>) Protocol.<span class="keyword">get</span>(maybeProtocol) <span class="keyword">else</span> Protocol.HTTP_1_1</span><br><span class="line">      success = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sslSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">        Platform.<span class="keyword">get</span>().afterHandshake(sslSocket)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        sslSocket?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;        </span><br></pre></td></tr></table></figure>
<h4 id="Route-requiresTunnel"><a href="#Route-requiresTunnel" class="headerlink" title="Route.requiresTunnel()"></a>Route.requiresTunnel()</h4><p>查看是否可以创建tunnel</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有sslSocketFactory并且代理是http</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">requiresTunnel</span><span class="params">()</span></span> = address.sslSocketFactory != <span class="literal">null</span> &amp;&amp; proxy.type() == Proxy.Type.HTTP</span><br></pre></td></tr></table></figure>
<h4 id="Http2Connection"><a href="#Http2Connection" class="headerlink" title="Http2Connection"></a>Http2Connection</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span> <span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">(sendConnectionPreface: <span class="type">Boolean</span> = <span class="literal">true</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (sendConnectionPreface) &#123;</span><br><span class="line">    <span class="comment">// 建立http2连接之前先发送preface，就是一段消息，类似于握手，相当于建立一个连接</span></span><br><span class="line">    <span class="comment">// 无论是否加密都要发送这段preface消息</span></span><br><span class="line">    writer.connectionPreface()</span><br><span class="line">    writer.settings(okHttpSettings)</span><br><span class="line">    <span class="keyword">val</span> windowSize = okHttpSettings.initialWindowSize</span><br><span class="line">    <span class="keyword">if</span> (windowSize != DEFAULT_INITIAL_WINDOW_SIZE) &#123;</span><br><span class="line">      writer.windowUpdate(<span class="number">0</span>, (windowSize - DEFAULT_INITIAL_WINDOW_SIZE).toLong())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Thread(readerRunnable, connectionName).start() <span class="comment">// Not a daemon thread.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Synchronized</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">isHealthy</span><span class="params">(nowNs: <span class="type">Long</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证心跳是否正常 A degraded pong is overdue.</span></span><br><span class="line">    <span class="keyword">if</span> (degradedPongsReceived &lt; degradedPingsSent &amp;&amp; nowNs &gt;= degradedPongDeadlineNs) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Http2Writer</span></span>(</span><br><span class="line">  ...</span><br><span class="line">) : Closeable &#123;</span><br><span class="line"> </span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Synchronized</span> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">connectionPreface</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> IOException(<span class="string">&quot;closed&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (!client) <span class="keyword">return</span> <span class="comment">// Nothing to write; servers don&#x27;t send connection headers!</span></span><br><span class="line">    <span class="keyword">if</span> (logger.isLoggable(FINE)) &#123;</span><br><span class="line">      <span class="comment">// http2 发送的preface消息，是所有的http2连接都要发送的，无论是否加密</span></span><br><span class="line">      <span class="comment">// 服务器拿到这段消息就知道客户端发送的是http2的消息</span></span><br><span class="line">      logger.fine(format(<span class="string">&quot;&gt;&gt; CONNECTION <span class="subst">$&#123;CONNECTION_PREFACE.hex()&#125;</span>&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    sink.write(CONNECTION_PREFACE)</span><br><span class="line">    sink.flush()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="RealConnection-isHealthy"><a href="#RealConnection-isHealthy" class="headerlink" title="RealConnection.isHealthy()"></a>RealConnection.isHealthy()</h4><p>检查链接是否健康</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isHealthy</span><span class="params">(doExtensiveChecks: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// socket 是否关闭</span></span><br><span class="line">  <span class="keyword">if</span> (socket.isClosed || socket.isInputShutdown || socket.isOutputShutdown) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// http2 连接是否健康</span></span><br><span class="line">  <span class="keyword">val</span> http2Connection = <span class="keyword">this</span>.http2Connection</span><br><span class="line">  <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> http2Connection.isHealthy(nowNs)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RealConnection-newCodec"><a href="#RealConnection-newCodec" class="headerlink" title="RealConnection.newCodec()"></a>RealConnection.newCodec()</h4><p>根据协议创建对应的编码解码器</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(SocketException::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCodec</span><span class="params">(client: <span class="type">OkHttpClient</span>, chain: <span class="type">RealInterceptorChain</span>)</span></span>: ExchangeCodec &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">val</span> http2Connection = <span class="keyword">this</span>.http2Connection</span><br><span class="line">	<span class="comment">// 根据http1/http2连接创建对应的编码解码器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">    Http2ExchangeCodec(client, <span class="keyword">this</span>, chain, http2Connection)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    Http1ExchangeCodec(client, <span class="keyword">this</span>, source, sink)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http1ExchangeCodec"><a href="#Http1ExchangeCodec" class="headerlink" title="Http1ExchangeCodec"></a>Http1ExchangeCodec</h4><p>编码解码器</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeRequestHeaders</span><span class="params">(request: <span class="type">Request</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> requestLine = RequestLine.<span class="keyword">get</span>(request, connection.route().proxy.type())</span><br><span class="line">   writeRequest(request.headers, requestLine)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 把请求写进数据里面（向网络传出），http1是明文传输</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeRequest</span><span class="params">(headers: <span class="type">Headers</span>, requestLine: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">   check(state == STATE_IDLE) &#123; <span class="string">&quot;state: <span class="variable">$state</span>&quot;</span> &#125;</span><br><span class="line">  <span class="comment">// writeUtf8(requestLine) 输入请求行</span></span><br><span class="line">  <span class="comment">// writeUtf8(&quot;\r\n&quot;) 输入回车换行</span></span><br><span class="line">   sink.writeUtf8(requestLine).writeUtf8(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">  <span class="comment">// 输入每一个header</span></span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until headers.size) &#123;</span><br><span class="line">     sink.writeUtf8(headers.name(i)) <span class="comment">// 输入header 名</span></span><br><span class="line">         .writeUtf8(<span class="string">&quot;: &quot;</span>) <span class="comment">// 输入：号</span></span><br><span class="line">         .writeUtf8(headers.value(i))<span class="comment">// 输入header 值</span></span><br><span class="line">         .writeUtf8(<span class="string">&quot;\r\n&quot;</span>)<span class="comment">// 回车换行</span></span><br><span class="line">   &#125;</span><br><span class="line">   sink.writeUtf8(<span class="string">&quot;\r\n&quot;</span>)<span class="comment">// 回车换行</span></span><br><span class="line">   state = STATE_OPEN_REQUEST_BODY</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Http2ExchangeCodec"><a href="#Http2ExchangeCodec" class="headerlink" title="Http2ExchangeCodec"></a>Http2ExchangeCodec</h4><p>格式与http1不同，需要不同的编码解码器</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeRequestHeaders</span><span class="params">(request: <span class="type">Request</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (stream != <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// http2需要stream 方式写/读数据</span></span><br><span class="line">  <span class="comment">// http2 报文格式更复杂，多用，灵活</span></span><br><span class="line">  <span class="comment">// http1是一个请求过去一个响应回来，</span></span><br><span class="line">  <span class="comment">// http2会封装多个stream，每个stream可以有多个请求/响应（多个发过去多个返回来）</span></span><br><span class="line">  <span class="comment">// 这一串流程就是stream，一个请求可以得到多个响应 </span></span><br><span class="line">  <span class="comment">// 响应不是一次性返回的，是通过服务器推送消息分次 推送过来的</span></span><br><span class="line">  <span class="comment">// 但是本质上和http1一样，都是要发请求和响应报文</span></span><br><span class="line">  stream = http2Connection.newStream(requestHeaders, hasRequestBody)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4><p>codec 包装类,与网络交互，读写数据。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exchange</span></span>(</span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> codec: ExchangeCodec</span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">writeRequestHeaders</span><span class="params">(request: <span class="type">Request</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      eventListener.requestHeadersStart(call)</span><br><span class="line">      codec.writeRequestHeaders(request)</span><br><span class="line">      eventListener.requestHeadersEnd(call, request)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">createRequestBody</span><span class="params">(request: <span class="type">Request</span>, duplex: <span class="type">Boolean</span>)</span></span>: Sink &#123;</span><br><span class="line">    <span class="keyword">this</span>.isDuplex = duplex</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>它负责实质的请求与响应的 I/O 操作，即 往 Socket 里写入请求数据，和从 Socket 里读取响应数据。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span>) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用Exchange实例读写数据</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equals(request.header(<span class="string">&quot;Expect&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">     ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">          <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          ...</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">var</span> code = response.code</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// Server sent a 100-continue even though we did not request one. Try again to read the actual</span></span><br><span class="line">      <span class="comment">// response status.</span></span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">      <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response = responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">          <span class="string">&quot;HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><code>OkHttpClient </code>相当于配置中心，所有的请求都会共享这些配置(例如出错是否重试、共享的连接池)。 </p>
</li>
<li><p><code>newCall(Request) </code>方法会返回一个 RealCall 对象，它是 Call 接口的它是 Call 接口的实现。当调用 <code>RealCall.execute()</code> 的时候，<code>RealCall.getResponseWithInterceptorChain()</code>会被调用，它会发起网络请求并拿到返回的响应，装进一个<code>Response</code>对象并作为返回值返 回; </p>
<p><code>RealCall.enqueue() </code>被调用的时候大同小异，区别在于<code>enqueue()</code> 会使用<code>Dispatcher</code>的线程池来把请求放在后台线程进行，但实质上使用的同样也是 <code>getResponseWithInterceptorChain() </code>方法。</p>
</li>
<li><p><code>getResponseWithInterceptorChain()</code> 方法做的事:把所有配置好的 <code>Interceptor </code>放在一个 List 里，然后作为参数，创建一个<code>RealInterceptorChain</code>对象，并调用<code>chain.proceed(request)</code>来发起请求和获取响应。</p>
</li>
<li><p>在 <code>RealInterceptorChain</code> 中，多个<code> Interceptor</code> 会依次调用自己的<code>intercept()</code> 方法。这个方法会做三件事:</p>
<ol>
<li>对请求进行预处理</li>
<li>预处理之后，重新调用 <code>RealIntercepterChain.proceed() </code>把请求交给下一个 <code>Interceptor</code></li>
<li>在下一个 <code>Interceptor </code>处理完成并返回之后，拿到 Response 进行后续处理</li>
</ol>
</li>
</ul>
<blockquote>
<p>当然了，最后一个 Interceptor 的任务只有一个:做真正的网络请求并 拿到响应</p>
</blockquote>
<ul>
<li>从上到下，每级 Interceptor 做的事:<ul>
<li>首先是开发者使用<code>addInterceptor(Interceptor)</code>所设置的，它们会按照开发者的要求，在所有其他 <code>Interceptor</code> 处理之前，进行最早的 预处理工作，以及在收到 Response 之后，做最后的善后工作。如果你有统 一的 header 要添加，可以在这里设置;</li>
<li>然后是<code> RetryAndFollowUpInterceptor</code> :它会对连接做一些初始化工作，并且负责在请求失败时的重试，以及重定向的自动后续请求。它的存在，可以让重试和重定向对于开发者是无感知的;</li>
<li><code>BridgeInterceptor</code> :它负责一些不影响开发者开发，但影响 HTTP 交互的一些额外预处理。例如，<code>Content-Length</code> 的计算和添加、<code>gzip</code> 的支持<code> (Accept-Encoding: gzip)</code>、<code>gzip</code> 压缩数据的解包，都是发生在这里;</li>
<li><code>CacheInterceptor </code>:它负责 Cache 的处理。把它放在后面的网络交互相关<code>Interceptor</code>的前面的好处是，如果本地有了可用的 Cache，一个 请求可以在没有发生实质网络交互的情况下就返回缓存结果，而完全不需要 开发者做出任何的额外工作，让 Cache 更加无感知;</li>
<li><code>ConnectInterceptor</code> :它负责建立连接。在这里，OkHttp 会创建出网络请求所需要的 TCP 连接(如果是 HTTP)，或者是建立在 TCP 连接之上 的 TLS 连接(如果是 HTTPS)，并且会创建出对应的 <code>HttpCodec </code>对象 (用于编码解码 HTTP 请求)它被封装到Exchange类中;</li>
<li>然后是开发者使用 <code>addNetworkInterceptor(Interceptor)</code> 所设置的，它们的行为逻辑和使用 <code>addInterceptor(Interceptor)</code> 创建的 一样，但由于位置不同，所以这里创建的<code>Interceptor</code>会看到每个请求和响应的数据(包括重定向以及重试的一些中间请求和响应)，并且看到的 是完整原始数据，而不是没有加<code> Content-Length</code> 的请求数据，或者<code> Body</code> 还没有被 gzip 解压的响应数据。多数情况，这个方法不需要被使用，不过如果你要做网络调试，可以用它;</li>
<li><code>CallServerInterceptor</code> :它负责实质的请求与响应的 I/O 操作(使用ConnectInteceptor构建的Exchange对象)，即 往 Socket 里写入请求数据，和从 Socket 里读取响应数据。</li>
</ul>
</li>
</ul>
<h3 id="结合HTTP协议理解"><a href="#结合HTTP协议理解" class="headerlink" title="结合HTTP协议理解"></a>结合HTTP协议理解</h3><h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><p>它所谓的初始化可选连接的任务主要是初始化一些对象给ConnectInterceptor去建立真正的TCP/TLS连接<br>它会初始化</p>
<ul>
<li>一个address对象，包含从url中解析的host，port，以及从okhttpclient 配置的dns等信息</li>
<li>bool值newExchangeFinde，决定是否让ExchangeFinder对象失效（会让原有nextRouteToTry等信息失效）    </li>
</ul>
<h4 id="ConnectInterceptor核心类1-ExchangeFinder"><a href="#ConnectInterceptor核心类1-ExchangeFinder" class="headerlink" title="ConnectInterceptor核心类1. ExchangeFinder"></a>ConnectInterceptor核心类1. ExchangeFinder</h4><p>建立连接的核心类</p>
<p>创建TCP/TLS连接的步骤</p>
<ol>
<li>call对象中的connection连接不为空（发生过重定向/重连可能会这样），校验连接是否可以在新的请求复用（host地址，端口，代理信息是否一致），校验通过接复用</li>
<li>从连接池获取符合http1连接复用条件的连接进行复用</li>
<li>从连接池中获取满足http2多路复用或者http1复用条件的连接</li>
<li>创建新连接后，从连接池获取只满足http2多路复用条件的连接，若验证可以复用到新请求则直接复用</li>
<li>使用新创建的连接</li>
</ol>
<h4 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h4><h5 id="selectedRoute"><a href="#selectedRoute" class="headerlink" title="selectedRoute"></a>selectedRoute</h5><ul>
<li><p>Route 路由对象，包含proxy代理信息，ip地址，Adress对象（包含port端口号)</p>
</li>
<li><p>routeSelection: 类型是一个Selection，内部是 List<Route>包含多个Route</Route></p>
<p>同一个 Selection 代理模式和端口都是一样的，只有ip地址不一样（端口可以通过uri推断，proxy可配置）</p>
</li>
<li><p>RouteSelector：包含多个routeSelection</p>
</li>
</ul>
<p>RouteSelector &gt; Selection(routeSelection) 按代理/端口分组 &gt; Route</p>
<h5 id="nextRouteToTry"><a href="#nextRouteToTry" class="headerlink" title="nextRouteToTry"></a>nextRouteToTry</h5><p>4中的新建连接可能会丢弃，但是这种复用方式是不稳定的，其他请求可能创建连接后又马上丢弃连接<br>若发生这种情况，我们仍需要重新创建连接，既然我们的连接新建成功了，那么它的selectedRouter信息是<br>可信任的，我们把它存储到临时变量  nextRouteToTry中，下次创建连接信息的时候可以优先使用这个信息</p>
<h5 id="ConnectInterceptor核心类2-RealConnection-核心"><a href="#ConnectInterceptor核心类2-RealConnection-核心" class="headerlink" title="ConnectInterceptor核心类2 RealConnection(核心)"></a>ConnectInterceptor核心类2 RealConnection(核心)</h5><p>建立一个新连接的过程</p>
<p>以sslSocketFactory 是否为空判断连接是否需要加密</p>
<p>先判断是否需要HTTP Tunnel</p>
<ol>
<li>请求类型是是http，且内容需要加密，要按HTTP Tunnel规范向服务器发一段专有信息并建立socket通道，这样就能用http代理https请求</li>
<li>若请求只是普通的http请求,则直接建立TCP连接（socket）</li>
</ol>
<p>再建立实际的连接（http1/http2/https）</p>
<ul>
<li><p>不需要加密 sslSocketFactory = null</p>
<ol>
<li>http2请求需要先发送一个preface</li>
<li>http1请求直接返回即可</li>
</ol>
</li>
<li><p>需要加密 </p>
<ol>
<li>http2请求先发送preface</li>
</ol>
</li>
</ul>
<ol start="2">
<li>http1请求直接创建TLS连接</li>
</ol>
<h5 id="HttpCodec"><a href="#HttpCodec" class="headerlink" title="HttpCodec"></a>HttpCodec</h5><p>因为http1和http2的差异导致需要不同的编码解码器</p>
<p>虽然本质上都是要发请求和响应报文但是，http2需要stream 方式写/读数据，</p>
<p>因为http2报文格式更复杂，多用，灵活，所以产生了差异</p>
<ul>
<li><p>http1直接一个明文报文请求过去一个响应回来，</p>
</li>
<li><p>http2会封装多个stream，每个stream可以有多个请求/响应（响应可以通过服务器消息分次推送过来）</p>
</li>
</ul>
<p>根据连接协议不同生成的codec编码解码器最终会封装成Exchange对象，通过内部的codec进行真正的数据交互。</p>
<p>​     </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="oldnineping"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">oldnineping</p>
  <div class="site-description" itemprop="description">技术日记和杂七杂八的dx</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oldnineping</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
