<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="进程和线程(介绍) 操作系统中运行多个软件。  一个运行中的软件可能包含多个进程。   一个运行中的进程可能包含多个线程。   操作系统开辟一段内存&#x2F;资源给进程。   进程和线程的异同 进程之间的内存不共享，线程程可以共享资源，都可以并行工作。 他们本质上不是一个东西，像是家庭和家庭成员的关系,进程相当于一个运行的程序，线程是一个程序里的并行线路之一。  CPU 线程和操作系统线程 CPU 线程：">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程和线程同步">
<meta property="og:url" content="http://example.com/2021/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/index.html">
<meta property="og:site_name" content="地球上的小东西">
<meta property="og:description" content="进程和线程(介绍) 操作系统中运行多个软件。  一个运行中的软件可能包含多个进程。   一个运行中的进程可能包含多个线程。   操作系统开辟一段内存&#x2F;资源给进程。   进程和线程的异同 进程之间的内存不共享，线程程可以共享资源，都可以并行工作。 他们本质上不是一个东西，像是家庭和家庭成员的关系,进程相当于一个运行的程序，线程是一个程序里的并行线路之一。  CPU 线程和操作系统线程 CPU 线程：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211010210933018.png">
<meta property="og:image" content="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211010213543039.png">
<meta property="og:image" content="http://example.com/2021/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/image-20210309190312852.png">
<meta property="og:image" content="http://example.com/2021/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/image-20210309190426850.png">
<meta property="article:published_time" content="2021-03-09T05:52:30.000Z">
<meta property="article:modified_time" content="2021-10-10T13:39:44.668Z">
<meta property="article:author" content="oldnineping">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211010210933018.png">

<link rel="canonical" href="http://example.com/2021/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>多线程和线程同步 | 地球上的小东西</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">地球上的小东西</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hiahiahiahia</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="oldnineping">
      <meta itemprop="description" content="技术日记和杂七杂八的dx">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地球上的小东西">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          多线程和线程同步
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-09 13:52:30" itemprop="dateCreated datePublished" datetime="2021-03-09T13:52:30+08:00">2021-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-10 21:39:44" itemprop="dateModified" datetime="2021-10-10T21:39:44+08:00">2021-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="进程和线程-介绍"><a href="#进程和线程-介绍" class="headerlink" title="进程和线程(介绍)"></a>进程和线程(介绍)</h1><ul>
<li><p>操作系统中运行多个软件。</p>
</li>
<li><p>一个运行中的软件可能包含多个进程。</p>
</li>
<li><p> 一个运行中的进程可能包含多个线程。</p>
</li>
<li><p> 操作系统开辟一段内存/资源给进程。</p>
</li>
</ul>
<h2 id="进程和线程的异同"><a href="#进程和线程的异同" class="headerlink" title="进程和线程的异同"></a>进程和线程的异同</h2><ul>
<li>进程之间的内存不共享，线程程可以共享资源，都可以并行工作。</li>
<li>他们本质上不是一个东西，像是家庭和家庭成员的关系,进程相当于一个运行的程序，线程是一个程序里的并行线路之一。</li>
</ul>
<h2 id="CPU-线程和操作系统线程"><a href="#CPU-线程和操作系统线程" class="headerlink" title="CPU 线程和操作系统线程"></a>CPU 线程和操作系统线程</h2><ol>
<li><p>CPU 线程：</p>
<p>多核 CPU 的每个核各自独立运行，因此每个核一个线程 「四核八线程」:CPU 硬件方在硬件级别对 CPU 进行了一核多线程的 支持(本质上依然是每个核一个线程)</p>
</li>
<li><p>操作系统线程:</p>
<p>操作系统利用时间分片的方式，把 CPU 的运行拆分给多条 运行逻辑，即为操作系统的线程，开发中接触的是操作系统线程。</p>
</li>
</ol>
<p>单核 CPU 也可以运行多线程操作系统 </p>
<h2 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么:"></a>线程是什么:</h2><p>按代码顺序执行下来，执行完毕就结束的一条线</p>
<h2 id="UI-线程为什么不会结束"><a href="#UI-线程为什么不会结束" class="headerlink" title="UI 线程为什么不会结束?"></a>UI 线程为什么不会结束?</h2><p>因为它在初始化完毕后会执行死循环，循环的内 容是刷新界面。</p>
<p>为什么一直循环却不会卡，就是因为在循环所以程序才没有结束，一次循环就是一次生命周期。</p>
<p>如果在ui线程中写了死循环，那么ui的下一次刷新就永远无法到来，就卡住了。</p>
<a id="more"></a>

<h1 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h1><h2 id="Java中开启线程的方法"><a href="#Java中开启线程的方法" class="headerlink" title="Java中开启线程的方法"></a>Java中开启线程的方法</h2><ol>
<li>new Thread: 可复写Thread#run方法。也可传递Runnable对象，更加灵活。<ul>
<li>缺点:缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom</li>
</ul>
</li>
<li>ThreadFactory 是个接口类需要实现newThread()，其实还是使用new Thread()开启</li>
<li>ThreadPoolExecutor:适用快速处理大量耗时较短的任务场景</li>
</ol>
<h2 id="Thread-和-Runnable"><a href="#Thread-和-Runnable" class="headerlink" title="Thread 和 Runnable"></a>Thread 和 Runnable</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Thread started&quot;</span>);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       thread.start(); <span class="comment">//后台启动</span></span><br><span class="line">       thread.run();<span class="comment">//直接运行，不会在后台启动</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Android 中 Thread 的start 方法调用的是nativeCreate（）方法，java中是调用start0方法，因为Java代码是不能开启虚拟机的，也没有切换线程的能力，只能交给Jvm让通过natvive平台实现</li>
<li>run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，<br>还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</li>
<li>总结：<ul>
<li>Jvm虚拟机开启了新线程之后又调用了Java 的run方法。</li>
<li>其实Thread也是实现了Runnable接口的，回调函数也是run方法</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Java 中的 registerNatives 本地方法，该方法主要的作用就是注册一些本地方法供 Thread 类使用，如 start0()，stop0() 等等，可以说，所有操作本地线程的本地方法都是由它注册的。</li>
<li>这个方法放在一个 static 语句块中，当该类被加载到 JVM 中的时候，它就会被调用，进而注册相应的本地方法。(查看本地方法的源码需要前往 <a target="_blank" rel="noopener" href="http://jdk.java.net/java-se-ri/8">http://jdk.java.net/java-se-ri/8</a> 下载openjdk的源代码)</li>
<li>而本地方法 registerNatives 是定义在 Thread.c 文件中的。Thread.c 是个很小的文件，它定义了各个操作系统平台都要用到的关于线程的公用数据和操作，</li>
<li> Java 线程调用 start-&gt;start0 的方法，实际上会调用到 JVM_StartThread 方法，     </li>
</ul>
</blockquote>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread with runnable started:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">        thread.run();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br></pre></td></tr></table></figure>
<p>Thread和Runnable调用run方法最终都会调用<code>runnable.run</code></p>
<p>所以用runnable的方法可以复用runnable且便于管理。</p>
<h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>它只是一个接口类，只是用来new Thread 而已.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory factory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">// int</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;Thread-&quot;</span> + count.incrementAndGet()); <span class="comment">// ++count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread = factory.newThread(runnable);</span><br><span class="line">thread.start();</span><br><span class="line">Thread thread1 = factory.newThread(runnable);</span><br><span class="line">thread1.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><h3 id="为什么引入线程池"><a href="#为什么引入线程池" class="headerlink" title="为什么引入线程池"></a>为什么引入线程池</h3><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="如何构建线程池"><a href="#如何构建线程池" class="headerlink" title="如何构建线程池"></a>如何构建线程池</h3><p>无论是使用Executors 还是直接创建线程池都会实例化ThreadPoolExecutor()来创建线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,       </span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">corePoolSize</td>
<td align="center">线程池中<strong>核心</strong>线程数量(默认线程数，刚创建的时候有多少线程，一直存在不会被销毁)</td>
</tr>
<tr>
<td align="center">maximumPoolSize</td>
<td align="center"><strong>最大</strong>能创建的线程数量（MAX_VALUE是无限，因为创建和销毁都要消耗资源，所以要限定）</td>
</tr>
<tr>
<td align="center">keepAliveTime</td>
<td align="center"><strong>非核心</strong>线程最大存活时间（非核心线程执行完任务多久要销毁）</td>
</tr>
<tr>
<td align="center">unit</td>
<td align="center">keepAliveTime的时间单位</td>
</tr>
<tr>
<td align="center">workQueue</td>
<td align="center">等待队列。当任务提交时，如果线程池中<strong>正在运行的的线程</strong>数量<strong>大于等于corePoolSize（核心线程数量）的时候，把该任务放入等待队列</strong>（这个队列满了之后才会创建非核心线程）</td>
</tr>
<tr>
<td align="center">threadFactory</td>
<td align="center"><strong>线程创建工程厂</strong>。默认使用Executors.defaultThreadFactory() 来创建线程，线程具有相同的NORM_PRIORITY优先级并且是非守护线程</td>
</tr>
<tr>
<td align="center"><strong>handler</strong></td>
<td align="center"><strong>线程池的饱和拒绝策略</strong>。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务（默认策略是抛出异常）。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void executor() &#123;</span><br><span class="line">    Runnable runnable &#x3D;new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Thread with Runnable started&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">		&#x2F;&#x2F;线程池</span><br><span class="line">    Executor executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">    executor.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JUC包下Executors提供的几种线程池"><a href="#JUC包下Executors提供的几种线程池" class="headerlink" title="JUC包下Executors提供的几种线程池"></a>JUC包下Executors提供的几种线程池</h3><ul>
<li><p>Executor可以创建4种线程池(缓存，单线程，固定线程数，可定时的线程池)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单一线程数,同时只有一个线程存活,但线程等待队列无界</span></span><br><span class="line"> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//线程可复用线程池,核心线程数为0，最大可创建的线程数为Interger.max,线程复用存活时间是60s.  </span></span><br><span class="line"> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//固定线程数量的线程池</span></span><br><span class="line"> Executors.newFixedThreadPool(<span class="keyword">int</span> corePoolSize);</span><br><span class="line"><span class="comment">//可执行定时任务,延迟任务的线程池</span></span><br><span class="line"> Executors.newScheduledThreadPool(<span class="keyword">int</span> corePoolSize);</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建好线程池后会返回一个 ExecutorService，用于管理线程池，ExecutorService包含两个主要方法：</p>
<ul>
<li>shutdown会保守的结束线程，等待当前执行中的线程结束后再停止线程，但允许再排队。</li>
<li>shutdownNow直接结束线程，使用的是interrupt。</li>
</ul>
</li>
</ul>
<h4 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h4><p>Executors 创建线程池的方法会返回ExecutorService，里面有几个个重要方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable run)</span><span class="comment">//提交任务,交由线程池调度</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span><span class="comment">//关闭线程池,等待任务执行完成</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdownNow</span><span class="params">()</span><span class="comment">//关闭线程池，不等待任务执行完成</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">getTaskCount</span><span class="params">()</span><span class="comment">//返回线程池找中所有任务的数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">getCompletedTaskCount</span><span class="params">()</span><span class="comment">//返回线程池中已执行完成的任务数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">getPoolSize</span><span class="params">()</span><span class="comment">//返回线程池中已创建线程数量 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">getActiveCount</span><span class="params">()</span><span class="comment">//返回当前正在运行的线程数量</span></span></span><br></pre></td></tr></table></figure>
<h4 id="newCachedThreadPool-新建缓存线程池"><a href="#newCachedThreadPool-新建缓存线程池" class="headerlink" title="newCachedThreadPool 新建缓存线程池"></a>newCachedThreadPool 新建缓存线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="newSingleThreadExecutor创建一个单线程"><a href="#newSingleThreadExecutor创建一个单线程" class="headerlink" title="newSingleThreadExecutor创建一个单线程"></a>newSingleThreadExecutor创建一个单线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(index);</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br></pre></td></tr></table></figure>
<p>创建一个单线程，一般用于取消线程的时候使用，不然在一个线程回收所有标记取消的线程太慢了。</p>
<h4 id="newFixedThreadPool-固定线程数的线程池"><a href="#newFixedThreadPool-固定线程数的线程池" class="headerlink" title="newFixedThreadPool  固定线程数的线程池"></a>newFixedThreadPool  固定线程数的线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(index);</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>固定线程数的线程池，不能增加也不能减少，空闲时候会一致占着不会回收，需要增加时也不能扩展。</p>
<p>适用于集中处理多个瞬时爆发的任务。</p>
<h4 id="newScheduledThreadPool-延迟任务"><a href="#newScheduledThreadPool-延迟任务" class="headerlink" title="newScheduledThreadPool:延迟任务"></a>newScheduledThreadPool:延迟任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delay 1 seconds, and excute every 3 seconds&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">Executors.newSingleThreadScheduledExecutor(factory);</span><br></pre></td></tr></table></figure>
<p>我们可以建造一个全局通用的线程池 </p>
<p> 可以用于RxJava</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService myExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">myExecutor.execute(runnable);</span><br></pre></td></tr></table></figure>
<h3 id="线程池状态流转"><a href="#线程池状态流转" class="headerlink" title="线程池状态流转"></a>线程池状态流转</h3><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211010210933018.png" alt="image-20211010210933018" style="zoom:50%;">



<h3 id="execute-提交任务流程"><a href="#execute-提交任务流程" class="headerlink" title="execute 提交任务流程"></a>execute 提交任务流程</h3><p><img src="https://gitee.com/laonaiping/blog-images/raw/master/img/image-20211010213543039.png" alt="image-20211010213543039"></p>
<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>很少用到，可以认为是个有返回值的runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; callables = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(callables);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String result = future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;result: &quot;</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>executorService.submit一个callable对象。</p>
<p>future.get()是阻塞式的api，可以等一会再取。这就是JavaApi能做到的极限了，这仍然是阻塞式的。</p>
<p>我们可以通过 future.isDone()来查询cllable是否完成。通过轮询来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; callables = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Done&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(callables);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String result = future.get();</span><br><span class="line">                    System.out.println(<span class="string">&quot;result: &quot;</span> + result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程同步和线程安全"><a href="#线程同步和线程安全" class="headerlink" title="线程同步和线程安全"></a>线程同步和线程安全</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="synchronized-关键字（锁）"><a href="#synchronized-关键字（锁）" class="headerlink" title="synchronized 关键字（锁）"></a>synchronized 关键字（锁）</h3><ul>
<li><p>synchronized</p>
<ul>
<li><p>synchronized方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">	x = newValue;</span><br><span class="line">	y = newValue; </span><br><span class="line">	<span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x: &quot;</span> + x + <span class="string">&quot;, y:&quot;</span> +y);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure></li>
<li><p>synchronized 代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个写法等价于在，方法前加 sychronized，因为是用这个类本身来监视代码块 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">		x = newValue; y = newValue; <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x: &quot;</span> + x + <span class="string">&quot;, y:&quot;</span>+ y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">synchronized (monitor1) &#123; </span><br><span class="line">		synchronized (monitor2) &#123;</span><br><span class="line">        name &#x3D; x + &quot;-&quot; + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>synchronized 的本质</p>
<ul>
<li><p>保证方法内部或代码块内部资源(数据)的互斥访问。即同一时间、由 同一个 Monitor 监视的代码，最多只能有一个线程在访问</p>
<img src="/2021/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/image-20210309190312852.png" alt="image-20210309190312852" style="zoom:50%;">
</li>
<li><p>保证线程之间对监视资源的<strong>数据同步</strong>。即，任何线程在获取到 Monitor 后的第一时间，会先将共享内存中的数据复制到自己的缓存中;任何线程在释放 Monitor 的第一时间，会先将缓存中的数据复制到共享内存中。</p>
  <img src="/2021/03/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/image-20210309190426850.png" alt="image-20210309190426850" style="zoom:50%;">

</li>
</ul>
</li>
</ul>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1:"></a>例子1:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Synchronized2Demo</span> <span class="keyword">implements</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) &#123;</span><br><span class="line">                    count();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;final x from 1: &quot;</span> + x);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) &#123;</span><br><span class="line">                    count();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;final x from 2: &quot;</span> + x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个线程都执行1百万次 count，理论上x++会执行2百万次，结果应该是2000000，实际输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final x from 1: 1963117</span><br><span class="line">final x from 2: 2000000</span><br></pre></td></tr></table></figure>
<p>因为两个线程一定不是同时结束运行的，后加完的结果应该就是2000000，执行完的结果应该小于2000000，但是如果不加关键字，执行结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final x from 1: 1466918</span><br><span class="line">final x from 2: 1670223</span><br></pre></td></tr></table></figure>
<p>两个线程的输出结果都没有到2000000，因为两个线程对x进行内存拷贝时可能存在互相覆盖的情况，会导致最后的结果不到200w</p>
<p>如果此时给int 值x 加一个volatile参数，而不是sychronize关键字，输出的结果仍然不会到200w，因为i++在Java中不是一步操作（原子操作），而是分两步完成（int temp= x+1 ,x=temp），这导致volatile关键字无法同步数值（可能在给临时变量temp赋值的时候切换线程，导致计数错误 ）。</p>
<p>所以想保持线程安全，不光要保证数值的同步，还要把那些会互相影响的操作合成为一个操作（原子操作）。</p>
<p>此时我们给执行x++操作的count方法加一个sychronized 关键字，它能让方法里的内容保持同步性，**<del>可以理解为当一个线程执行这个count方法时，其他线程就不能调用了，里面的变量值也能保证同步性</del>**注意这个理解是不全面的。</p>
<h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Synchronized3Demo</span> <span class="keyword">implements</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        x = newValue;</span><br><span class="line">        y = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">private</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        x -= delta;</span><br><span class="line">        y -= delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，我们想保护的是数据而不是方法，Java中会通过一个监视者Monitor来监视方法是不是被其他线程调用，当我们为两个方法加上synchronized关键字的时候，会使用同一个Monitor，当线程1调用count方法的时候，线程2级不能调用count方法也不能调用setName方法，非常影响效率。</p>
<p>这个设计的意义是，minus方法没有加synchronized关键字，仍然可以被其他线程改变x，y的值，为了让 x,y的数据不被其他线程修改，我们对会影响数据x，y的 两个方法使用synchronized，公用一个Monitor，让其它线程无法调用。</p>
<p>对于setName方法，它不会影响到x和y我们希望它能有一个独立的Monitor，synchronized代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		x = newValue; y = newValue; <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x: &quot;</span> + x + <span class="string">&quot;, y:&quot;</span>+ y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 this 的含义是 ，这个TestDemo类本身将会作为这块代码的Monitor</p>
<p>Monitor我们也可以自己定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object monitor1 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object monitor2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (monitor1) &#123;</span><br><span class="line">    x = newValue;   <span class="comment">// monitor</span></span><br><span class="line">    y = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (monitor1) &#123;</span><br><span class="line">    x -= delta;</span><br><span class="line">    y -= delta;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String newName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (monitor2) &#123;</span><br><span class="line">    name = newName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样可以给count和minus分配monitor1观察，setName用monitor2观察。</p>
<p>这里之所以用Object作为监视者是因为monitor本身只是一个标识位，具体监视行为交给Jvm即可，没必要特地使用Monitor类，而且省资源。</p>
<p>自己手动new，直接使用synchronized以及用this synchronized代码块会产生三个不同好的monitor。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p>有的时候我们不只要锁一个东西，在同一个代码块里面可能要锁两个东西。</p>
</li>
<li><p>当两个方法互相拿着对方的锁的时候就会造成死锁（count 方法想拿monitor2往下执行，恰巧此时setName方法想使用monitor1再继续往下执行，但是此时恰巧monitor都被对方占用等待释放，此时就会形成死锁，永远也无法释放）</p>
</li>
<li><p>单锁永远不会死锁，双锁才会。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object monitor1 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object monitor2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (monitor1) &#123;</span><br><span class="line">        x = newValue;   <span class="comment">// monitor</span></span><br><span class="line">        y = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (monitor2)&#123;</span><br><span class="line">        name =newValue+<span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String newName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (monitor2) &#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (monitor1)&#123;</span><br><span class="line">        x = <span class="number">1</span>;   <span class="comment">// monitor</span></span><br><span class="line">        y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><p>对于Android 线程应用场景比较简单，其实没有那么多乐观锁悲观锁问题。这是一个数据库问题，在大型的应用里面，比如web服务，每时每刻都有很多人访问数据库，可能很多人在同时间想改变数据库的某条数据然后存进数据库。</p>
<p>乐观锁，乐观并发控制：当我们修改数据时，如果遇到别人也在修改数据，我们撤回修改等其他人改完了再去改。我们乐观的认为其他人不会老这么做，如果别人老这么做就没法干了。当我们不太会冲突的时候一般这样做效率比较好，不用总使用很大的成本上锁。它的重点不在于锁，而在于不锁。</p>
<p>当我们想锁一个静态变量的时候有两个方法：</p>
<ol>
<li>用一个静态的monitor对象来观察它。</li>
<li>用class对象观察</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">//静态方法无法访问本地变量，所以也要改成静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//使用静态monitor观察静态方法的sychronized</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object monitor1 = <span class="keyword">new</span> Object(); </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object monitor2 = <span class="keyword">new</span> Object(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (monitor1) &#123;</span><br><span class="line">          x = newValue;   <span class="comment">// monitor</span></span><br><span class="line">          y = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//使用此时sychronized锁方法，和使用class对象观察等价，因为是静态方法所以不再能使用this对象观察，所以			//锁方法也是使用class对象观察</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Synchronized3.class) &#123;</span><br><span class="line">          x = newValue;   <span class="comment">// monitor</span></span><br><span class="line">          y = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//和用class对象观察等价,不再等价</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">          x = newValue;   <span class="comment">// monitor</span></span><br><span class="line">          y = newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><ul>
<li>保证加了 volatile 关键字的字段的操作具有同步性，以及对 long 和 double 的操作的原子性(long double 原子性这个简单说一下就行)。</li>
<li>因此 volatile 可以看做是简化版的 synchronized。volatile 只对基本类型 (byte、char、short、int、long、float、double、 boolean) 的赋值操作和对象的引用赋值操作有效，你要修改 User.name 是 不能保证同步的。</li>
<li> volatile 依然解决不了 ++ 的原子性问题。</li>
</ul>
<h4 id="例子1-1"><a href="#例子1-1" class="headerlink" title="例子1:"></a>例子1:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> <span class="keyword">implements</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (isRunning)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isRunning = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   volatile 关键字<br>  实际上，如果不加volatile关键字这个程序是不会停的，<br>   每个线程是使用一段独立的内存空间的，他们会把主线程中的变量拷过来单独处理再传回去，<br>  线程的每块内存和程序核心的内存（ 一般是使用你的操作系统，去利用cpu的高速缓存）反复交互，程序效率会很低，<br>   而独立区域，适时同步，效率会大幅度提升，可能会提高几倍。</p>
<p>  但是多个线程同时操作同一个变量的时候会造成错误，例如以上的代码，自线程拿到的running一直是true，<br>不去跟主线程同步，子线程就会一直执行下去。</p>
<p>  volatile就是强制打开变量的同步积极性，也就是每次执行的时候，<br> 子线程绝对不从自己的内存中读取变量，而是从主内存中读取，<br>  自线程修改变量后会马上同步给主线程。<br> 每次修改变量的时候都会先读取主线程中的变量，以防被其他变量修改。</p>
<p>   程序的效率降低了，但是安全性提升了。<br> 所以我们只有在需要的时候才打开它，比如用不同的线程操作相同的变量的时候。</p>
</blockquote>
<h3 id="java-util-concurrent-atomic包："><a href="#java-util-concurrent-atomic包：" class="headerlink" title="java.util.concurrent.atomic包："></a>java.util.concurrent.atomic包：</h3><p>下面有 AtomicInteger AtomicBoolean 等类，作用和 volatile 基本 一致，可以看做是通用版的 volatile。可以保证数据的原子性和数据同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">atomicInteger.getAndIncrement();</span><br><span class="line">atomicInteger。incrementAndGet();</span><br></pre></td></tr></table></figure>
<p>　　getAndIncrement()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　incrementAndGet()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从返回结果来看，getAndIncrement()返回的是原值，incrementAndGet()返回的是原值+1。那么大家是不是有种似曾相识的赶脚呢？？</p>
<p>没错！这就是i++和++i的原子操作。众所周知++i，i++，–i，i–这些操作都不是原子性的，在多线程下，我们要对这些操作加锁。</p>
<p> 补充：addAndGet(i)和getAndAdd(i)</p>
<p>当i=1时，这些方法可以两两互换，当i为其它，addAndGet(i)相当于a =+ i，getAndAdd(i)第一个值为原值，然后执行a=+i</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger a &#x3D; new AtomicInteger(0);</span><br><span class="line">System.out.println(a.getAndAdd(4));</span><br><span class="line"></span><br><span class="line">输出：0 4 8 12</span><br><span class="line"></span><br><span class="line">System.out.println(a.addAndGet(4));</span><br><span class="line"></span><br><span class="line">输出：4 8 12 16</span><br></pre></td></tr></table></figure>
<h2 id="Lock-ReentrantReadWriteLock（可重用锁）"><a href="#Lock-ReentrantReadWriteLock（可重用锁）" class="headerlink" title="Lock / ReentrantReadWriteLock（可重用锁）"></a>Lock / ReentrantReadWriteLock（可重用锁）</h2><ul>
<li><p>同样是「加锁」机制。但使用方式更灵活，同时也更麻烦一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">...</span><br><span class="line">lock.lock(); <span class="keyword">try</span> &#123;</span><br><span class="line">x++;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>finally 的作用:保证在方法提前结束或出现 Exception 的时候，依然 能正常释放锁。</p>
</blockquote>
</li>
<li><p>一般并不会只是使用 Lock ，而是会使用更复杂的锁，例如 ReadWriteLock :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">Lock readLock = lock.readLock(); </span><br><span class="line">Lock writeLock = lock.writeLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写的时候其他线程不可以拿来写</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> writeLock.lock(); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读的时候其他线程可以拿来读，但是不能写</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123; </span><br><span class="line">  readLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123; </span><br><span class="line">System.out.print(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(); </span><br><span class="line">&#125; </span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantReadWriteLock是JDK代码层面的锁，而synchronized是JVM关键字</p>
</li>
</ul>
<h2 id="线程安全问题的本质"><a href="#线程安全问题的本质" class="headerlink" title="线程安全问题的本质"></a>线程安全问题的本质</h2><p>在多个线程访问共同的资源时，在<strong>某一个线程</strong>对资源进行<strong>写操作的中途</strong>(写入已 经开始，但还没结束)，<strong>其他线程</strong>对这个写了一半的资源进行了<strong>读操作</strong>，或者基 于这个写了一半的资源进行了<strong>写操作</strong>，导致出现<strong>数据错误</strong>。</p>
<h2 id="锁机制的本质"><a href="#锁机制的本质" class="headerlink" title="锁机制的本质:"></a>锁机制的本质:</h2><p>通过对共享资源进行访问限制，让同一时间只有一个线程可以访问资源，保证了数据的准确性。</p>
<p>不论是线程安全问题，还是针对线程安全问题所衍生出的锁机制，它们的核心都在于共享的<strong>资源</strong>，而不是某个方法或者某几行代码。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/07/Koa%E5%85%A5%E9%97%A81-%E7%AE%80%E4%BB%8B%E5%92%8C%E5%8E%9F%E7%90%86/" rel="prev" title="Koa入门">
      <i class="fa fa-chevron-left"></i> Koa入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/22/%E6%AF%8F%E6%97%A5%E4%B8%89%E9%A2%98/" rel="next" title="每日三题">
      每日三题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">进程和线程(介绍)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.1.</span> <span class="nav-text">进程和线程的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">CPU 线程和操作系统线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.</span> <span class="nav-text">线程是什么:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UI-%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E7%BB%93%E6%9D%9F"><span class="nav-number">1.4.</span> <span class="nav-text">UI 线程为什么不会结束?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">多线程的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E5%BC%80%E5%90%AF%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">Java中开启线程的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-%E5%92%8C-Runnable"><span class="nav-number">2.2.</span> <span class="nav-text">Thread 和 Runnable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread"><span class="nav-number">2.2.1.</span> <span class="nav-text">Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable"><span class="nav-number">2.2.2.</span> <span class="nav-text">Runnable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadFactory"><span class="nav-number">2.3.</span> <span class="nav-text">ThreadFactory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.4.</span> <span class="nav-text">线程池的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.4.1.</span> <span class="nav-text">为什么引入线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.4.2.</span> <span class="nav-text">如何构建线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC%E5%8C%85%E4%B8%8BExecutors%E6%8F%90%E4%BE%9B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.4.3.</span> <span class="nav-text">JUC包下Executors提供的几种线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ExecutorService"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">ExecutorService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newCachedThreadPool-%E6%96%B0%E5%BB%BA%E7%BC%93%E5%AD%98%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">newCachedThreadPool 新建缓存线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newSingleThreadExecutor%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">newSingleThreadExecutor创建一个单线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newFixedThreadPool-%E5%9B%BA%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">newFixedThreadPool  固定线程数的线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newScheduledThreadPool-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1"><span class="nav-number">2.4.3.5.</span> <span class="nav-text">newScheduledThreadPool:延迟任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC"><span class="nav-number">2.4.4.</span> <span class="nav-text">线程池状态流转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execute-%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">2.4.5.</span> <span class="nav-text">execute 提交任务流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable"><span class="nav-number">2.5.</span> <span class="nav-text">Callable</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.</span> <span class="nav-text">线程同步和线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.1.</span> <span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E9%94%81%EF%BC%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">synchronized 关键字（锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%901"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">例子1:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%902%EF%BC%9A"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">例子2：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">3.1.2.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">3.1.3.</span> <span class="nav-text">悲观锁和乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.1.4.</span> <span class="nav-text">volatile 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%901-1"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">例子1:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-util-concurrent-atomic%E5%8C%85%EF%BC%9A"><span class="nav-number">3.1.5.</span> <span class="nav-text">java.util.concurrent.atomic包：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock-ReentrantReadWriteLock%EF%BC%88%E5%8F%AF%E9%87%8D%E7%94%A8%E9%94%81%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">Lock &#x2F; ReentrantReadWriteLock（可重用锁）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">3.3.</span> <span class="nav-text">线程安全问题的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">3.4.</span> <span class="nav-text">锁机制的本质:</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="oldnineping"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">oldnineping</p>
  <div class="site-description" itemprop="description">技术日记和杂七杂八的dx</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">oldnineping</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
